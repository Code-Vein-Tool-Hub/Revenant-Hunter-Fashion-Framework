#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Extensions

#include "Basic.hpp"

#include "Extensions_classes.hpp"
#include "Extensions_parameters.hpp"


namespace SDK
{

// Function Extensions.ColorPieceBase.GetColorData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharacterCustomizeDataTableColor*Data                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UColorPieceBase::GetColorData(struct FCharacterCustomizeDataTableColor* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "GetColorData");

	Params::ColorPieceBase_GetColorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function Extensions.ColorPieceBase.GetColorPaletteName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UColorPieceBase::GetColorPaletteName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "GetColorPaletteName");

	Params::ColorPieceBase_GetColorPaletteName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPieceBase.GetSpecialColorData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharacterCustomizeDataTableSpecialColor*Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UColorPieceBase::GetSpecialColorData(struct FCharacterCustomizeDataTableSpecialColor* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "GetSpecialColorData");

	Params::ColorPieceBase_GetSpecialColorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function Extensions.ColorPieceBase.OnSetColorData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterCustomizeDataTableColor&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UColorPieceBase::OnSetColorData(const struct FCharacterCustomizeDataTableColor& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "OnSetColorData");

	Params::ColorPieceBase_OnSetColorData Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ColorPieceBase.OnSetSpecialColorData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterCustomizeDataTableSpecialColor&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UColorPieceBase::OnSetSpecialColorData(const struct FCharacterCustomizeDataTableSpecialColor& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "OnSetSpecialColorData");

	Params::ColorPieceBase_OnSetSpecialColorData Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ColorPieceBase.PlayDecideEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UColorPieceBase::PlayDecideEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "PlayDecideEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ColorPieceBase.SetColorData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterCustomizeDataTableColor&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName&                      InPaletteName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPieceBase::SetColorData(const struct FCharacterCustomizeDataTableColor& Data, const class FName& InPaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "SetColorData");

	Params::ColorPieceBase_SetColorData Parms{};

	Parms.Data = std::move(Data);
	Parms.InPaletteName = InPaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPieceBase.SetSpecialColorData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterCustomizeDataTableSpecialColor&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName&                      InPaletteName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPieceBase::SetSpecialColorData(const struct FCharacterCustomizeDataTableSpecialColor& Data, const class FName& InPaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPieceBase", "SetSpecialColorData");

	Params::ColorPieceBase_SetSpecialColorData Parms{};

	Parms.Data = std::move(Data);
	Parms.InPaletteName = InPaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionCharacter.GetCharacterType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag AActionCharacter::GetCharacterType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCharacter", "GetCharacterType");

	Params::ActionCharacter_GetCharacterType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionCharacter.GetFallDistance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionCharacter::GetFallDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCharacter", "GetFallDistance");

	Params::ActionCharacter_GetFallDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionCharacter.IsInCinematic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionCharacter::IsInCinematic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCharacter", "IsInCinematic");

	Params::ActionCharacter_IsInCinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BodilessEnemy.OnEnemyEndPlay
// (Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          InEndPlayReason                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABodilessEnemy::OnEnemyEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BodilessEnemy", "OnEnemyEndPlay");

	Params::BodilessEnemy_OnEnemyEndPlay Parms{};

	Parms.InActor = InActor;
	Parms.InEndPlayReason = InEndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BodilessEnemy.RequestDropItem
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   InDropLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABodilessEnemy::RequestDropItem(const struct FVector& InDropLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BodilessEnemy", "RequestDropItem");

	Params::BodilessEnemy_RequestDropItem Parms{};

	Parms.InDropLocation = std::move(InDropLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.GetCurrentBattleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnemyModeId                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnemyModeId AEnemyCharacter::GetCurrentBattleMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "GetCurrentBattleMode");

	Params::EnemyCharacter_GetCurrentBattleMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyCharacter.K2_AbortSpawnEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InSpawnEffectName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::K2_AbortSpawnEffect(const class FName& InSpawnEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_AbortSpawnEffect");

	Params::EnemyCharacter_K2_AbortSpawnEffect Parms{};

	Parms.InSpawnEffectName = InSpawnEffectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.K2_AbortSpawnEffectAll
// (Final, Native, Public, BlueprintCallable)

void AEnemyCharacter::K2_AbortSpawnEffectAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_AbortSpawnEffectAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.K2_IsBurningState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnemyCharacter::K2_IsBurningState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_IsBurningState");

	Params::EnemyCharacter_K2_IsBurningState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyCharacter.K2_SpawnEffectAlways
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InEffectName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InAttachPointName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::K2_SpawnEffectAlways(const class FName& InEffectName, const class FName& InAttachPointName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_SpawnEffectAlways");

	Params::EnemyCharacter_K2_SpawnEffectAlways Parms{};

	Parms.InEffectName = InEffectName;
	Parms.InAttachPointName = InAttachPointName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.NetMulticastRegisterBossIndicator
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AEnemyCharacter::NetMulticastRegisterBossIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "NetMulticastRegisterBossIndicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.NetMulticastRequestPlayAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FEnemyRequestAnimationInfo&InInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AEnemyCharacter::NetMulticastRequestPlayAnimation(const struct FEnemyRequestAnimationInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "NetMulticastRequestPlayAnimation");

	Params::EnemyCharacter_NetMulticastRequestPlayAnimation Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.NetMulticastRequestVanishDeath
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   InVanishTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::NetMulticastRequestVanishDeath(float InVanishTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "NetMulticastRequestVanishDeath");

	Params::EnemyCharacter_NetMulticastRequestVanishDeath Parms{};

	Parms.InVanishTime = InVanishTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.NetMulticastStopAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::NetMulticastStopAnimation(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "NetMulticastStopAnimation");

	Params::EnemyCharacter_NetMulticastStopAnimation Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.OnEnemyLodChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   PrevLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::OnEnemyLodChanged(int32 PrevLevel, int32 NextLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "OnEnemyLodChanged");

	Params::EnemyCharacter_OnEnemyLodChanged Parms{};

	Parms.PrevLevel = PrevLevel;
	Parms.NextLevel = NextLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.OnPostVisualControlCreate
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCharacterVisualControlComponent* InVisualControl                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::OnPostVisualControlCreate(class UCharacterVisualControlComponent* InVisualControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "OnPostVisualControlCreate");

	Params::EnemyCharacter_OnPostVisualControlCreate Parms{};

	Parms.InVisualControl = InVisualControl;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyCharacter.ServerRegisterBossIndicator
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AEnemyCharacter::ServerRegisterBossIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "ServerRegisterBossIndicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.ServerRequestPlayAnimation
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// const struct FEnemyRequestAnimationInfo&InInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AEnemyCharacter::ServerRequestPlayAnimation(const struct FEnemyRequestAnimationInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "ServerRequestPlayAnimation");

	Params::EnemyCharacter_ServerRequestPlayAnimation Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.ServerStopAnimation
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyCharacter::ServerStopAnimation(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "ServerStopAnimation");

	Params::EnemyCharacter_ServerStopAnimation Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyCharacter.K2_GetEnemyParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UEnemyParameter*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UEnemyParameter* AEnemyCharacter::K2_GetEnemyParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_GetEnemyParameter");

	Params::EnemyCharacter_K2_GetEnemyParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyCharacter.K2_GetEnemyParameterMortalSin
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEnemyParameterMortalSin*        OutParameter                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnemyCharacter::K2_GetEnemyParameterMortalSin(struct FEnemyParameterMortalSin* OutParameter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyCharacter", "K2_GetEnemyParameterMortalSin");

	Params::EnemyCharacter_K2_GetEnemyParameterMortalSin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutParameter != nullptr)
		*OutParameter = std::move(Parms.OutParameter);

	return Parms.ReturnValue;
}


// Function Extensions.NetworkIndicatorUIObject.HideNetworkIndicator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNetworkIndicatorUIObject::HideNetworkIndicator(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NetworkIndicatorUIObject", "HideNetworkIndicator");

	Params::NetworkIndicatorUIObject_HideNetworkIndicator Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NetworkIndicatorUIObject.ShowNetworkIndicator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNetworkIndicatorUIObject::ShowNetworkIndicator(class UObject* InWorldContext, const class FText& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NetworkIndicatorUIObject", "ShowNetworkIndicator");

	Params::NetworkIndicatorUIObject_ShowNetworkIndicator Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NetworkIndicatorUIObject.HideNetworkIndicatorBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkIndicatorUIObject::HideNetworkIndicatorBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkIndicatorUIObject", "HideNetworkIndicatorBP");

	Params::NetworkIndicatorUIObject_HideNetworkIndicatorBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.NetworkIndicatorUIObject.ShowNetworkIndicatorBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkIndicatorUIObject::ShowNetworkIndicatorBP(const class FText& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkIndicatorUIObject", "ShowNetworkIndicatorBP");

	Params::NetworkIndicatorUIObject_ShowNetworkIndicatorBP Parms{};

	Parms.InMessage = std::move(InMessage);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.AppMenuBase.GetInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputAxis                              InInputAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppMenuBase::GetInputAxis(EInputAxis InInputAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppMenuBase", "GetInputAxis");

	Params::AppMenuBase_GetInputAxis Parms{};

	Parms.InInputAxis = InInputAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppMenuBase.GetMenuPieces
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UMenuPieceBase*>*          OutMenuPieces                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAppMenuBase::GetMenuPieces(TArray<class UMenuPieceBase*>* OutMenuPieces)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppMenuBase", "GetMenuPieces");

	Params::AppMenuBase_GetMenuPieces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMenuPieces != nullptr)
		*OutMenuPieces = std::move(Parms.OutMenuPieces);
}


// Function Extensions.AbilityTask_ActionHumanPlayMontage.CreateNetLocoPlayMontageAndWaitProxy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 InOwningAbility                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTaskInstanceName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     InMontageToPlay                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutDuration                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStartSection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbStopWhenAbilityEnds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimRootMotionTranslationScale                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartTimeSeconds                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ActionHumanPlayMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ActionHumanPlayMontage* UAbilityTask_ActionHumanPlayMontage::CreateNetLocoPlayMontageAndWaitProxy(class UGameplayAbility* InOwningAbility, class FName InTaskInstanceName, class UAnimMontage* InMontageToPlay, float* OutDuration, float InRate, class FName InStartSection, bool InbStopWhenAbilityEnds, float InAnimRootMotionTranslationScale, float InStartTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ActionHumanPlayMontage", "CreateNetLocoPlayMontageAndWaitProxy");

	Params::AbilityTask_ActionHumanPlayMontage_CreateNetLocoPlayMontageAndWaitProxy Parms{};

	Parms.InOwningAbility = InOwningAbility;
	Parms.InTaskInstanceName = InTaskInstanceName;
	Parms.InMontageToPlay = InMontageToPlay;
	Parms.InRate = InRate;
	Parms.InStartSection = InStartSection;
	Parms.InbStopWhenAbilityEnds = InbStopWhenAbilityEnds;
	Parms.InAnimRootMotionTranslationScale = InAnimRootMotionTranslationScale;
	Parms.InStartTimeSeconds = InStartTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDuration != nullptr)
		*OutDuration = Parms.OutDuration;

	return Parms.ReturnValue;
}


// Function Extensions.AbilityTask_ActionHumanPlayMontage.OnAnimNotifyBeginReceived
// (Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilityTask_ActionHumanPlayMontage::OnAnimNotifyBeginReceived(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, float InTotalDuration, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ActionHumanPlayMontage", "OnAnimNotifyBeginReceived");

	Params::AbilityTask_ActionHumanPlayMontage_OnAnimNotifyBeginReceived Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InTotalDuration = InTotalDuration;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AbilityTask_ActionHumanPlayMontage.OnAnimNotifyEndReceived
// (Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilityTask_ActionHumanPlayMontage::OnAnimNotifyEndReceived(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ActionHumanPlayMontage", "OnAnimNotifyEndReceived");

	Params::AbilityTask_ActionHumanPlayMontage_OnAnimNotifyEndReceived Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MultipleTutorialVolume.OnDescriptionWindowClosed
// (Native, Public)

void AMultipleTutorialVolume::OnDescriptionWindowClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultipleTutorialVolume", "OnDescriptionWindowClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MultipleTutorialVolume.OnEvaluationFormulaResultUpdated
// (Native, Public)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMultipleTutorialVolume::OnEvaluationFormulaResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultipleTutorialVolume", "OnEvaluationFormulaResultUpdated");

	Params::MultipleTutorialVolume_OnEvaluationFormulaResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.EndInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInteractionActorAndPrimitiveComponentPair&InIgnorePair                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AInteractiveActor::EndInteraction(class AActor* InActor, const struct FInteractionActorAndPrimitiveComponentPair& InIgnorePair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "EndInteraction");

	Params::InteractiveActor_EndInteraction Parms{};

	Parms.InActor = InActor;
	Parms.InIgnorePair = std::move(InIgnorePair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.NetMulticastRequestSyncronizedNotify
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const double                            InTime                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::NetMulticastRequestSyncronizedNotify(const double InTime, const struct FGameplayTag& InTag, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "NetMulticastRequestSyncronizedNotify");

	Params::InteractiveActor_NetMulticastRequestSyncronizedNotify Parms{};

	Parms.InTime = InTime;
	Parms.InTag = std::move(InTag);
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.OnAnyActorEntersInteractionArea
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AInteractiveActor::OnAnyActorEntersInteractionArea(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnAnyActorEntersInteractionArea");

	Params::InteractiveActor_OnAnyActorEntersInteractionArea Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.OnAnyActorLeavesInteractionArea
// (Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::OnAnyActorLeavesInteractionArea(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnAnyActorLeavesInteractionArea");

	Params::InteractiveActor_OnAnyActorLeavesInteractionArea Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.OnFocused_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::OnFocused_BP(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnFocused_BP");

	Params::InteractiveActor_OnFocused_BP Parms{};

	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.InteractiveActor.OnInteractionBegin_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InTriggerOptionIndex                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::OnInteractionBegin_BP(class AActor* InActor, const int32 InTriggerOptionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnInteractionBegin_BP");

	Params::InteractiveActor_OnInteractionBegin_BP Parms{};

	Parms.InActor = InActor;
	Parms.InTriggerOptionIndex = InTriggerOptionIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.InteractiveActor.OnInteractionEnd_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::OnInteractionEnd_BP(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnInteractionEnd_BP");

	Params::InteractiveActor_OnInteractionEnd_BP Parms{};

	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.InteractiveActor.OnRep_ReplicatedExistence
// (Final, Native, Protected)

void AInteractiveActor::OnRep_ReplicatedExistence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnRep_ReplicatedExistence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.OnUnfocused_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::OnUnfocused_BP(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "OnUnfocused_BP");

	Params::InteractiveActor_OnUnfocused_BP Parms{};

	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.InteractiveActor.RegisterAsTrigger
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::RegisterAsTrigger(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "RegisterAsTrigger");

	Params::InteractiveActor_RegisterAsTrigger Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.SetCanInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bInCanInteract                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::SetCanInteract(const bool bInCanInteract, const class FString& InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "SetCanInteract");

	Params::InteractiveActor_SetCanInteract Parms{};

	Parms.bInCanInteract = bInCanInteract;
	Parms.InID = std::move(InID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractiveActor.GetUniqueSaveID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AInteractiveActor::GetUniqueSaveID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "GetUniqueSaveID");

	Params::InteractiveActor_GetUniqueSaveID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InteractiveActor.SetupInteractionInfo
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FInteraction*                    OutInteraction                                         (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionComponent*            InInteractionComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveActor::SetupInteractionInfo(struct FInteraction* OutInteraction, class AActor* InActor, class UInteractionComponent* InInteractionComponent, class UPrimitiveComponent* InOverlappedComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveActor", "SetupInteractionInfo");

	Params::InteractiveActor_SetupInteractionInfo Parms{};

	Parms.InActor = InActor;
	Parms.InInteractionComponent = InInteractionComponent;
	Parms.InOverlappedComponent = InOverlappedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteraction != nullptr)
		*OutInteraction = std::move(Parms.OutInteraction);
}


// Function Extensions.AbilityTask_MountAnimPlayAndWait.CreatePlayMountMontageAndWaitProxy
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 InOwningAbility                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTaskInstanceName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     InRiderMontageToPlay                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     InMountMontageToPlay                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutDuration                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStartSection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbStopWhenAbilityEnds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimRootMotionTranslationScale                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartTimeSeconds                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_MountAnimPlayAndWait*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_MountAnimPlayAndWait* UAbilityTask_MountAnimPlayAndWait::CreatePlayMountMontageAndWaitProxy(class UGameplayAbility* InOwningAbility, class FName InTaskInstanceName, class UAnimMontage* InRiderMontageToPlay, class UAnimMontage* InMountMontageToPlay, float* OutDuration, float InRate, class FName InStartSection, bool InbStopWhenAbilityEnds, float InAnimRootMotionTranslationScale, float InStartTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_MountAnimPlayAndWait", "CreatePlayMountMontageAndWaitProxy");

	Params::AbilityTask_MountAnimPlayAndWait_CreatePlayMountMontageAndWaitProxy Parms{};

	Parms.InOwningAbility = InOwningAbility;
	Parms.InTaskInstanceName = InTaskInstanceName;
	Parms.InRiderMontageToPlay = InRiderMontageToPlay;
	Parms.InMountMontageToPlay = InMountMontageToPlay;
	Parms.InRate = InRate;
	Parms.InStartSection = InStartSection;
	Parms.InbStopWhenAbilityEnds = InbStopWhenAbilityEnds;
	Parms.InAnimRootMotionTranslationScale = InAnimRootMotionTranslationScale;
	Parms.InStartTimeSeconds = InStartTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDuration != nullptr)
		*OutDuration = Parms.OutDuration;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionControlComponent.K2_EmotionAbort
// (Final, Native, Public, BlueprintCallable)

void UEmotionControlComponent::K2_EmotionAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionControlComponent", "K2_EmotionAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionControlComponent.K2_EmotionForceAbort
// (Final, Native, Public, BlueprintCallable)

void UEmotionControlComponent::K2_EmotionForceAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionControlComponent", "K2_EmotionForceAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionControlComponent.K2_EmotionForceEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionControlComponent::K2_EmotionForceEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionControlComponent", "K2_EmotionForceEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionControlComponent.OnRep_ReplicatedRequestEmotionInfo
// (Final, Native, Protected)

void UEmotionControlComponent::OnRep_ReplicatedRequestEmotionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionControlComponent", "OnRep_ReplicatedRequestEmotionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionControlComponent.Server_ReqestPlayEmotion
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FReplicateRequestEmotionInfo&InRequestEmotionInfo                                   (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEmotionControlComponent::Server_ReqestPlayEmotion(const struct FReplicateRequestEmotionInfo& InRequestEmotionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionControlComponent", "Server_ReqestPlayEmotion");

	Params::EmotionControlComponent_Server_ReqestPlayEmotion Parms{};

	Parms.InRequestEmotionInfo = std::move(InRequestEmotionInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.GetCurrentEmotionSlot
// (Final, Native, Public)
// Parameters:
// const EEmotionSlot                      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EEmotionSlot UPlayerEmotionControlComponent::GetCurrentEmotionSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetCurrentEmotionSlot");

	Params::PlayerEmotionControlComponent_GetCurrentEmotionSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEmotionControlComponent.GetEmotionIndexNumber
// (Final, Native, Public)
// Parameters:
// const EEmotionEntry                     InEntry                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEmotionControlComponent::GetEmotionIndexNumber(const EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetEmotionIndexNumber");

	Params::PlayerEmotionControlComponent_GetEmotionIndexNumber Parms{};

	Parms.InEntry = InEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEmotionControlComponent.GetEmotionSlotUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const EEmotionSlot                      InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionShowUIInfo*              OutUIInfo                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::GetEmotionSlotUIInfo(const EEmotionSlot InSlot, struct FEmotionShowUIInfo* OutUIInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetEmotionSlotUIInfo");

	Params::PlayerEmotionControlComponent_GetEmotionSlotUIInfo Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUIInfo != nullptr)
		*OutUIInfo = std::move(Parms.OutUIInfo);
}


// Function Extensions.PlayerEmotionControlComponent.GetGestureUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams)
// Parameters:
// const uint32                            InAvailableIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionGestureUIInfo*           OutGestureInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::GetGestureUIInfoByAvailableIndex(const uint32 InAvailableIndex, struct FEmotionGestureUIInfo* OutGestureInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetGestureUIInfoByAvailableIndex");

	Params::PlayerEmotionControlComponent_GetGestureUIInfoByAvailableIndex Parms{};

	Parms.InAvailableIndex = InAvailableIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGestureInfo != nullptr)
		*OutGestureInfo = std::move(Parms.OutGestureInfo);
}


// Function Extensions.PlayerEmotionControlComponent.GetIndexCurentSlotEntry
// (Final, Native, Public)
// Parameters:
// const EEmotionEntry                     InEntry                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEmotionControlComponent::GetIndexCurentSlotEntry(const EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetIndexCurentSlotEntry");

	Params::PlayerEmotionControlComponent_GetIndexCurentSlotEntry Parms{};

	Parms.InEntry = InEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEmotionControlComponent.GetStampUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams)
// Parameters:
// const uint32                            InAvailableIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionStampUIInfo*             OutStampInfo                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::GetStampUIInfoByAvailableIndex(const uint32 InAvailableIndex, struct FEmotionStampUIInfo* OutStampInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetStampUIInfoByAvailableIndex");

	Params::PlayerEmotionControlComponent_GetStampUIInfoByAvailableIndex Parms{};

	Parms.InAvailableIndex = InAvailableIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStampInfo != nullptr)
		*OutStampInfo = std::move(Parms.OutStampInfo);
}


// Function Extensions.PlayerEmotionControlComponent.GetVoiceUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams)
// Parameters:
// const uint32                            InAvailableIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionVoiceUIInfo*             OutVoiceInfo                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::GetVoiceUIInfoByAvailableIndex(const uint32 InAvailableIndex, struct FEmotionVoiceUIInfo* OutVoiceInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "GetVoiceUIInfoByAvailableIndex");

	Params::PlayerEmotionControlComponent_GetVoiceUIInfoByAvailableIndex Parms{};

	Parms.InAvailableIndex = InAvailableIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVoiceInfo != nullptr)
		*OutVoiceInfo = std::move(Parms.OutVoiceInfo);
}


// Function Extensions.PlayerEmotionControlComponent.InitVoiceSubtitles
// (Final, Native, Protected)

void UPlayerEmotionControlComponent::InitVoiceSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "InitVoiceSubtitles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.OnVoicePlay
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FOnAppAudioVoicePlayParam& InParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bInPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::OnVoicePlay(const struct FOnAppAudioVoicePlayParam& InParam, bool bInPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "OnVoicePlay");

	Params::PlayerEmotionControlComponent_OnVoicePlay Parms{};

	Parms.InParam = std::move(InParam);
	Parms.bInPlay = bInPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.RequestPlayEmotionbyAvailableIndex
// (Final, Native, Public)
// Parameters:
// const struct FRequestEmotionByIndexInfo&InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::RequestPlayEmotionbyAvailableIndex(const struct FRequestEmotionByIndexInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "RequestPlayEmotionbyAvailableIndex");

	Params::PlayerEmotionControlComponent_RequestPlayEmotionbyAvailableIndex Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.RequestPlayEmotionSlot
// (Final, Native, Public)
// Parameters:
// EEmotionSlot                            InSlot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::RequestPlayEmotionSlot(EEmotionSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "RequestPlayEmotionSlot");

	Params::PlayerEmotionControlComponent_RequestPlayEmotionSlot Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.SetCurrentEmotionSlot
// (Final, Native, Public)
// Parameters:
// const EEmotionSlot                      InEmotionUISlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::SetCurrentEmotionSlot(const EEmotionSlot InEmotionUISlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "SetCurrentEmotionSlot");

	Params::PlayerEmotionControlComponent_SetCurrentEmotionSlot Parms{};

	Parms.InEmotionUISlot = InEmotionUISlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.SetCurrentSlotGesutureByIndex
// (Final, Native, Public)
// Parameters:
// const uint32                            InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsFemale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::SetCurrentSlotGesutureByIndex(const uint32 InIndex, bool bInIsFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "SetCurrentSlotGesutureByIndex");

	Params::PlayerEmotionControlComponent_SetCurrentSlotGesutureByIndex Parms{};

	Parms.InIndex = InIndex;
	Parms.bInIsFemale = bInIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.SetCurrentSlotStampByIndex
// (Final, Native, Public)
// Parameters:
// const uint32                            InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::SetCurrentSlotStampByIndex(const uint32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "SetCurrentSlotStampByIndex");

	Params::PlayerEmotionControlComponent_SetCurrentSlotStampByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.SetCurrentSlotVoiceByIndex
// (Final, Native, Public)
// Parameters:
// const uint32                            InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEmotionControlComponent::SetCurrentSlotVoiceByIndex(const uint32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "SetCurrentSlotVoiceByIndex");

	Params::PlayerEmotionControlComponent_SetCurrentSlotVoiceByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEmotionControlComponent.UpdateAvailableRowNames
// (Final, Native, Public)

void UPlayerEmotionControlComponent::UpdateAvailableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEmotionControlComponent", "UpdateAvailableRowNames");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.YadorigiBase.OnRep_ReplicatedReplicatedAppearance
// (Final, Native, Protected)

void AYadorigiBase::OnRep_ReplicatedReplicatedAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiBase", "OnRep_ReplicatedReplicatedAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.YadorigiBase.ServerEndInteraction
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AYadorigiBase::ServerEndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiBase", "ServerEndInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.YadorigiBase.UpdateEffects_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FYadorigiAppearance&       InYadorigiAppearance                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AYadorigiBase::UpdateEffects_BP(const struct FYadorigiAppearance& InYadorigiAppearance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiBase", "UpdateEffects_BP");

	Params::YadorigiBase_UpdateEffects_BP Parms{};

	Parms.InYadorigiAppearance = std::move(InYadorigiAppearance);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.YadorigiTeleportPoint.OnDecide
// (Final, Native, Private)
// Parameters:
// uint8                                   InDecideOptionNumber                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYadorigiTeleportPoint::OnDecide(uint8 InDecideOptionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiTeleportPoint", "OnDecide");

	Params::YadorigiTeleportPoint_OnDecide Parms{};

	Parms.InDecideOptionNumber = InDecideOptionNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.YadorigiTeleportPoint.OnExistenceUpdated_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bInExistence                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYadorigiTeleportPoint::OnExistenceUpdated_BP(const bool bInExistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiTeleportPoint", "OnExistenceUpdated_BP");

	Params::YadorigiTeleportPoint_OnExistenceUpdated_BP Parms{};

	Parms.bInExistence = bInExistence;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.YadorigiTeleportPoint.OnUIClosed
// (Final, Native, Private)

void AYadorigiTeleportPoint::OnUIClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YadorigiTeleportPoint", "OnUIClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Acid
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Acid(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Acid");

	Params::AccumulativeStatusAttributeSet_OnRep_Acid Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Blood
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Blood(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Blood");

	Params::AccumulativeStatusAttributeSet_OnRep_Blood Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Capture
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Capture(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Capture");

	Params::AccumulativeStatusAttributeSet_OnRep_Capture Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Curse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Curse(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Curse");

	Params::AccumulativeStatusAttributeSet_OnRep_Curse Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_DeadlyVenom
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_DeadlyVenom(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_DeadlyVenom");

	Params::AccumulativeStatusAttributeSet_OnRep_DeadlyVenom Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Disease
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Disease(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Disease");

	Params::AccumulativeStatusAttributeSet_OnRep_Disease Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Dissonance
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Dissonance(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Dissonance");

	Params::AccumulativeStatusAttributeSet_OnRep_Dissonance Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Eclipse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Eclipse(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Eclipse");

	Params::AccumulativeStatusAttributeSet_OnRep_Eclipse Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_FatalLeak
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_FatalLeak(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_FatalLeak");

	Params::AccumulativeStatusAttributeSet_OnRep_FatalLeak Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Leak
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Leak(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Leak");

	Params::AccumulativeStatusAttributeSet_OnRep_Leak Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Moon
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Moon(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Moon");

	Params::AccumulativeStatusAttributeSet_OnRep_Moon Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Rinne
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Rinne(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Rinne");

	Params::AccumulativeStatusAttributeSet_OnRep_Rinne Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Slow
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Slow(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Slow");

	Params::AccumulativeStatusAttributeSet_OnRep_Slow Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Stall
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Stall(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Stall");

	Params::AccumulativeStatusAttributeSet_OnRep_Stall Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Stone
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Stone(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Stone");

	Params::AccumulativeStatusAttributeSet_OnRep_Stone Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Stun
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Stun(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Stun");

	Params::AccumulativeStatusAttributeSet_OnRep_Stun Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Sun
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Sun(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Sun");

	Params::AccumulativeStatusAttributeSet_OnRep_Sun Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Vanish
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Vanish(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Vanish");

	Params::AccumulativeStatusAttributeSet_OnRep_Vanish Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Venom
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Venom(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Venom");

	Params::AccumulativeStatusAttributeSet_OnRep_Venom Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulativeStatusAttributeSet.OnRep_Wound
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAccumulativeStatusAttributeSet::OnRep_Wound(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccumulativeStatusAttributeSet", "OnRep_Wound");

	Params::AccumulativeStatusAttributeSet_OnRep_Wound Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppLevelSequencePlayer.CreateAppLevelSequencePlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneSequencePlaybackSettings&Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AAppLevelSequenceActor**          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAppLevelSequencePlayer*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppLevelSequencePlayer* UAppLevelSequencePlayer::CreateAppLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, class AAppLevelSequenceActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppLevelSequencePlayer", "CreateAppLevelSequencePlayer");

	Params::AppLevelSequencePlayer_CreateAppLevelSequencePlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelSequence = LevelSequence;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function Extensions.AppLevelSequencePlayer.CreateLevelSequencePlayer_NoOverrideAspectRatioAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneSequencePlaybackSettings&Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ALevelSequenceActor**             OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequencePlayer*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequencePlayer* UAppLevelSequencePlayer::CreateLevelSequencePlayer_NoOverrideAspectRatioAxis(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, class ALevelSequenceActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppLevelSequencePlayer", "CreateLevelSequencePlayer_NoOverrideAspectRatioAxis");

	Params::AppLevelSequencePlayer_CreateLevelSequencePlayer_NoOverrideAspectRatioAxis Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelSequence = LevelSequence;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function Extensions.AppLevelSequencePlayer.StartSequenceEventFunction
// (Final, Native, Public)

void UAppLevelSequencePlayer::StartSequenceEventFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppLevelSequencePlayer", "StartSequenceEventFunction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppLevelSequencePlayer.StopSequenceEventFunction
// (Final, Native, Public)

void UAppLevelSequencePlayer::StopSequenceEventFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppLevelSequencePlayer", "StopSequenceEventFunction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.BreakUpSessionWithReason
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::BreakUpSessionWithReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "BreakUpSessionWithReason");

	Params::AppOnlineSessionManager_BreakUpSessionWithReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.CreateSessionWithMapName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InMapName                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMatchCondition>*         InMatchConditions                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bInUseInvite                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::CreateSessionWithMapName(const class FString& InMapName, TArray<struct FMatchCondition>* InMatchConditions, bool bInUseInvite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "CreateSessionWithMapName");

	Params::AppOnlineSessionManager_CreateSessionWithMapName Parms{};

	Parms.InMapName = std::move(InMapName);
	Parms.bInUseInvite = bInUseInvite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InMatchConditions != nullptr)
		*InMatchConditions = std::move(Parms.InMatchConditions);
}


// Function Extensions.AppOnlineSessionManager.GetCurrentMapPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAppOnlineSessionManager::GetCurrentMapPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "GetCurrentMapPath");

	Params::AppOnlineSessionManager_GetCurrentMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppOnlineSessionManager.HideOnlineDebugMenu
// (Final, Native, Public, BlueprintCallable)

void UAppOnlineSessionManager::HideOnlineDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "HideOnlineDebugMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.IsOnlineMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppOnlineSessionManager::IsOnlineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "IsOnlineMode");

	Params::AppOnlineSessionManager_IsOnlineMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppOnlineSessionManager.LeaveSessionWithReason
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::LeaveSessionWithReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "LeaveSessionWithReason");

	Params::AppOnlineSessionManager_LeaveSessionWithReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.ServerTravelOnly
// (Final, Native, Public, BlueprintCallable)

void UAppOnlineSessionManager::ServerTravelOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "ServerTravelOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.ServerTravelOnlyTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InTestMapName                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::ServerTravelOnlyTest(const class FString& InTestMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "ServerTravelOnlyTest");

	Params::AppOnlineSessionManager_ServerTravelOnlyTest Parms{};

	Parms.InTestMapName = std::move(InTestMapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.SetOnlineMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOnlineMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::SetOnlineMode(bool bIsOnlineMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "SetOnlineMode");

	Params::AppOnlineSessionManager_SetOnlineMode Parms{};

	Parms.bIsOnlineMode = bIsOnlineMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.SetSessionCompressedCharacterCustomizeParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterCustomizeParameter&InCharacterCustomizeParameter                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAppOnlineSessionManager::SetSessionCompressedCharacterCustomizeParameter(const struct FCharacterCustomizeParameter& InCharacterCustomizeParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "SetSessionCompressedCharacterCustomizeParameter");

	Params::AppOnlineSessionManager_SetSessionCompressedCharacterCustomizeParameter Parms{};

	Parms.InCharacterCustomizeParameter = std::move(InCharacterCustomizeParameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppOnlineSessionManager.ShowOnlineDebugMenu
// (Final, Native, Public, BlueprintCallable)

void UAppOnlineSessionManager::ShowOnlineDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppOnlineSessionManager", "ShowOnlineDebugMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyLayerAnimInstance.GetCharacterAnimParameter
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterAnimParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterAnimParameter UEnemyLayerAnimInstance::GetCharacterAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLayerAnimInstance", "GetCharacterAnimParameter");

	Params::EnemyLayerAnimInstance_GetCharacterAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLayerAnimInstance.GetEnemyAnimInstance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UEnemyAnimInstance*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UEnemyAnimInstance* UEnemyLayerAnimInstance::GetEnemyAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLayerAnimInstance", "GetEnemyAnimInstance");

	Params::EnemyLayerAnimInstance_GetEnemyAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLayerAnimInstance.GetEnemyAnimParameter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FEnemyAnimParameter        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEnemyAnimParameter UEnemyLayerAnimInstance::GetEnemyAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLayerAnimInstance", "GetEnemyAnimParameter");

	Params::EnemyLayerAnimInstance_GetEnemyAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLayerAnimInstance.GetMainInstanceCachedCurveValue
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnemyLayerAnimInstance::GetMainInstanceCachedCurveValue(class FName CurveName, float DefaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLayerAnimInstance", "GetMainInstanceCachedCurveValue");

	Params::EnemyLayerAnimInstance_GetMainInstanceCachedCurveValue Parms{};

	Parms.CurveName = CurveName;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemySkeletalControlAnimInstance.GetLookAtAnimParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimLookAtParameter       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimLookAtParameter UEnemySkeletalControlAnimInstance::GetLookAtAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySkeletalControlAnimInstance", "GetLookAtAnimParameter");

	Params::EnemySkeletalControlAnimInstance_GetLookAtAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SimpleAnimNotify.K2_GetParameterMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName USimpleAnimNotify::K2_GetParameterMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleAnimNotify", "K2_GetParameterMessage");

	Params::SimpleAnimNotify_K2_GetParameterMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimationControlComponent.SetIKConditionForCinema
// (Native, Public, BlueprintCallable)
// Parameters:
// EAppAnimationAdjustMask                 AdjustType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationControlComponent::SetIKConditionForCinema(EAppAnimationAdjustMask AdjustType, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationControlComponent", "SetIKConditionForCinema");

	Params::AnimationControlComponent_SetIKConditionForCinema Parms{};

	Parms.AdjustType = AdjustType;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AnimationControlComponent.SetPermanentAnimClassLayer
// (Native, Protected, BlueprintCallable)

void UAnimationControlComponent::SetPermanentAnimClassLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationControlComponent", "SetPermanentAnimClassLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppAnimInstance.OnAnimMontageBlendingOut
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppAnimInstance::OnAnimMontageBlendingOut(class UAnimMontage* InMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppAnimInstance", "OnAnimMontageBlendingOut");

	Params::AppAnimInstance_OnAnimMontageBlendingOut Parms{};

	Parms.InMontage = InMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppAnimInstance.OnAnimMontageStarted
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppAnimInstance::OnAnimMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppAnimInstance", "OnAnimMontageStarted");

	Params::AppAnimInstance_OnAnimMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppAnimInstance.GetCachedCurveValueWithDefaultValue
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppAnimInstance::GetCachedCurveValueWithDefaultValue(class FName CurveName, float DefaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppAnimInstance", "GetCachedCurveValueWithDefaultValue");

	Params::AppAnimInstance_GetCachedCurveValueWithDefaultValue Parms{};

	Parms.CurveName = CurveName;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.BeginTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceSync                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::BeginTrail(class UNiagaraComponent* InNiagaraComponent, bool bInForceSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "BeginTrail");

	Params::AppNiagaraUtility_BeginTrail Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;
	Parms.bInForceSync = bInForceSync;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.BeginTrailByDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  InAttachComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InFirstSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSecondSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         InWidthScaleMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidthScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceSync                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::BeginTrailByDelegate(class UNiagaraComponent* InNiagaraComponent, class USceneComponent* InAttachComponent, class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthScaleMode, float InWidthScale, bool bInForceSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "BeginTrailByDelegate");

	Params::AppNiagaraUtility_BeginTrailByDelegate Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;
	Parms.InAttachComponent = InAttachComponent;
	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthScaleMode = InWidthScaleMode;
	Parms.InWidthScale = InWidthScale;
	Parms.bInForceSync = bInForceSync;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.EndTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::EndTrail(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "EndTrail");

	Params::AppNiagaraUtility_EndTrail Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.EndTrailByDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::EndTrailByDelegate(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "EndTrailByDelegate");

	Params::AppNiagaraUtility_EndTrailByDelegate Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.IsEnableTrailDebug
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::IsEnableTrailDebug(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "IsEnableTrailDebug");

	Params::AppNiagaraUtility_IsEnableTrailDebug Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.IsEnableTrailSubstep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::IsEnableTrailSubstep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "IsEnableTrailSubstep");

	Params::AppNiagaraUtility_IsEnableTrailSubstep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppNiagaraUtility.SetEnableTrailDebug
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEnableTrailDebug                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppNiagaraUtility::SetEnableTrailDebug(class UObject* InObject, bool bInEnableTrailDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "SetEnableTrailDebug");

	Params::AppNiagaraUtility_SetEnableTrailDebug Parms{};

	Parms.InObject = InObject;
	Parms.bInEnableTrailDebug = bInEnableTrailDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppNiagaraUtility.SetEnableTrailSubstep
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnableTrailSubstep                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppNiagaraUtility::SetEnableTrailSubstep(bool bInEnableTrailSubstep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "SetEnableTrailSubstep");

	Params::AppNiagaraUtility_SetEnableTrailSubstep Parms{};

	Parms.bInEnableTrailSubstep = bInEnableTrailSubstep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppNiagaraUtility.UpdateTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  InAttachComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InFirstSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSecondSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         InWidthScaleMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidthScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceSync                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppNiagaraUtility::UpdateTrail(class UNiagaraComponent* InNiagaraComponent, class USceneComponent* InAttachComponent, class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthScaleMode, float InWidthScale, bool bInForceSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraUtility", "UpdateTrail");

	Params::AppNiagaraUtility_UpdateTrail Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;
	Parms.InAttachComponent = InAttachComponent;
	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthScaleMode = InWidthScaleMode;
	Parms.InWidthScale = InWidthScale;
	Parms.bInForceSync = bInForceSync;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionAnimInstance.GetCharacterAnimParameter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterAnimParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterAnimParameter UActionAnimInstance::GetCharacterAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAnimInstance", "GetCharacterAnimParameter");

	Params::ActionAnimInstance_GetCharacterAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditMenu.EditEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteEditMenu::EditEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "EditEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditMenu.EmotionPaletteEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteEditMenu::EmotionPaletteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "EmotionPaletteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditMenu.GetEditSlotWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// EEmotionSlot                            InSlot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteEditMenu::GetEditSlotWidget(EEmotionSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "GetEditSlotWidget");

	Params::EmotionPaletteEditMenu_GetEditSlotWidget Parms{};

	Parms.InSlot = InSlot;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditMenu.RequestEmotionPaletteCurrentSlot
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteEditMenu::RequestEmotionPaletteCurrentSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "RequestEmotionPaletteCurrentSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditMenu.SelectLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditMenu::SelectLeft(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "SelectLeft");

	Params::EmotionPaletteEditMenu_SelectLeft Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditMenu.SelectRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditMenu::SelectRight(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditMenu", "SelectRight");

	Params::EmotionPaletteEditMenu_SelectRight Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SWITCH.OnInteractionResultConfirmed_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const ESwitchInteractionResult          InResult                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASWITCH::OnInteractionResultConfirmed_BP(const ESwitchInteractionResult InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SWITCH", "OnInteractionResultConfirmed_BP");

	Params::SWITCH_OnInteractionResultConfirmed_BP Parms{};

	Parms.InResult = InResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.SWITCH.OnStoryFlagRequirementsResultUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASWITCH::OnStoryFlagRequirementsResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SWITCH", "OnStoryFlagRequirementsResultUpdated");

	Params::SWITCH_OnStoryFlagRequirementsResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Lever.NetMulticastPlayAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::NetMulticastPlayAnimation(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "NetMulticastPlayAnimation");

	Params::Lever_NetMulticastPlayAnimation Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArchiveMenuUIObject.BindOnChangeControlType
// (Final, Native, Public, BlueprintCallable)

void UArchiveMenuUIObject::BindOnChangeControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "BindOnChangeControlType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArchiveMenuUIObject.GetControlType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESupportMenuControlType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESupportMenuControlType UArchiveMenuUIObject::GetControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "GetControlType");

	Params::ArchiveMenuUIObject_GetControlType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArchiveMenuUIObject.GetDebugAllArchiveItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArchiveMenuUIObject::GetDebugAllArchiveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "GetDebugAllArchiveItem");

	Params::ArchiveMenuUIObject_GetDebugAllArchiveItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArchiveMenuUIObject.OnChangeControlType
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESupportMenuControlType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArchiveMenuUIObject::OnChangeControlType(ESupportMenuControlType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "OnChangeControlType");

	Params::ArchiveMenuUIObject_OnChangeControlType Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ArchiveMenuUIObject.OnChangeControlTypeCallback
// (Final, Native, Protected)
// Parameters:
// ESupportMenuControlType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArchiveMenuUIObject::OnChangeControlTypeCallback(ESupportMenuControlType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "OnChangeControlTypeCallback");

	Params::ArchiveMenuUIObject_OnChangeControlTypeCallback Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArchiveMenuUIObject.StartQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UQuestSystemAsset> QuestSystemAsset                                       (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArchiveMenuUIObject::StartQuest(TSoftObjectPtr<class UQuestSystemAsset> QuestSystemAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveMenuUIObject", "StartQuest");

	Params::ArchiveMenuUIObject_StartQuest Parms{};

	Parms.QuestSystemAsset = QuestSystemAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanAbilitySystem.GetActiveAbilityInstances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 InAbility                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayAbility*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGameplayAbility*> UActionHumanAbilitySystem::GetActiveAbilityInstances(class UGameplayAbility* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAbilitySystem", "GetActiveAbilityInstances");

	Params::ActionHumanAbilitySystem_GetActiveAbilityInstances Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAbilitySystem.GiveAbilityIfNotGranted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     InAbility                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UActionHumanAbilitySystem::GiveAbilityIfNotGranted(TSubclassOf<class UGameplayAbility> InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAbilitySystem", "GiveAbilityIfNotGranted");

	Params::ActionHumanAbilitySystem_GiveAbilityIfNotGranted Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAbilitySystem.HandleGameplayEvent_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventTag                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEventData&        Payload                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActionHumanAbilitySystem::HandleGameplayEvent_BP(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAbilitySystem", "HandleGameplayEvent_BP");

	Params::ActionHumanAbilitySystem_HandleGameplayEvent_BP Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.CallEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::CallEvent(class FName InName, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "CallEvent");

	Params::VisualControlComponent_CallEvent Parms{};

	Parms.InName = InName;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.FindReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UVisualControlComponent::FindReference(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "FindReference");

	Params::VisualControlComponent_FindReference Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.FindReferences
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InContainName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UVisualControlComponent::FindReferences(class FName InContainName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "FindReferences");

	Params::VisualControlComponent_FindReferences Parms{};

	Parms.InContainName = InContainName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.GetFloatVariable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  InValue                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::GetFloatVariable(class FName InName, float* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "GetFloatVariable");

	Params::VisualControlComponent_GetFloatVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InValue != nullptr)
		*InValue = Parms.InValue;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.GetTransformVariable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      InValue                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::GetTransformVariable(class FName InName, struct FTransform* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "GetTransformVariable");

	Params::VisualControlComponent_GetTransformVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InValue != nullptr)
		*InValue = std::move(Parms.InValue);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.GetVectorVariable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         InValue                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::GetVectorVariable(class FName InName, struct FVector* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "GetVectorVariable");

	Params::VisualControlComponent_GetVectorVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InValue != nullptr)
		*InValue = std::move(Parms.InValue);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.RegisterReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::RegisterReference(class FName InName, class UActorComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "RegisterReference");

	Params::VisualControlComponent_RegisterReference Parms{};

	Parms.InName = InName;
	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.RemoveFloatVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::RemoveFloatVariable(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "RemoveFloatVariable");

	Params::VisualControlComponent_RemoveFloatVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.RemoveTransformVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::RemoveTransformVariable(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "RemoveTransformVariable");

	Params::VisualControlComponent_RemoveTransformVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.RemoveVectorVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::RemoveVectorVariable(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "RemoveVectorVariable");

	Params::VisualControlComponent_RemoveVectorVariable Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlComponent.SetFloatVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlComponent::SetFloatVariable(class FName InName, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "SetFloatVariable");

	Params::VisualControlComponent_SetFloatVariable Parms{};

	Parms.InName = InName;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlComponent.SetTransformVariable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InValue                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlComponent::SetTransformVariable(class FName InName, const struct FTransform& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "SetTransformVariable");

	Params::VisualControlComponent_SetTransformVariable Parms{};

	Parms.InName = InName;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlComponent.SetVectorVariable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlComponent::SetVectorVariable(class FName InName, const struct FVector& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "SetVectorVariable");

	Params::VisualControlComponent_SetVectorVariable Parms{};

	Parms.InName = InName;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlComponent.UnregisterReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlComponent::UnregisterReference(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualControlComponent", "UnregisterReference");

	Params::VisualControlComponent_UnregisterReference Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.AppearEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::AppearEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "AppearEquipment");

	Params::EquipmentVisualControlComponent_AppearEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.BeginWeaponMeshChange
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InTargetMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InChangeMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::BeginWeaponMeshChange(class USkeletalMeshComponent* InTargetMesh, class USkeletalMeshComponent* InChangeMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "BeginWeaponMeshChange");

	Params::EquipmentVisualControlComponent_BeginWeaponMeshChange Parms{};

	Parms.InTargetMesh = InTargetMesh;
	Parms.InChangeMesh = InChangeMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.DisappearEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::DisappearEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "DisappearEquipment");

	Params::EquipmentVisualControlComponent_DisappearEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.EnchantEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_EnchantEffect_Type                    InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InWeaponMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::EnchantEffect(E_EnchantEffect_Type InType, bool bInEnable, class USkeletalMeshComponent* InWeaponMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "EnchantEffect");

	Params::EquipmentVisualControlComponent_EnchantEffect Parms{};

	Parms.InType = InType;
	Parms.bInEnable = bInEnable;
	Parms.InWeaponMesh = InWeaponMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.EnchantEffectAllMeshByGCTag
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InGCTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::EnchantEffectAllMeshByGCTag(const struct FGameplayTag& InGCTag, bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "EnchantEffectAllMeshByGCTag");

	Params::EquipmentVisualControlComponent_EnchantEffectAllMeshByGCTag Parms{};

	Parms.InGCTag = std::move(InGCTag);
	Parms.bInEnable = bInEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.EnchantEffectByGCTag
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InGCTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InWeaponMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::EnchantEffectByGCTag(const struct FGameplayTag& InGCTag, bool bInEnable, class USkeletalMeshComponent* InWeaponMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "EnchantEffectByGCTag");

	Params::EquipmentVisualControlComponent_EnchantEffectByGCTag Parms{};

	Parms.InGCTag = std::move(InGCTag);
	Parms.bInEnable = bInEnable;
	Parms.InWeaponMesh = InWeaponMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.EndWeaponMeshChange
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InTargetMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InChangeMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::EndWeaponMeshChange(class USkeletalMeshComponent* InTargetMesh, class USkeletalMeshComponent* InChangeMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "EndWeaponMeshChange");

	Params::EquipmentVisualControlComponent_EndWeaponMeshChange Parms{};

	Parms.InTargetMesh = InTargetMesh;
	Parms.InChangeMesh = InChangeMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.GetCharacterActor
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UEquipmentVisualControlComponent::GetCharacterActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "GetCharacterActor");

	Params::EquipmentVisualControlComponent_GetCharacterActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.GetCharacterMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UEquipmentVisualControlComponent::GetCharacterMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "GetCharacterMesh");

	Params::EquipmentVisualControlComponent_GetCharacterMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.GetEquipmentActor
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEquipmentVisualControlComponent::GetEquipmentActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "GetEquipmentActor");

	Params::EquipmentVisualControlComponent_GetEquipmentActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.GetEquipmentMeshAll
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class USkeletalMeshComponent*>*  OutMeshArray                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::GetEquipmentMeshAll(TArray<class USkeletalMeshComponent*>* OutMeshArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "GetEquipmentMeshAll");

	Params::EquipmentVisualControlComponent_GetEquipmentMeshAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshArray != nullptr)
		*OutMeshArray = std::move(Parms.OutMeshArray);
}


// Function Extensions.EquipmentVisualControlComponent.GetInCinematic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::GetInCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "GetInCinematic");

	Params::EquipmentVisualControlComponent_GetInCinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.InitializeAppearEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bAppear                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::InitializeAppearEquipment(bool bAppear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "InitializeAppearEquipment");

	Params::EquipmentVisualControlComponent_InitializeAppearEquipment Parms{};

	Parms.bAppear = bAppear;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.OnActivateVisualControl
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::OnActivateVisualControl(bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnActivateVisualControl");

	Params::EquipmentVisualControlComponent_OnActivateVisualControl Parms{};

	Parms.bReset = bReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.OnDeactivateVisualControl
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UEquipmentVisualControlComponent::OnDeactivateVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnDeactivateVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EquipmentVisualControlComponent.OnDestroyVisualControl
// (Event, Protected, BlueprintEvent)

void UEquipmentVisualControlComponent::OnDestroyVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnDestroyVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EquipmentVisualControlComponent.OnFinishCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnFinishCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnFinishCinematicEvent");

	Params::EquipmentVisualControlComponent_OnFinishCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnGadgetEffectBegin
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnGadgetEffectBegin(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnGadgetEffectBegin");

	Params::EquipmentVisualControlComponent_OnGadgetEffectBegin Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnGadgetEffectEnd
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnGadgetEffectEnd(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnGadgetEffectEnd");

	Params::EquipmentVisualControlComponent_OnGadgetEffectEnd Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnGadgetEffectTick
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnGadgetEffectTick(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnGadgetEffectTick");

	Params::EquipmentVisualControlComponent_OnGadgetEffectTick Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnInitializeVisualControl
// (Event, Protected, BlueprintEvent)

void UEquipmentVisualControlComponent::OnInitializeVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnInitializeVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EquipmentVisualControlComponent.OnSimpleAnimNotify_Begin
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnSimpleAnimNotify_Begin(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnSimpleAnimNotify_Begin");

	Params::EquipmentVisualControlComponent_OnSimpleAnimNotify_Begin Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnSimpleAnimNotify_End
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnSimpleAnimNotify_End(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnSimpleAnimNotify_End");

	Params::EquipmentVisualControlComponent_OnSimpleAnimNotify_End Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnSimpleAnimNotify_Tick
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnSimpleAnimNotify_Tick(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnSimpleAnimNotify_Tick");

	Params::EquipmentVisualControlComponent_OnSimpleAnimNotify_Tick Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.OnStartCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentVisualControlComponent::OnStartCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "OnStartCinematicEvent");

	Params::EquipmentVisualControlComponent_OnStartCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EquipmentVisualControlComponent.ResetAppearEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::ResetAppearEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "ResetAppearEquipment");

	Params::EquipmentVisualControlComponent_ResetAppearEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.ResetDisappearEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::ResetDisappearEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "ResetDisappearEquipment");

	Params::EquipmentVisualControlComponent_ResetDisappearEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.SetPhotoModeHiddenInGame
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InWeaponMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::SetPhotoModeHiddenInGame(class USkeletalMeshComponent* InWeaponMesh, bool bInHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "SetPhotoModeHiddenInGame");

	Params::EquipmentVisualControlComponent_SetPhotoModeHiddenInGame Parms{};

	Parms.InWeaponMesh = InWeaponMesh;
	Parms.bInHidden = bInHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.SummonEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::SummonEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "SummonEquipment");

	Params::EquipmentVisualControlComponent_SummonEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.SummonEquipment_OnFinish
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::SummonEquipment_OnFinish(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "SummonEquipment_OnFinish");

	Params::EquipmentVisualControlComponent_SummonEquipment_OnFinish Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipmentVisualControlComponent.UnsummonEquipment
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::UnsummonEquipment(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "UnsummonEquipment");

	Params::EquipmentVisualControlComponent_UnsummonEquipment Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlComponent.UnsummonEquipment_OnFinish
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentVisualControlComponent::UnsummonEquipment_OnFinish(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentVisualControlComponent", "UnsummonEquipment_OnFinish");

	Params::EquipmentVisualControlComponent_UnsummonEquipment_OnFinish Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppRecastNavMesh.Editor_DeleteGeneratedNavLinks
// (Final, Native, Public)

void AAppRecastNavMesh::Editor_DeleteGeneratedNavLinks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppRecastNavMesh", "Editor_DeleteGeneratedNavLinks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppRecastNavMesh.Editor_RegenerateAllNavLinks
// (Final, Native, Public)

void AAppRecastNavMesh::Editor_RegenerateAllNavLinks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppRecastNavMesh", "Editor_RegenerateAllNavLinks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppRecastNavMesh.RegenerateAllNavLinksOnWorldPartition
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FBox&                      CellBounds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       CellName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppRecastNavMesh::RegenerateAllNavLinksOnWorldPartition(const struct FBox& CellBounds, const class FName CellName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppRecastNavMesh", "RegenerateAllNavLinksOnWorldPartition");

	Params::AppRecastNavMesh_RegenerateAllNavLinksOnWorldPartition Parms{};

	Parms.CellBounds = std::move(CellBounds);
	Parms.CellName = CellName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanAnimInstance.OnGameplayTagNewOrRemoved_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanAnimInstance::OnGameplayTagNewOrRemoved_BP(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "OnGameplayTagNewOrRemoved_BP");

	Params::ActionHumanAnimInstance_OnGameplayTagNewOrRemoved_BP Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ActionHumanAnimInstance.GetGameFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UActionHumanAnimInstance::GetGameFlags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetGameFlags");

	Params::ActionHumanAnimInstance_GetGameFlags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.GetHeadScale
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanAnimInstance::GetHeadScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetHeadScale");

	Params::ActionHumanAnimInstance_GetHeadScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.GetOwnerOwnedGameplayTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UActionHumanAnimInstance::GetOwnerOwnedGameplayTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetOwnerOwnedGameplayTags");

	Params::ActionHumanAnimInstance_GetOwnerOwnedGameplayTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.GetPawnOwnerAsActionHumanCharacter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* UActionHumanAnimInstance::GetPawnOwnerAsActionHumanCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetPawnOwnerAsActionHumanCharacter");

	Params::ActionHumanAnimInstance_GetPawnOwnerAsActionHumanCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.GetPlayerAnimParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerAnimParameter       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPlayerAnimParameter UActionHumanAnimInstance::GetPlayerAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetPlayerAnimParameter");

	Params::ActionHumanAnimInstance_GetPlayerAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.GetReplicatedLinkedAnimClasses
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class UAnimInstance>>*OutAnimClasses                                         (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UActionHumanAnimInstance::GetReplicatedLinkedAnimClasses(TArray<TSubclassOf<class UAnimInstance>>* OutAnimClasses) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetReplicatedLinkedAnimClasses");

	Params::ActionHumanAnimInstance_GetReplicatedLinkedAnimClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimClasses != nullptr)
		*OutAnimClasses = std::move(Parms.OutAnimClasses);
}


// Function Extensions.ActionHumanAnimInstance.GetSelectedWeaponCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponCategory                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponCategory UActionHumanAnimInstance::GetSelectedWeaponCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "GetSelectedWeaponCategory");

	Params::ActionHumanAnimInstance_GetSelectedWeaponCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.IsFemale
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanAnimInstance::IsFemale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "IsFemale");

	Params::ActionHumanAnimInstance_IsFemale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanAnimInstance.IsPlayingSlotAnimationAny
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       InSlotNodeName                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanAnimInstance::IsPlayingSlotAnimationAny(const class FName InSlotNodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanAnimInstance", "IsPlayingSlotAnimationAny");

	Params::ActionHumanAnimInstance_IsPlayingSlotAnimationAny Parms{};

	Parms.InSlotNodeName = InSlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BattleStateComponent.HideWeapon_BP
// (Final, Native, Public, BlueprintCallable)

void UBattleStateComponent::HideWeapon_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateComponent", "HideWeapon_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BattleStateComponent.UnhideWeapon_BP
// (Final, Native, Public, BlueprintCallable)

void UBattleStateComponent::UnhideWeapon_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateComponent", "UnhideWeapon_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BattleStateComponent.UpdateABPLinks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bInToBattle                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleStateComponent::UpdateABPLinks(const bool bInToBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateComponent", "UpdateABPLinks");

	Params::BattleStateComponent_UpdateABPLinks Parms{};

	Parms.bInToBattle = bInToBattle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BattleStateComponent.GetSettings_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UBattleStateSettings*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UBattleStateSettings* UBattleStateComponent::GetSettings_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateComponent", "GetSettings_BP");

	Params::BattleStateComponent_GetSettings_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BattleStateComponent.ShouldSkipMontage_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UBattleStateComponent::ShouldSkipMontage_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateComponent", "ShouldSkipMontage_BP");

	Params::BattleStateComponent_ShouldSkipMontage_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemManager.GetCharacterCustomizeSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterCustomizeSystem*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterCustomizeSystem* UGameSystemManager::GetCharacterCustomizeSystem(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSystemManager", "GetCharacterCustomizeSystem");

	Params::GameSystemManager_GetCharacterCustomizeSystem Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemManager.GetMapSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMapSystem*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMapSystem* UGameSystemManager::GetMapSystem(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSystemManager", "GetMapSystem");

	Params::GameSystemManager_GetMapSystem Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemManager.LoadCharacterCustomizeSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSystemManager::LoadCharacterCustomizeSystem(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSystemManager", "LoadCharacterCustomizeSystem");

	Params::GameSystemManager_LoadCharacterCustomizeSystem Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameSystemManager.LoadMapSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSystemManager::LoadMapSystem(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSystemManager", "LoadMapSystem");

	Params::GameSystemManager_LoadMapSystem Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SimpleAnimNotifyState.K2_GetParameterMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName USimpleAnimNotifyState::K2_GetParameterMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleAnimNotifyState", "K2_GetParameterMessage");

	Params::SimpleAnimNotifyState_K2_GetParameterMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.HealthGaugeInterface.SetHealth
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InHealth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InRecoverableHealth                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InFactor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IHealthGaugeInterface::SetHealth(const float InHealth, const float InMaxHealth, const float InRecoverableHealth, const EResourceChangeFactor InFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HealthGaugeInterface", "SetHealth");

	Params::HealthGaugeInterface_SetHealth Parms{};

	Parms.InHealth = InHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InRecoverableHealth = InRecoverableHealth;
	Parms.InFactor = InFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetWheelCorneringStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetWheelCorneringStiffness(int32 WheelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetWheelCorneringStiffness");

	Params::AppWheelVehicleMovementComponent_GetWheelCorneringStiffness Parms{};

	Parms.WheelIndex = WheelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetWheelRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetWheelRadius(int32 WheelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetWheelRadius");

	Params::AppWheelVehicleMovementComponent_GetWheelRadius Parms{};

	Parms.WheelIndex = WheelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.OnChangeGlideInputEvent
// (Final, Native, Private)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppWheelVehicleMovementComponent::OnChangeGlideInputEvent(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "OnChangeGlideInputEvent");

	Params::AppWheelVehicleMovementComponent_OnChangeGlideInputEvent Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheelVehicleMovementComponent.OnInAir
// (Event, Protected, BlueprintEvent)

void UAppWheelVehicleMovementComponent::OnInAir()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "OnInAir");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.AppWheelVehicleMovementComponent.OnLand
// (Event, Protected, BlueprintEvent)

void UAppWheelVehicleMovementComponent::OnLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "OnLand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.AppWheelVehicleMovementComponent.SetWheelCorneringStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppWheelVehicleMovementComponent::SetWheelCorneringStiffness(int32 WheelIndex, float Stiffness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "SetWheelCorneringStiffness");

	Params::AppWheelVehicleMovementComponent_SetWheelCorneringStiffness Parms{};

	Parms.WheelIndex = WheelIndex;
	Parms.Stiffness = Stiffness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetActualSteeringInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetActualSteeringInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetActualSteeringInput");

	Params::AppWheelVehicleMovementComponent_GetActualSteeringInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetAxelTurnAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetAxelTurnAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetAxelTurnAlpha");

	Params::AppWheelVehicleMovementComponent_GetAxelTurnAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetAxelTurnInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetAxelTurnInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetAxelTurnInput");

	Params::AppWheelVehicleMovementComponent_GetAxelTurnInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetCurrentSteeringAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetCurrentSteeringAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetCurrentSteeringAngle");

	Params::AppWheelVehicleMovementComponent_GetCurrentSteeringAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetForwardAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetForwardAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetForwardAcceleration");

	Params::AppWheelVehicleMovementComponent_GetForwardAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetPitchInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetPitchInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetPitchInput");

	Params::AppWheelVehicleMovementComponent_GetPitchInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetSlideBrakeInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetSlideBrakeInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetSlideBrakeInput");

	Params::AppWheelVehicleMovementComponent_GetSlideBrakeInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetStopThresold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float UAppWheelVehicleMovementComponent::GetStopThresold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetStopThresold");

	Params::AppWheelVehicleMovementComponent_GetStopThresold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetVehicleWorldTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAppWheelVehicleMovementComponent::GetVehicleWorldTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetVehicleWorldTransform");

	Params::AppWheelVehicleMovementComponent_GetVehicleWorldTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.GetWheelMaxSteerAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppWheelVehicleMovementComponent::GetWheelMaxSteerAngle(int32 WheelIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "GetWheelMaxSteerAngle");

	Params::AppWheelVehicleMovementComponent_GetWheelMaxSteerAngle Parms{};

	Parms.WheelIndex = WheelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheelVehicleMovementComponent.IsInAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UAppWheelVehicleMovementComponent::IsInAir() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheelVehicleMovementComponent", "IsInAir");

	Params::AppWheelVehicleMovementComponent_IsInAir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentLightUpdater.GetWeahterParameterDataAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InWeatherTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWeatherParameters*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeatherParameters* UEnvironmentLightUpdater::GetWeahterParameterDataAsset(const struct FGameplayTag& InWeatherTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentLightUpdater", "GetWeahterParameterDataAsset");

	Params::EnvironmentLightUpdater_GetWeahterParameterDataAsset Parms{};

	Parms.InWeatherTag = std::move(InWeatherTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArticleFunction.AssetLoad
// (Final, Native, Public, BlueprintCallable)

void UArticleFunction::AssetLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleFunction", "AssetLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArticleFunction.ExecuteFunction
// (Native, Public, BlueprintCallable)
// Parameters:
// class UGA_ArticleFunction*              InOwnerAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArticleFunction::ExecuteFunction(class UGA_ArticleFunction* InOwnerAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleFunction", "ExecuteFunction");

	Params::ArticleFunction_ExecuteFunction Parms{};

	Parms.InOwnerAbility = InOwnerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.AddRemovableSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    InSkeletalMesh                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InSocketName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::AddRemovableSkeletalMeshComponent(class USkeletalMesh* InSkeletalMesh, const class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "AddRemovableSkeletalMeshComponent");

	Params::ActionHumanCharacter_AddRemovableSkeletalMeshComponent Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.CancelForceAllowJump
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::CancelForceAllowJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "CancelForceAllowJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ClientWarp
// (Net, NetReliable, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              bInStopMovement                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ClientWarp(const struct FVector& InLocation, const struct FRotator& InRotation, const bool bInStopMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ClientWarp");

	Params::ActionHumanCharacter_ClientWarp Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.bInStopMovement = bInStopMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.DeleteIvyMarker
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::DeleteIvyMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "DeleteIvyMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.EndTurn
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AActionHumanCharacter::EndTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "EndTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.FellOff
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::FellOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "FellOff");

	Params::ActionHumanCharacter_FellOff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.ForceAllowJumpOnce
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::ForceAllowJumpOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ForceAllowJumpOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.GetCommonActionMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* AActionHumanCharacter::GetCommonActionMontage(class FName InActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetCommonActionMontage");

	Params::ActionHumanCharacter_GetCommonActionMontage Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetGadgetActorByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EStandAloneGadgetType                   InGadgetType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGadgetStateType                        InStateType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGadgetBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGadgetBase* AActionHumanCharacter::GetGadgetActorByType(EStandAloneGadgetType InGadgetType, EGadgetStateType InStateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetGadgetActorByType");

	Params::ActionHumanCharacter_GetGadgetActorByType Parms{};

	Parms.InGadgetType = InGadgetType;
	Parms.InStateType = InStateType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetReadyGadgetActorByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EStandAloneGadgetType                   InGadgetType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGadgetBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGadgetBase* AActionHumanCharacter::GetReadyGadgetActorByType(EStandAloneGadgetType InGadgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetReadyGadgetActorByType");

	Params::ActionHumanCharacter_GetReadyGadgetActorByType Parms{};

	Parms.InGadgetType = InGadgetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsBindOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsBindOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsBindOverride");

	Params::ActionHumanCharacter_IsBindOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.LandWithAbility
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::LandWithAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "LandWithAbility");

	Params::ActionHumanCharacter_LandWithAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.LinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPriority                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass, const int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "LinkAnimClassLayers");

	Params::ActionHumanCharacter_LinkAnimClassLayers Parms{};

	Parms.InClass = InClass;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.MakeLocoStartFromCycle
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::MakeLocoStartFromCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "MakeLocoStartFromCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.MakeLocoStartFromStop
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::MakeLocoStartFromStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "MakeLocoStartFromStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NetMulticastMakeLocoStartFromCycleIfSimulatedProxy
// (Final, Net, Native, Event, NetMulticast, Private)

void AActionHumanCharacter::NetMulticastMakeLocoStartFromCycleIfSimulatedProxy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NetMulticastMakeLocoStartFromCycleIfSimulatedProxy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NetMulticastMakeLocoStartFromStopIfSimulatedProxy
// (Final, Net, Native, Event, NetMulticast, Private)

void AActionHumanCharacter::NetMulticastMakeLocoStartFromStopIfSimulatedProxy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NetMulticastMakeLocoStartFromStopIfSimulatedProxy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NetMulticastReplicatedStopAnimMontageIfSimulatedProxy
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::NetMulticastReplicatedStopAnimMontageIfSimulatedProxy(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NetMulticastReplicatedStopAnimMontageIfSimulatedProxy");

	Params::ActionHumanCharacter_NetMulticastReplicatedStopAnimMontageIfSimulatedProxy Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NetMulticastReplicatePhotoModeCharacterParameter
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const EPhotoModeCharacterParameterCharacterInCharacterType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPhotoModeCharacterParameter      InParameterType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::NetMulticastReplicatePhotoModeCharacterParameter(const EPhotoModeCharacterParameterCharacter InCharacterType, const EPhotoModeCharacterParameter InParameterType, const int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NetMulticastReplicatePhotoModeCharacterParameter");

	Params::ActionHumanCharacter_NetMulticastReplicatePhotoModeCharacterParameter Parms{};

	Parms.InCharacterType = InCharacterType;
	Parms.InParameterType = InParameterType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NetMulticastResetPhotoModeCharacterParameter
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AActionHumanCharacter::NetMulticastResetPhotoModeCharacterParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NetMulticastResetPhotoModeCharacterParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NotifyLocoEnteredCycle
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::NotifyLocoEnteredCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NotifyLocoEnteredCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.NotifyLocoEnteredStop
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::NotifyLocoEnteredStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "NotifyLocoEnteredStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_AdditiveMontageInfo
// (Final, Native, Protected)

void AActionHumanCharacter::OnRep_AdditiveMontageInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_AdditiveMontageInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_bReplicatedIsVisible
// (Final, Native, Private)

void AActionHumanCharacter::OnRep_bReplicatedIsVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_bReplicatedIsVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_PrepareAimOffset
// (Final, Native, Protected)

void AActionHumanCharacter::OnRep_PrepareAimOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_PrepareAimOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_ReplicatedAcceleration
// (Final, Native, Private)

void AActionHumanCharacter::OnRep_ReplicatedAcceleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_ReplicatedAcceleration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_ReplicatedLinkedAnimClasses
// (Final, Native, Private)

void AActionHumanCharacter::OnRep_ReplicatedLinkedAnimClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_ReplicatedLinkedAnimClasses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_ReplicatedLooseGameplayTagCounts
// (Final, Native, Private)

void AActionHumanCharacter::OnRep_ReplicatedLooseGameplayTagCounts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_ReplicatedLooseGameplayTagCounts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_ReplicatedRemovableSkeletalMeshInfos
// (Final, Native, Private)

void AActionHumanCharacter::OnRep_ReplicatedRemovableSkeletalMeshInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_ReplicatedRemovableSkeletalMeshInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_RepSpawnedGadget
// (Final, Native, Protected)

void AActionHumanCharacter::OnRep_RepSpawnedGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_RepSpawnedGadget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.OnRep_SpawnedIvyMarker
// (Final, Native, Protected)

void AActionHumanCharacter::OnRep_SpawnedIvyMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "OnRep_SpawnedIvyMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.QuickRotate
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InToDirection                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bServerRPC                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bServerOnly                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::QuickRotate(const struct FVector& InToDirection, const bool bServerRPC, const bool bServerOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "QuickRotate");

	Params::ActionHumanCharacter_QuickRotate Parms{};

	Parms.InToDirection = std::move(InToDirection);
	Parms.bServerRPC = bServerRPC;
	Parms.bServerOnly = bServerOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.RemoveRemovableSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    InSkeletalMesh                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::RemoveRemovableSkeletalMeshComponent(class USkeletalMesh* InSkeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "RemoveRemovableSkeletalMeshComponent");

	Params::ActionHumanCharacter_RemoveRemovableSkeletalMeshComponent Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ReplicatedStopAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ReplicatedStopAnimMontage(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ReplicatedStopAnimMontage");

	Params::ActionHumanCharacter_ReplicatedStopAnimMontage Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.RequestSpawnIvyMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AIvySuckingBloodMarker>InActor                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSpawnNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::RequestSpawnIvyMarker(TSubclassOf<class AIvySuckingBloodMarker> InActor, int32 InSpawnNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "RequestSpawnIvyMarker");

	Params::ActionHumanCharacter_RequestSpawnIvyMarker Parms{};

	Parms.InActor = InActor;
	Parms.InSpawnNum = InSpawnNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.RestartPlayer
// (Native, Public, BlueprintCallable)

void AActionHumanCharacter::RestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "RestartPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ResurrectNextTick
// (Final, Native, Public, BlueprintCallable)

void AActionHumanCharacter::ResurrectNextTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ResurrectNextTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerAddAdditiveMontage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerAddAdditiveMontage(class UAnimMontage* InAnimMontage, float InStartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerAddAdditiveMontage");

	Params::ActionHumanCharacter_ServerAddAdditiveMontage Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InStartTime = InStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerAdditiveMontageJumpSection
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerAdditiveMontageJumpSection(class UAnimMontage* InAnimMontage, const class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerAdditiveMontageJumpSection");

	Params::ActionHumanCharacter_ServerAdditiveMontageJumpSection Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerAddRemovableSkeletalMeshComponent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class USkeletalMesh*                    InSkeletalMesh                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InSocketName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerAddRemovableSkeletalMeshComponent(class USkeletalMesh* InSkeletalMesh, const class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerAddRemovableSkeletalMeshComponent");

	Params::ActionHumanCharacter_ServerAddRemovableSkeletalMeshComponent Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerLinkAnimClassLayers
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPriority                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerLinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass, const int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerLinkAnimClassLayers");

	Params::ActionHumanCharacter_ServerLinkAnimClassLayers Parms{};

	Parms.InClass = InClass;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerNotifyIvyMarkerInput
// (Net, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// const struct FVector2D&                 InInput                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerNotifyIvyMarkerInput(const struct FVector2D& InInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerNotifyIvyMarkerInput");

	Params::ActionHumanCharacter_ServerNotifyIvyMarkerInput Parms{};

	Parms.InInput = std::move(InInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerOnLockOnEnded
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AActionHumanCharacter::ServerOnLockOnEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerOnLockOnEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerOnLockOnStarted
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FPlayerLockOnInfo&         InLockOnInfo                                           (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerOnLockOnStarted(const struct FPlayerLockOnInfo& InLockOnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerOnLockOnStarted");

	Params::ActionHumanCharacter_ServerOnLockOnStarted Parms{};

	Parms.InLockOnInfo = std::move(InLockOnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerQuickRotate
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const uint8                             InToYawDirection                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerQuickRotate(const uint8 InToYawDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerQuickRotate");

	Params::ActionHumanCharacter_ServerQuickRotate Parms{};

	Parms.InToYawDirection = InToYawDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerRemoveAdditiveMontage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerRemoveAdditiveMontage(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerRemoveAdditiveMontage");

	Params::ActionHumanCharacter_ServerRemoveAdditiveMontage Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerRemoveRemovableSkeletalMeshComponent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class USkeletalMesh*                    InSkeletalMesh                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerRemoveRemovableSkeletalMeshComponent(class USkeletalMesh* InSkeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerRemoveRemovableSkeletalMeshComponent");

	Params::ActionHumanCharacter_ServerRemoveRemovableSkeletalMeshComponent Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerReplicatedStopAnimMontage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UAnimMontage*                     InAnimMontage                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerReplicatedStopAnimMontage(class UAnimMontage* InAnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerReplicatedStopAnimMontage");

	Params::ActionHumanCharacter_ServerReplicatedStopAnimMontage Parms{};

	Parms.InAnimMontage = InAnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerReplicatePhotoModeCharacterParameter
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const EPhotoModeCharacterParameterCharacterInCharacterType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPhotoModeCharacterParameter      InParameterType                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerReplicatePhotoModeCharacterParameter(const EPhotoModeCharacterParameterCharacter InCharacterType, const EPhotoModeCharacterParameter InParameterType, const int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerReplicatePhotoModeCharacterParameter");

	Params::ActionHumanCharacter_ServerReplicatePhotoModeCharacterParameter Parms{};

	Parms.InCharacterType = InCharacterType;
	Parms.InParameterType = InParameterType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerResetPhotoModeCharacterParameter
// (Net, NetReliable, Native, Event, Public, NetServer)

void AActionHumanCharacter::ServerResetPhotoModeCharacterParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerResetPhotoModeCharacterParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerSetLooseGameplayTagCount
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// const struct FGameplayTag&              InGameplayTag                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNewCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerSetLooseGameplayTagCount(const struct FGameplayTag& InGameplayTag, const int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerSetLooseGameplayTagCount");

	Params::ActionHumanCharacter_ServerSetLooseGameplayTagCount Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerSetVisibility
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const bool                              bInIsVisible                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerSetVisibility(const bool bInIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerSetVisibility");

	Params::ActionHumanCharacter_ServerSetVisibility Parms{};

	Parms.bInIsVisible = bInIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.ServerUnlinkAnimClassLayers
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPriority                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::ServerUnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass, const int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ServerUnlinkAnimClassLayers");

	Params::ActionHumanCharacter_ServerUnlinkAnimClassLayers Parms{};

	Parms.InClass = InClass;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.SetLooseGameplayTagCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InGameplayTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNewCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInReplicate                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::SetLooseGameplayTagCount(const struct FGameplayTag& InGameplayTag, const int32 InNewCount, const bool bInReplicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "SetLooseGameplayTagCount");

	Params::ActionHumanCharacter_SetLooseGameplayTagCount Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InNewCount = InNewCount;
	Parms.bInReplicate = bInReplicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.SetNetMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EActionHumanNetMovementMode       InNewMode                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::SetNetMovementMode(const EActionHumanNetMovementMode InNewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "SetNetMovementMode");

	Params::ActionHumanCharacter_SetNetMovementMode Parms{};

	Parms.InNewMode = InNewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bInIsVisible                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::SetVisibility(const bool bInIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "SetVisibility");

	Params::ActionHumanCharacter_SetVisibility Parms{};

	Parms.bInIsVisible = bInIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.Sprint
// (Native, Public, BlueprintCallable)

void AActionHumanCharacter::Sprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "Sprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.StartTurn
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   InTurnAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnPlayRate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::StartTurn(float InTurnAngle, float InTurnPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "StartTurn");

	Params::ActionHumanCharacter_StartTurn Parms{};

	Parms.InTurnAngle = InTurnAngle;
	Parms.InTurnPlayRate = InTurnPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.UnlinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPriority                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanCharacter::UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass, const int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "UnlinkAnimClassLayers");

	Params::ActionHumanCharacter_UnlinkAnimClassLayers Parms{};

	Parms.InClass = InClass;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.UnSprint
// (Native, Public, BlueprintCallable)

void AActionHumanCharacter::UnSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "UnSprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanCharacter.GetAppAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UActionHumanAbilitySystem*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionHumanAbilitySystem* AActionHumanCharacter::GetAppAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetAppAbilitySystemComponent");

	Params::ActionHumanCharacter_GetAppAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetAppMovementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UActionHumanMovementComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionHumanMovementComponent* AActionHumanCharacter::GetAppMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetAppMovementComponent");

	Params::ActionHumanCharacter_GetAppMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetFallDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             InFallDistance                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionHumanCharacter::GetFallDamage(const float InFallDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetFallDamage");

	Params::ActionHumanCharacter_GetFallDamage Parms{};

	Parms.InFallDistance = InFallDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetFieldNPCAnimBPBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionHumanCharacter::GetFieldNPCAnimBPBlendTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetFieldNPCAnimBPBlendTime");

	Params::ActionHumanCharacter_GetFieldNPCAnimBPBlendTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetIvyMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIvyMarkerStateType                     InMarkerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIvySuckingBloodMarker*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIvySuckingBloodMarker* AActionHumanCharacter::GetIvyMarker(EIvyMarkerStateType InMarkerType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetIvyMarker");

	Params::ActionHumanCharacter_GetIvyMarker Parms{};

	Parms.InMarkerType = InMarkerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetLadderClimberComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULadderClimberComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULadderClimberComponent* AActionHumanCharacter::GetLadderClimberComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetLadderClimberComponent");

	Params::ActionHumanCharacter_GetLadderClimberComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetLatestJumpApexLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActionHumanCharacter::GetLatestJumpApexLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetLatestJumpApexLocation");

	Params::ActionHumanCharacter_GetLatestJumpApexLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetLocoStopFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionHumanCharacter::GetLocoStopFraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetLocoStopFraction");

	Params::ActionHumanCharacter_GetLocoStopFraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetMotionWarpingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UActionHumanMotionWarping*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionHumanMotionWarping* AActionHumanCharacter::GetMotionWarpingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetMotionWarpingComponent");

	Params::ActionHumanCharacter_GetMotionWarpingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetMountControlComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMountControlComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMountControlComponent* AActionHumanCharacter::GetMountControlComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetMountControlComponent");

	Params::ActionHumanCharacter_GetMountControlComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetPrepareAimOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D AActionHumanCharacter::GetPrepareAimOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetPrepareAimOffset");

	Params::ActionHumanCharacter_GetPrepareAimOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.GetUseFieldNPCAnimBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::GetUseFieldNPCAnimBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "GetUseFieldNPCAnimBP");

	Params::ActionHumanCharacter_GetUseFieldNPCAnimBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsDead");

	Params::ActionHumanCharacter_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsLockingOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsLockingOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsLockingOn");

	Params::ActionHumanCharacter_IsLockingOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsLocoStartEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsLocoStartEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsLocoStartEnabled");

	Params::ActionHumanCharacter_IsLocoStartEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsLocoStopEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsLocoStopEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsLocoStopEnabled");

	Params::ActionHumanCharacter_IsLocoStopEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsNoHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsNoHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsNoHealth");

	Params::ActionHumanCharacter_IsNoHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsSprinting");

	Params::ActionHumanCharacter_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsSteepSlope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsSteepSlope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsSteepSlope");

	Params::ActionHumanCharacter_IsSteepSlope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsStrafing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsStrafing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsStrafing");

	Params::ActionHumanCharacter_IsStrafing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "IsVisible");

	Params::ActionHumanCharacter_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.ShouldLocoStartFromCycle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::ShouldLocoStartFromCycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ShouldLocoStartFromCycle");

	Params::ActionHumanCharacter_ShouldLocoStartFromCycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanCharacter.ShouldLocoStartFromStop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanCharacter::ShouldLocoStartFromStop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanCharacter", "ShouldLocoStartFromStop");

	Params::ActionHumanCharacter_ShouldLocoStartFromStop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusAccumulatorComponent.OnRep_ReplicatedAffectedUIInfo
// (Native, Protected)

void UPlayerStatusAccumulatorComponent::OnRep_ReplicatedAffectedUIInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusAccumulatorComponent", "OnRep_ReplicatedAffectedUIInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.AdditiveMontageJumpSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::AdditiveMontageJumpSection(class UAnimMontage* InMontage, const class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "AdditiveMontageJumpSection");

	Params::ActionHumanGameplayAbility_AdditiveMontageJumpSection Parms{};

	Parms.InMontage = InMontage;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.BlockAbilitiesWithATag
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::BlockAbilitiesWithATag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "BlockAbilitiesWithATag");

	Params::ActionHumanGameplayAbility_BlockAbilitiesWithATag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.CheckCloseEnough
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::CheckCloseEnough()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "CheckCloseEnough");

	Params::ActionHumanGameplayAbility_CheckCloseEnough Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.CheckCurrentMontageSectionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::CheckCurrentMontageSectionName(class FName InSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "CheckCurrentMontageSectionName");

	Params::ActionHumanGameplayAbility_CheckCurrentMontageSectionName Parms{};

	Parms.InSectionName = InSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.CheckWallStackFailSafe
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const float                             InSafetyLimit                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InToWallVelocityThreshold                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InFirstSectionName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::CheckWallStackFailSafe(const float InSafetyLimit, const float InToWallVelocityThreshold, class FName InFirstSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "CheckWallStackFailSafe");

	Params::ActionHumanGameplayAbility_CheckWallStackFailSafe Parms{};

	Parms.InSafetyLimit = InSafetyLimit;
	Parms.InToWallVelocityThreshold = InToWallVelocityThreshold;
	Parms.InFirstSectionName = InFirstSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.CheckZStackFailSafe
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const float                             InSafetyLimit                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDownVelocityThreshold                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::CheckZStackFailSafe(const float InSafetyLimit, const float InDownVelocityThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "CheckZStackFailSafe");

	Params::ActionHumanGameplayAbility_CheckZStackFailSafe Parms{};

	Parms.InSafetyLimit = InSafetyLimit;
	Parms.InDownVelocityThreshold = InDownVelocityThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.EmitNoiseByID
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FName                       InID                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::EmitNoiseByID(const class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "EmitNoiseByID");

	Params::ActionHumanGameplayAbility_EmitNoiseByID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.FailSafeEndAbility
// (Final, Native, Protected, BlueprintCallable)

void UActionHumanGameplayAbility::FailSafeEndAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "FailSafeEndAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.GetMontageSectionLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanGameplayAbility::GetMontageSectionLength(class UAnimMontage* InMontage, class FName InSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "GetMontageSectionLength");

	Params::ActionHumanGameplayAbility_GetMontageSectionLength Parms{};

	Parms.InMontage = InMontage;
	Parms.InSectionName = InSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.GetUseAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UActionHumanGameplayAbility::GetUseAnimation(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "GetUseAnimation");

	Params::ActionHumanGameplayAbility_GetUseAnimation Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.GetUseMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UActionHumanGameplayAbility::GetUseMontage(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "GetUseMontage");

	Params::ActionHumanGameplayAbility_GetUseMontage Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.IsDush2Enemy
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::IsDush2Enemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "IsDush2Enemy");

	Params::ActionHumanGameplayAbility_IsDush2Enemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.IsLandingSoon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InCheckTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       InCollisionChannel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::IsLandingSoon(float InCheckTime, ECollisionChannel InCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "IsLandingSoon");

	Params::ActionHumanGameplayAbility_IsLandingSoon Parms{};

	Parms.InCheckTime = InCheckTime;
	Parms.InCollisionChannel = InCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.MontageJumpToSectionAndStartTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::MontageJumpToSectionAndStartTime(class FName InSectionName, float InStartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "MontageJumpToSectionAndStartTime");

	Params::ActionHumanGameplayAbility_MontageJumpToSectionAndStartTime Parms{};

	Parms.InSectionName = InSectionName;
	Parms.InStartTime = InStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.MontageJumpToSectionIfAnimatingAbility
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const class FName                       InSectionName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanGameplayAbility::MontageJumpToSectionIfAnimatingAbility(const class FName InSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "MontageJumpToSectionIfAnimatingAbility");

	Params::ActionHumanGameplayAbility_MontageJumpToSectionIfAnimatingAbility Parms{};

	Parms.InSectionName = InSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.OnAbilityCancelledBy
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class UGameplayAbility*           InAbility                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::OnAbilityCancelledBy(const class UGameplayAbility* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "OnAbilityCancelledBy");

	Params::ActionHumanGameplayAbility_OnAbilityCancelledBy Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.OnCharge
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const bool                              bInBegin                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::OnCharge(const bool bInBegin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "OnCharge");

	Params::ActionHumanGameplayAbility_OnCharge Parms{};

	Parms.bInBegin = bInBegin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.OnNotifyMessage
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FActionHumanGameplayAbilityMessage&InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::OnNotifyMessage(const struct FActionHumanGameplayAbilityMessage& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "OnNotifyMessage");

	Params::ActionHumanGameplayAbility_OnNotifyMessage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.PlayAdditiveMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InStartTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::PlayAdditiveMontage(class UAnimMontage* InMontage, const float InStartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "PlayAdditiveMontage");

	Params::ActionHumanGameplayAbility_PlayAdditiveMontage Parms{};

	Parms.InMontage = InMontage;
	Parms.InStartTime = InStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.RequestLeftHandWeaponAppear
// (Final, Native, Public, BlueprintCallable)

void UActionHumanGameplayAbility::RequestLeftHandWeaponAppear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "RequestLeftHandWeaponAppear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.RequestLeftHandWeaponDisappear
// (Final, Native, Public, BlueprintCallable)

void UActionHumanGameplayAbility::RequestLeftHandWeaponDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "RequestLeftHandWeaponDisappear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.RequestWeaponAppear
// (Final, Native, Public, BlueprintCallable)

void UActionHumanGameplayAbility::RequestWeaponAppear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "RequestWeaponAppear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.RequestWeaponDisappear
// (Final, Native, Public, BlueprintCallable)

void UActionHumanGameplayAbility::RequestWeaponDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "RequestWeaponDisappear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.SetFly
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bToFly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::SetFly(bool bToFly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "SetFly");

	Params::ActionHumanGameplayAbility_SetFly Parms{};

	Parms.bToFly = bToFly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.StopAdditiveMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::StopAdditiveMontage(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "StopAdditiveMontage");

	Params::ActionHumanGameplayAbility_StopAdditiveMontage Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.StopUnContorolMontage
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const class UAnimMontage*               InMontage                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::StopUnContorolMontage(const class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "StopUnContorolMontage");

	Params::ActionHumanGameplayAbility_StopUnContorolMontage Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.UnBlockAbilitiesWithATag
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanGameplayAbility::UnBlockAbilitiesWithATag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "UnBlockAbilitiesWithATag");

	Params::ActionHumanGameplayAbility_UnBlockAbilitiesWithATag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanGameplayAbility.GetAbilityTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UActionHumanGameplayAbility::GetAbilityTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "GetAbilityTags");

	Params::ActionHumanGameplayAbility_GetAbilityTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanGameplayAbility.GetOwningAppCharacter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* UActionHumanGameplayAbility::GetOwningAppCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanGameplayAbility", "GetOwningAppCharacter");

	Params::ActionHumanGameplayAbility_GetOwningAppCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DamageReactionAbility.StartDeathScreenMask
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDamageReactionAbility::StartDeathScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageReactionAbility", "StartDeathScreenMask");

	Params::DamageReactionAbility_StartDeathScreenMask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DamageReactionAbility.GetSettings
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UActionHumanRespawnSettings*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UActionHumanRespawnSettings* UDamageReactionAbility::GetSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageReactionAbility", "GetSettings");

	Params::DamageReactionAbility_GetSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DamageReactionAbility.IsDramaEventVoicePlaying
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageReactionAbility::IsDramaEventVoicePlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageReactionAbility", "IsDramaEventVoicePlaying");

	Params::DamageReactionAbility_IsDramaEventVoicePlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanDebugSubsystem.IsEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InObject                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EActionHumanDebugCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanDebugSubsystem::IsEnabled(const class UObject* InObject, const EActionHumanDebugCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanDebugSubsystem", "IsEnabled");

	Params::ActionHumanDebugSubsystem_IsEnabled Parms{};

	Parms.InObject = InObject;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionProxy.Execute
// (Final, Native, Public)

void UActionHumanFunctionProxy::Execute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanFunctionProxy", "Execute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDecalActor.SetCategoryName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewCategoryName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppDecalActor::SetCategoryName(class FName NewCategoryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDecalActor", "SetCategoryName");

	Params::AppDecalActor_SetCategoryName Parms{};

	Parms.NewCategoryName = NewCategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDecalActor.SetMaxCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppDecalActor::SetMaxCount(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDecalActor", "SetMaxCount");

	Params::AppDecalActor_SetMaxCount Parms{};

	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDecalActor.SpawnDecal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDecalActorSpawnParameters*      InParameter                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AAppDecalActor::SpawnDecal(struct FDecalActorSpawnParameters* InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDecalActor", "SpawnDecal");

	Params::AppDecalActor_SpawnDecal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InParameter != nullptr)
		*InParameter = std::move(Parms.InParameter);
}


// Function Extensions.AppDecalActor.GetCurrentCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AAppDecalActor::GetCurrentCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDecalActor", "GetCurrentCount");

	Params::AppDecalActor_GetCurrentCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppDecalActor.GetMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AAppDecalActor::GetMaxCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDecalActor", "GetMaxCount");

	Params::AppDecalActor_GetMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment.OnDiscarded_BP
// (Event, Protected, BlueprintEvent)

void AActionHumanEquipment::OnDiscarded_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment", "OnDiscarded_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ActionHumanEquipment.OnEquipped_BP
// (Event, Protected, BlueprintEvent)

void AActionHumanEquipment::OnEquipped_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment", "OnEquipped_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ActionHumanEquipment.OnReserved_BP
// (Event, Protected, BlueprintEvent)

void AActionHumanEquipment::OnReserved_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment", "OnReserved_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ActionHumanEquipment.RegistryEquipMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InAttachSocket                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEquipPositionBindTag&     InEquipPositionBindTag                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanEquipment::RegistryEquipMesh(class USkeletalMeshComponent* InMeshComponent, const class FName InAttachSocket, const struct FEquipPositionBindTag& InEquipPositionBindTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment", "RegistryEquipMesh");

	Params::ActionHumanEquipment_RegistryEquipMesh Parms{};

	Parms.InMeshComponent = InMeshComponent;
	Parms.InAttachSocket = InAttachSocket;
	Parms.InEquipPositionBindTag = std::move(InEquipPositionBindTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment.GetUserAsActionHumanCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* AActionHumanEquipment::GetUserAsActionHumanCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment", "GetUserAsActionHumanCharacter");

	Params::ActionHumanEquipment_GetUserAsActionHumanCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GridMapManager.InitializeKnownMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CanvasWidth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CanvasHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridPixel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridMapManager::InitializeKnownMapping(int32 CanvasWidth, int32 CanvasHeight, int32 GridPixel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridMapManager", "InitializeKnownMapping");

	Params::GridMapManager_InitializeKnownMapping Parms{};

	Parms.CanvasWidth = CanvasWidth;
	Parms.CanvasHeight = CanvasHeight;
	Parms.GridPixel = GridPixel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GridMapManager.SetKnownMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridMapManager::SetKnownMapping(int32 X, int32 Y, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridMapManager", "SetKnownMapping");

	Params::GridMapManager_SetKnownMapping Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GridMapManager.UpdateKnownMappingData
// (Final, Native, Public, BlueprintCallable)

void UGridMapManager::UpdateKnownMappingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridMapManager", "UpdateKnownMappingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GridMapManager.UpdateKnownMappingTexture
// (Final, Native, Public, BlueprintCallable)

void UGridMapManager::UpdateKnownMappingTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridMapManager", "UpdateKnownMappingTexture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GridMapManager.GetKnownMappingTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UGridMapManager::GetKnownMappingTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridMapManager", "GetKnownMappingTexture");

	Params::GridMapManager_GetKnownMappingTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_Vampire.GetBloodSuckMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AActionHumanEquipment_Vampire::GetBloodSuckMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Vampire", "GetBloodSuckMesh");

	Params::ActionHumanEquipment_Vampire_GetBloodSuckMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_Vampire.OnAnimInitialized
// (Native, Protected)

void AActionHumanEquipment_Vampire::OnAnimInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Vampire", "OnAnimInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_Vampire.OnAnimNotifyBegin
// (Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AActionHumanEquipment_Vampire::OnAnimNotifyBegin(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, float InTotalDuration, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Vampire", "OnAnimNotifyBegin");

	Params::ActionHumanEquipment_Vampire_OnAnimNotifyBegin Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InTotalDuration = InTotalDuration;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_Vampire.ServerExecuteSpecialBloodSuck
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class AEnemyCharacter*                  InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSpecialBloodSuckInfo&     InInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AActionHumanEquipment_Vampire::ServerExecuteSpecialBloodSuck(class AEnemyCharacter* InTarget, const struct FSpecialBloodSuckInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Vampire", "ServerExecuteSpecialBloodSuck");

	Params::ActionHumanEquipment_Vampire_ServerExecuteSpecialBloodSuck Parms{};

	Parms.InTarget = InTarget;
	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_Vampire.SetBloodSuckMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanEquipment_Vampire::SetBloodSuckMesh(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Vampire", "SetBloodSuckMesh");

	Params::ActionHumanEquipment_Vampire_SetBloodSuckMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AudioListenerController.SetListenerDataAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UListenerDataAsset*               SetDataAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioListenerController::SetListenerDataAsset(class UListenerDataAsset* SetDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioListenerController", "SetListenerDataAsset");

	Params::AudioListenerController_SetListenerDataAsset Parms{};

	Parms.SetDataAsset = SetDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_Weapon.ShoudAdditionalActionAddInputBullet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAddInputBulletType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionHumanEquipment_Weapon::ShoudAdditionalActionAddInputBullet(EAddInputBulletType InType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Weapon", "ShoudAdditionalActionAddInputBullet");

	Params::ActionHumanEquipment_Weapon_ShoudAdditionalActionAddInputBullet Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PostProcessVolumeTrial.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessVolumeTrial::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessVolumeTrial", "AddOrUpdateBlendable");

	Params::PostProcessVolumeTrial_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_Bayonet.GetCanActivateDropEmptyShell
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADropEmptyShell*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropEmptyShell* AActionHumanEquipment_Bayonet::GetCanActivateDropEmptyShell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Bayonet", "GetCanActivateDropEmptyShell");

	Params::ActionHumanEquipment_Bayonet_GetCanActivateDropEmptyShell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_Bayonet.OnMoveInput
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FVector2D&                 InVector                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanEquipment_Bayonet::OnMoveInput(const struct FVector2D& InVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_Bayonet", "OnMoveInput");

	Params::ActionHumanEquipment_Bayonet_OnMoveInput Parms{};

	Parms.InVector = std::move(InVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_SAGadget.DeleteGadgetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AGadgetBase>          InActor                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanEquipment_SAGadget::DeleteGadgetActor(TSubclassOf<class AGadgetBase> InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_SAGadget", "DeleteGadgetActor");

	Params::ActionHumanEquipment_SAGadget_DeleteGadgetActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEquipment_SAGadget.GetGadgetActorByType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGadgetStateType                        InStateType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGadgetBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGadgetBase* AActionHumanEquipment_SAGadget::GetGadgetActorByType(EGadgetStateType InStateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_SAGadget", "GetGadgetActorByType");

	Params::ActionHumanEquipment_SAGadget_GetGadgetActorByType Parms{};

	Parms.InStateType = InStateType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_SAGadget.GetReadyGadgetActorByType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGadgetBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGadgetBase* AActionHumanEquipment_SAGadget::GetReadyGadgetActorByType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_SAGadget", "GetReadyGadgetActorByType");

	Params::ActionHumanEquipment_SAGadget_GetReadyGadgetActorByType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_SAGadget.SpawnGadgetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AGadgetBase>          InActor                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanEquipment_SAGadget::SpawnGadgetActor(TSubclassOf<class AGadgetBase> InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_SAGadget", "SpawnGadgetActor");

	Params::ActionHumanEquipment_SAGadget_SpawnGadgetActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapMenuUIObject.NotifyFastTravelProhibited
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapMenuUIObject::NotifyFastTravelProhibited(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMenuUIObject", "NotifyFastTravelProhibited");

	Params::MapMenuUIObject_NotifyFastTravelProhibited Parms{};

	Parms.InEnabled = InEnabled;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEquipment_ExecutionSword.ReceiveOnDiscard
// (Event, Protected, BlueprintEvent)

void AActionHumanEquipment_ExecutionSword::ReceiveOnDiscard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEquipment_ExecutionSword", "ReceiveOnDiscard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnemyBulletComponent.CreatePoolingData
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyBulletComponent::CreatePoolingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyBulletComponent", "CreatePoolingData");

	Params::EnemyBulletComponent_CreatePoolingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionVoiceSubtitlesUIObject.HideEmotionVoiceDialog
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmotionVoiceSubtitlesUIObject::HideEmotionVoiceDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionVoiceSubtitlesUIObject", "HideEmotionVoiceDialog");

	Params::EmotionVoiceSubtitlesUIObject_HideEmotionVoiceDialog Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionVoiceSubtitlesUIObject.IsShowEmotionVoiceDialog
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmotionVoiceSubtitlesUIObject::IsShowEmotionVoiceDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionVoiceSubtitlesUIObject", "IsShowEmotionVoiceDialog");

	Params::EmotionVoiceSubtitlesUIObject_IsShowEmotionVoiceDialog Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionVoiceSubtitlesUIObject.K2_ShowEmotionVoiceDialog
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InStatement                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmotionVoiceSubtitlesUIObject::K2_ShowEmotionVoiceDialog(const class FText& InStatement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionVoiceSubtitlesUIObject", "K2_ShowEmotionVoiceDialog");

	Params::EmotionVoiceSubtitlesUIObject_K2_ShowEmotionVoiceDialog Parms{};

	Parms.InStatement = std::move(InStatement);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BatManager.K2_ChargeStart
// (Final, Native, Public, BlueprintCallable)

void UBatManager::K2_ChargeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatManager", "K2_ChargeStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Pitfall.OnRep_ReplicatedContext
// (Final, Native, Protected)

void APitfall::OnRep_ReplicatedContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pitfall", "OnRep_ReplicatedContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Pitfall.ResetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInActivated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInImmediately                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APitfall::ResetState(bool bInActivated, bool bInImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pitfall", "ResetState");

	Params::Pitfall_ResetState Parms{};

	Parms.bInActivated = bInActivated;
	Parms.bInImmediately = bInImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Pitfall.UpdateState_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPitfallContext&           InContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APitfall::UpdateState_BP(const struct FPitfallContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pitfall", "UpdateState_BP");

	Params::Pitfall_UpdateState_BP Parms{};

	Parms.InContext = std::move(InContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.QSTask_ProtoSetEnemyLocation.OnScreenMaskCompleted
// (Final, Native, Private)

void UQSTask_ProtoSetEnemyLocation::OnScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ProtoSetEnemyLocation", "OnScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_ProtoSetEnemyLocation.OnWaitTime
// (Final, Native, Private)

void UQSTask_ProtoSetEnemyLocation::OnWaitTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ProtoSetEnemyLocation", "OnWaitTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.CanApplyPostProcess
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanApplyPostProcess(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanApplyPostProcess");

	Params::PhotoModeManager_CanApplyPostProcess Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanApplyRotationAndTranslation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanApplyRotationAndTranslation(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanApplyRotationAndTranslation");

	Params::PhotoModeManager_CanApplyRotationAndTranslation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanBlinkEachEye
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanBlinkEachEye(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanBlinkEachEye");

	Params::PhotoModeManager_CanBlinkEachEye Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanChangeEnvironment
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanChangeEnvironment(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanChangeEnvironment");

	Params::PhotoModeManager_CanChangeEnvironment Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanChangeFacial
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             CharacterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanChangeFacial(const class UObject* WorldContextObject, const int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanChangeFacial");

	Params::PhotoModeManager_CanChangeFacial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanChangeToStillMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanChangeToStillMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanChangeToStillMode");

	Params::PhotoModeManager_CanChangeToStillMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.CanRequestPose
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             CharacterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::CanRequestPose(const class UObject* WorldContextObject, const int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "CanRequestPose");

	Params::PhotoModeManager_CanRequestPose Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.EndPhotoMode
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::EndPhotoMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "EndPhotoMode");

	Params::PhotoModeManager_EndPhotoMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.GetBoolParam
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeBoolParameter                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::GetBoolParam(const class UObject* WorldContextObject, EPhotoModeBoolParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetBoolParam");

	Params::PhotoModeManager_GetBoolParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetCharacterIntParam
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeCharacterParameter            Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPhotoModeManager::GetCharacterIntParam(const class UObject* WorldContextObject, EPhotoModeCharacterParameter Parameter, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetCharacterIntParam");

	Params::PhotoModeManager_GetCharacterIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parameter = Parameter;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetFacialExpressionDisplayTexts
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UPhotoModeManager::GetFacialExpressionDisplayTexts(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetFacialExpressionDisplayTexts");

	Params::PhotoModeManager_GetFacialExpressionDisplayTexts Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetFloatParam
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeFloatParameter                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhotoModeManager::GetFloatParam(const class UObject* WorldContextObject, EPhotoModeFloatParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetFloatParam");

	Params::PhotoModeManager_GetFloatParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetFrameDisplayTexts
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPhotoFrameType                   FrameType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UPhotoModeManager::GetFrameDisplayTexts(const class UObject* WorldContextObject, const EPhotoFrameType FrameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetFrameDisplayTexts");

	Params::PhotoModeManager_GetFrameDisplayTexts Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FrameType = FrameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetIntParam
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeIntParameter                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPhotoModeManager::GetIntParam(const class UObject* WorldContextObject, EPhotoModeIntParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetIntParam");

	Params::PhotoModeManager_GetIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetPoseDisplayTexts
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UPhotoModeManager::GetPoseDisplayTexts(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetPoseDisplayTexts");

	Params::PhotoModeManager_GetPoseDisplayTexts Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetPostProcessDisplayTexts
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UPhotoModeManager::GetPostProcessDisplayTexts(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetPostProcessDisplayTexts");

	Params::PhotoModeManager_GetPostProcessDisplayTexts Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetTakeOffBuddyCostumeTypeNum
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPhotoModeManager::GetTakeOffBuddyCostumeTypeNum(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetTakeOffBuddyCostumeTypeNum");

	Params::PhotoModeManager_GetTakeOffBuddyCostumeTypeNum Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetTargetCharacterDisplayTexts
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UPhotoModeManager::GetTargetCharacterDisplayTexts(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "GetTargetCharacterDisplayTexts");

	Params::PhotoModeManager_GetTargetCharacterDisplayTexts Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.HasMotorcycle
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::HasMotorcycle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "HasMotorcycle");

	Params::PhotoModeManager_HasMotorcycle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsCharacterRidingMount
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsCharacterRidingMount(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsCharacterRidingMount");

	Params::PhotoModeManager_IsCharacterRidingMount Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsCompanionCharacterExist
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsCompanionCharacterExist(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsCompanionCharacterExist");

	Params::PhotoModeManager_IsCompanionCharacterExist Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsEnablePropMotorcycle
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsEnablePropMotorcycle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsEnablePropMotorcycle");

	Params::PhotoModeManager_IsEnablePropMotorcycle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsEnableTakeOffBuddyCostume
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsEnableTakeOffBuddyCostume(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsEnableTakeOffBuddyCostume");

	Params::PhotoModeManager_IsEnableTakeOffBuddyCostume Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsLoopPose
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             CharacterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsLoopPose(const class UObject* WorldContextObject, const int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsLoopPose");

	Params::PhotoModeManager_IsLoopPose Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsRealTimeMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsRealTimeMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsRealTimeMode");

	Params::PhotoModeManager_IsRealTimeMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsStillMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsStillMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsStillMode");

	Params::PhotoModeManager_IsStillMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsUsePostProcessBlendWeight
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsUsePostProcessBlendWeight(const class UObject* WorldContextObject, const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsUsePostProcessBlendWeight");

	Params::PhotoModeManager_IsUsePostProcessBlendWeight Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsValidWeatherType
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeWeatherType                   WeatherType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsValidWeatherType(const class UObject* WorldContextObject, EPhotoModeWeatherType WeatherType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "IsValidWeatherType");

	Params::PhotoModeManager_IsValidWeatherType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WeatherType = WeatherType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.RequestAdvanceFrameForward
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::RequestAdvanceFrameForward(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "RequestAdvanceFrameForward");

	Params::PhotoModeManager_RequestAdvanceFrameForward Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.RequestPlayPose
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::RequestPlayPose(const class UObject* WorldContextObject, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "RequestPlayPose");

	Params::PhotoModeManager_RequestPlayPose Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.ResetBoolParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeBoolParameter                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::ResetBoolParam(const class UObject* WorldContextObject, EPhotoModeBoolParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "ResetBoolParam");

	Params::PhotoModeManager_ResetBoolParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.ResetCharacterIntParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeCharacterParameter            Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::ResetCharacterIntParam(const class UObject* WorldContextObject, EPhotoModeCharacterParameter Parameter, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "ResetCharacterIntParam");

	Params::PhotoModeManager_ResetCharacterIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parameter = Parameter;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.ResetCharacterParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeCharacterParameter            Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::ResetCharacterParam(const class UObject* WorldContextObject, EPhotoModeCharacterParameter Parameter, int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "ResetCharacterParam");

	Params::PhotoModeManager_ResetCharacterParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parameter = Parameter;
	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.ResetIntParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeIntParameter                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::ResetIntParam(const class UObject* WorldContextObject, EPhotoModeIntParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "ResetIntParam");

	Params::PhotoModeManager_ResetIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.ResetParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeParameter                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::ResetParam(const class UObject* WorldContextObject, EPhotoModeParameter Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "ResetParam");

	Params::PhotoModeManager_ResetParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetBoolParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeBoolParameter                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::SetBoolParam(const class UObject* WorldContextObject, EPhotoModeBoolParameter Type, bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "SetBoolParam");

	Params::PhotoModeManager_SetBoolParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetCharacterIntParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeCharacterParameter            Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::SetCharacterIntParam(const class UObject* WorldContextObject, EPhotoModeCharacterParameter Parameter, int32 CharacterIndex, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "SetCharacterIntParam");

	Params::PhotoModeManager_SetCharacterIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parameter = Parameter;
	Parms.CharacterIndex = CharacterIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetFloatParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeFloatParameter                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::SetFloatParam(const class UObject* WorldContextObject, EPhotoModeFloatParameter Type, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "SetFloatParam");

	Params::PhotoModeManager_SetFloatParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetIntParam
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhotoModeIntParameter                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::SetIntParam(const class UObject* WorldContextObject, EPhotoModeIntParameter Type, int32 Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "SetIntParam");

	Params::PhotoModeManager_SetIntParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetRealTimeMode
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRealTimeMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoModeManager::SetRealTimeMode(const class UObject* WorldContextObject, bool bRealTimeMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoModeManager", "SetRealTimeMode");

	Params::PhotoModeManager_SetRealTimeMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bRealTimeMode = bRealTimeMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.OnPhotoModeAdjustableParameterChanged
// (Final, Native, Protected)

void UPhotoModeManager::OnPhotoModeAdjustableParameterChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "OnPhotoModeAdjustableParameterChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.OnPhotoModeCameraParameterChanged
// (Final, Native, Protected)

void UPhotoModeManager::OnPhotoModeCameraParameterChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "OnPhotoModeCameraParameterChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.SetCurrentViewParamsAsOriginal_BP
// (Final, Native, Protected, BlueprintCallable)

void UPhotoModeManager::SetCurrentViewParamsAsOriginal_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "SetCurrentViewParamsAsOriginal_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeManager.GetAdjustableParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPhotoModeAdjustableParameterReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPhotoModeAdjustableParameter UPhotoModeManager::GetAdjustableParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "GetAdjustableParameter");

	Params::PhotoModeManager_GetAdjustableParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.GetPhotoModeCameraActor_BP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APhotoModeCameraActor*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhotoModeCameraActor* UPhotoModeManager::GetPhotoModeCameraActor_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "GetPhotoModeCameraActor_BP");

	Params::PhotoModeManager_GetPhotoModeCameraActor_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeManager.IsModeActive_BP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoModeManager::IsModeActive_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeManager", "IsModeActive_BP");

	Params::PhotoModeManager_IsModeActive_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyPatrolComponent.OnChangePatrolPointGroup
// (Final, Native, Private)
// Parameters:
// class APatrolPointGroup*                NextPatrolPointGroup                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyPatrolComponent::OnChangePatrolPointGroup(class APatrolPointGroup* NextPatrolPointGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyPatrolComponent", "OnChangePatrolPointGroup");

	Params::EnemyPatrolComponent_OnChangePatrolPointGroup Parms{};

	Parms.NextPatrolPointGroup = NextPatrolPointGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingCharacterComponent.OnInteractionBegin
// (Final, Native, Protected)

void UMatchingCharacterComponent::OnInteractionBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingCharacterComponent", "OnInteractionBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingCharacterComponent.OnInteractionEnd
// (Final, Native, Protected)

void UMatchingCharacterComponent::OnInteractionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingCharacterComponent", "OnInteractionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingCharacterComponent.OnJoinSessionComplete
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FOnlineResultInformation&  InResult                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchingCharacterComponent::OnJoinSessionComplete(const struct FOnlineResultInformation& InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingCharacterComponent", "OnJoinSessionComplete");

	Params::MatchingCharacterComponent_OnJoinSessionComplete Parms{};

	Parms.InResult = std::move(InResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InvaderWaveManager.AbortWave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvaderWaveManager::AbortWave(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InvaderWaveManager", "AbortWave");

	Params::InvaderWaveManager_AbortWave Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InvaderWaveManager.BeginWave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInvaderWaveStageDataAsset*       InStageData                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvaderWaveManager::BeginWave(const class UObject* WorldContextObject, class UInvaderWaveStageDataAsset* InStageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InvaderWaveManager", "BeginWave");

	Params::InvaderWaveManager_BeginWave Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InStageData = InStageData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InvaderWaveManager.InvaderWaveForceEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInvaderWaveStageDataAsset* InStageData                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvaderWaveManager::InvaderWaveForceEnd(const class UObject* WorldContextObject, const class UInvaderWaveStageDataAsset* InStageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InvaderWaveManager", "InvaderWaveForceEnd");

	Params::InvaderWaveManager_InvaderWaveForceEnd Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InStageData = InStageData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InvaderWaveManager.ServerBeginWave
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UInvaderWaveStageDataAsset*       InStageData                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvaderWaveManager::ServerBeginWave(class UInvaderWaveStageDataAsset* InStageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvaderWaveManager", "ServerBeginWave");

	Params::InvaderWaveManager_ServerBeginWave Parms{};

	Parms.InStageData = InStageData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArticleInfoMenuPieceBase.IsActuallyVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArticleInfoMenuPieceBase::IsActuallyVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleInfoMenuPieceBase", "IsActuallyVisible");

	Params::ArticleInfoMenuPieceBase_IsActuallyVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanEventVisUserWidget.OnAnimNotifyState
// (Native, Protected)
// Parameters:
// const class UAnimNotifyState*           ANS                                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsBegin                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanEventVisUserWidget::OnAnimNotifyState(const class UAnimNotifyState* ANS, const bool bIsBegin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEventVisUserWidget", "OnAnimNotifyState");

	Params::ActionHumanEventVisUserWidget_OnAnimNotifyState Parms{};

	Parms.ANS = ANS;
	Parms.bIsBegin = bIsBegin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanEventVisUserWidget.OnMovementModeChanged
// (Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanEventVisUserWidget::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanEventVisUserWidget", "OnMovementModeChanged");

	Params::ActionHumanEventVisUserWidget_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckBatVisualController.GetInCinematic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckBatVisualController::GetInCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "GetInCinematic");

	Params::BloodSuckBatVisualController_GetInCinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatVisualController.K2_OnChangeBloodSuckBatState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EBloodSuckBatState                InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodSuckBatVisualController::K2_OnChangeBloodSuckBatState(const EBloodSuckBatState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "K2_OnChangeBloodSuckBatState");

	Params::BloodSuckBatVisualController_K2_OnChangeBloodSuckBatState Parms{};

	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BloodSuckBatVisualController.OnFinishCinematic
// (Final, Native, Public)

void UBloodSuckBatVisualController::OnFinishCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "OnFinishCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckBatVisualController.OnFinishCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckBatVisualController::OnFinishCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "OnFinishCinematicEvent");

	Params::BloodSuckBatVisualController_OnFinishCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatVisualController.OnStartCinematic
// (Final, Native, Public)

void UBloodSuckBatVisualController::OnStartCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "OnStartCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckBatVisualController.OnStartCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckBatVisualController::OnStartCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "OnStartCinematicEvent");

	Params::BloodSuckBatVisualController_OnStartCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatVisualController.K2_GetActiveBatGroupComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UBloodSuckBatGroupComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UBloodSuckBatGroupComponent*> UBloodSuckBatVisualController::K2_GetActiveBatGroupComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "K2_GetActiveBatGroupComponents");

	Params::BloodSuckBatVisualController_K2_GetActiveBatGroupComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatVisualController.K2_GetBloodSuckBatState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBloodSuckBatState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBloodSuckBatState UBloodSuckBatVisualController::K2_GetBloodSuckBatState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatVisualController", "K2_GetBloodSuckBatState");

	Params::BloodSuckBatVisualController_K2_GetBloodSuckBatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FacialControlComponent.NetMulticastPlayFacialAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EFacialType                             FacialType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFacialControlComponent::NetMulticastPlayFacialAnimation(EFacialType FacialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FacialControlComponent", "NetMulticastPlayFacialAnimation");

	Params::FacialControlComponent_NetMulticastPlayFacialAnimation Parms{};

	Parms.FacialType = FacialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FacialControlComponent.ServerRequestPlayFacialAnimation
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// EFacialType                             FacialType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFacialControlComponent::ServerRequestPlayFacialAnimation(EFacialType FacialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FacialControlComponent", "ServerRequestPlayFacialAnimation");

	Params::FacialControlComponent_ServerRequestPlayFacialAnimation Parms{};

	Parms.FacialType = FacialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FacialControlComponent.IsValidFacial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFacialType                             FacialType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFacialControlComponent::IsValidFacial(EFacialType FacialType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FacialControlComponent", "IsValidFacial");

	Params::FacialControlComponent_IsValidFacial Parms{};

	Parms.FacialType = FacialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimationControlInfo.OnMontageBlendingOutStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationControlInfo::OnMontageBlendingOutStarted(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationControlInfo", "OnMontageBlendingOutStarted");

	Params::AnimationControlInfo_OnMontageBlendingOutStarted Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AnimationControlInfo.OnMontageEnded
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationControlInfo::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationControlInfo", "OnMontageEnded");

	Params::AnimationControlInfo_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AnimationControlInfo.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationControlInfo::OnMontageStarted(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationControlInfo", "OnMontageStarted");

	Params::AnimationControlInfo_OnMontageStarted Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanFacialControlComponent.OnEndPhotoMode
// (Final, Native, Protected)

void UActionHumanFacialControlComponent::OnEndPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanFacialControlComponent", "OnEndPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanFacialControlComponent.OnStartPhotoMode
// (Final, Native, Protected)

void UActionHumanFacialControlComponent::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanFacialControlComponent", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanFunctionLibrary.BindProcessRootMotionPostConvertToWorld_AddRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRot                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InDuration                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionHumanProcessRootMotionDelegateHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActionHumanProcessRootMotionDelegateHandle UActionHumanFunctionLibrary::BindProcessRootMotionPostConvertToWorld_AddRotation(const class AActionHumanCharacter* InCharacter, const struct FRotator& InRot, const float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "BindProcessRootMotionPostConvertToWorld_AddRotation");

	Params::ActionHumanFunctionLibrary_BindProcessRootMotionPostConvertToWorld_AddRotation Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InRot = std::move(InRot);
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.BindProcessRootMotionPostConvertToWorld_None
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDuration                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionHumanProcessRootMotionDelegateHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActionHumanProcessRootMotionDelegateHandle UActionHumanFunctionLibrary::BindProcessRootMotionPostConvertToWorld_None(const class AActionHumanCharacter* InCharacter, const float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "BindProcessRootMotionPostConvertToWorld_None");

	Params::ActionHumanFunctionLibrary_BindProcessRootMotionPostConvertToWorld_None Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.BindProcessRootMotionPostConvertToWorld_RotateTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDirection                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDuration                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionHumanProcessRootMotionDelegateHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActionHumanProcessRootMotionDelegateHandle UActionHumanFunctionLibrary::BindProcessRootMotionPostConvertToWorld_RotateTo(const class AActionHumanCharacter* InCharacter, const struct FVector& InDirection, const float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "BindProcessRootMotionPostConvertToWorld_RotateTo");

	Params::ActionHumanFunctionLibrary_BindProcessRootMotionPostConvertToWorld_RotateTo Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InDirection = std::move(InDirection);
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.BindProcessRootMotionPostConvertToWorld_TransformProportionalToTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InTargetTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDuration                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTolerance                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionHumanProcessRootMotionDelegateHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActionHumanProcessRootMotionDelegateHandle UActionHumanFunctionLibrary::BindProcessRootMotionPostConvertToWorld_TransformProportionalToTime(const class AActionHumanCharacter* InCharacter, const struct FTransform& InTargetTransform, const float InDuration, const float InTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "BindProcessRootMotionPostConvertToWorld_TransformProportionalToTime");

	Params::ActionHumanFunctionLibrary_BindProcessRootMotionPostConvertToWorld_TransformProportionalToTime Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InTargetTransform = std::move(InTargetTransform);
	Parms.InDuration = InDuration;
	Parms.InTolerance = InTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ExtractRootMotion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimSequence*              InAnimSequence                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InFromTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDeltaTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInLoop                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UActionHumanFunctionLibrary::ExtractRootMotion(const class UAnimSequence* InAnimSequence, const float InFromTime, const float InDeltaTime, const bool bInLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ExtractRootMotion");

	Params::ActionHumanFunctionLibrary_ExtractRootMotion Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InFromTime = InFromTime;
	Parms.InDeltaTime = InDeltaTime;
	Parms.bInLoop = bInLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ExtractRootMotion_Montage
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               InAnimMontage                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InFromTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDeltaTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAlsoMotionWarpingOffset                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UActionHumanFunctionLibrary::ExtractRootMotion_Montage(const class UAnimMontage* InAnimMontage, const float InFromTime, const float InDeltaTime, bool bInAlsoMotionWarpingOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ExtractRootMotion_Montage");

	Params::ActionHumanFunctionLibrary_ExtractRootMotion_Montage Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InFromTime = InFromTime;
	Parms.InDeltaTime = InDeltaTime;
	Parms.bInAlsoMotionWarpingOffset = bInAlsoMotionWarpingOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ExtractRootMotionBlendSpace
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UBlendSpace*                InBlendSpace                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InX                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InY                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InFromTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InDeltaTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInLoop                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UActionHumanFunctionLibrary::ExtractRootMotionBlendSpace(const class UBlendSpace* InBlendSpace, const float InX, const float InY, const float InFromTime, const float InDeltaTime, const bool bInLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ExtractRootMotionBlendSpace");

	Params::ActionHumanFunctionLibrary_ExtractRootMotionBlendSpace Parms{};

	Parms.InBlendSpace = InBlendSpace;
	Parms.InX = InX;
	Parms.InY = InY;
	Parms.InFromTime = InFromTime;
	Parms.InDeltaTime = InDeltaTime;
	Parms.bInLoop = bInLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.FindAngleBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InA                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InB                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::FindAngleBetween(const struct FVector& InA, const struct FVector& InB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "FindAngleBetween");

	Params::ActionHumanFunctionLibrary_FindAngleBetween Parms{};

	Parms.InA = std::move(InA);
	Parms.InB = std::move(InB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.FindAngleBetweenAbout
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InA                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InB                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InN                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::FindAngleBetweenAbout(const struct FVector& InA, const struct FVector& InB, const struct FVector& InN)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "FindAngleBetweenAbout");

	Params::ActionHumanFunctionLibrary_FindAngleBetweenAbout Parms{};

	Parms.InA = std::move(InA);
	Parms.InB = std::move(InB);
	Parms.InN = std::move(InN);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.FindDeltaAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             InA                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InB                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::FindDeltaAngle(const float InA, const float InB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "FindDeltaAngle");

	Params::ActionHumanFunctionLibrary_FindDeltaAngle Parms{};

	Parms.InA = InA;
	Parms.InB = InB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetCancelNotify
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UActionHumanFunctionLibrary::GetCancelNotify(const struct FGameplayTag& InTag, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetCancelNotify");

	Params::ActionHumanFunctionLibrary_GetCancelNotify Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function Extensions.ActionHumanFunctionLibrary.GetCancelTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer*           OutTags                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UActionHumanFunctionLibrary::GetCancelTags(const class FName InNotifyName, struct FGameplayTagContainer* OutTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetCancelTags");

	Params::ActionHumanFunctionLibrary_GetCancelTags Parms{};

	Parms.InNotifyName = InNotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTags != nullptr)
		*OutTags = std::move(Parms.OutTags);
}


// Function Extensions.ActionHumanFunctionLibrary.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              InObjectClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UActionHumanFunctionLibrary::GetDefaultObject(TSubclassOf<class UObject> InObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetDefaultObject");

	Params::ActionHumanFunctionLibrary_GetDefaultObject Parms{};

	Parms.InObjectClass = InObjectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             InRad                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNumOfDivs                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutSlackRad                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActionHumanFunctionLibrary::GetDirection(const float InRad, const int32 InNumOfDivs, float* OutSlackRad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetDirection");

	Params::ActionHumanFunctionLibrary_GetDirection Parms{};

	Parms.InRad = InRad;
	Parms.InNumOfDivs = InNumOfDivs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlackRad != nullptr)
		*OutSlackRad = Parms.OutSlackRad;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetLookAtLocationAndRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 InSelfCharacter                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::GetLookAtLocationAndRotation(const class ACharacter* InSelfCharacter, struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetLookAtLocationAndRotation");

	Params::ActionHumanFunctionLibrary_GetLookAtLocationAndRotation Parms{};

	Parms.InSelfCharacter = InSelfCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetMontageInstanceIDFromAnimNotifyEventReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimNotifyEventReference& AnimNotifyEventReferenc                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  OutMontageInstanceID                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::GetMontageInstanceIDFromAnimNotifyEventReference(const struct FAnimNotifyEventReference& AnimNotifyEventReferenc, int32* OutMontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetMontageInstanceIDFromAnimNotifyEventReference");

	Params::ActionHumanFunctionLibrary_GetMontageInstanceIDFromAnimNotifyEventReference Parms{};

	Parms.AnimNotifyEventReferenc = std::move(AnimNotifyEventReferenc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMontageInstanceID != nullptr)
		*OutMontageInstanceID = Parms.OutMontageInstanceID;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetRuntimeFloatCurveValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRuntimeFloatCurve&        InCurve                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             InTime                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::GetRuntimeFloatCurveValue(const struct FRuntimeFloatCurve& InCurve, const float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetRuntimeFloatCurveValue");

	Params::ActionHumanFunctionLibrary_GetRuntimeFloatCurveValue Parms{};

	Parms.InCurve = std::move(InCurve);
	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetSeparateMeshRotationDuration_Start
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::GetSeparateMeshRotationDuration_Start(const class AActionHumanCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetSeparateMeshRotationDuration_Start");

	Params::ActionHumanFunctionLibrary_GetSeparateMeshRotationDuration_Start Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.GetServerWorldTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWorld*                     InWorld                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::GetServerWorldTimeSeconds(const class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "GetServerWorldTimeSeconds");

	Params::ActionHumanFunctionLibrary_GetServerWorldTimeSeconds Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.LerpDeg
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             InA                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InB                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InAlpha                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::LerpDeg(const float InA, const float InB, const float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "LerpDeg");

	Params::ActionHumanFunctionLibrary_LerpDeg Parms{};

	Parms.InA = InA;
	Parms.InB = InB;
	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.LerpRad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             InA                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InB                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InAlpha                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanFunctionLibrary::LerpRad(const float InA, const float InB, const float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "LerpRad");

	Params::ActionHumanFunctionLibrary_LerpRad Parms{};

	Parms.InA = InA;
	Parms.InB = InB;
	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.SendGameplayAbilityMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UActionHumanAbilitySystem*        InAbilitySystemComponent                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UActionHumanGameplayAbility>>&InAbilities                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FActionHumanGameplayAbilityMessage&InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::SendGameplayAbilityMessage(class UActionHumanAbilitySystem* InAbilitySystemComponent, const TArray<TSubclassOf<class UActionHumanGameplayAbility>>& InAbilities, const struct FActionHumanGameplayAbilityMessage& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "SendGameplayAbilityMessage");

	Params::ActionHumanFunctionLibrary_SendGameplayAbilityMessage Parms{};

	Parms.InAbilitySystemComponent = InAbilitySystemComponent;
	Parms.InAbilities = std::move(InAbilities);
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ShouldHideReservedEquipments
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::ShouldHideReservedEquipments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ShouldHideReservedEquipments");

	Params::ActionHumanFunctionLibrary_ShouldHideReservedEquipments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ShouldSeparateMeshRotationDuration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::ShouldSeparateMeshRotationDuration(const class AActionHumanCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ShouldSeparateMeshRotationDuration");

	Params::ActionHumanFunctionLibrary_ShouldSeparateMeshRotationDuration Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.ShouldUseRightFootFrontStance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionHumanFunctionLibrary::ShouldUseRightFootFrontStance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "ShouldUseRightFootFrontStance");

	Params::ActionHumanFunctionLibrary_ShouldUseRightFootFrontStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanFunctionLibrary.UnbindProcessRootMotionPostConvertToWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActionHumanProcessRootMotionDelegateHandle&InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionHumanFunctionLibrary::UnbindProcessRootMotionPostConvertToWorld(const class AActionHumanCharacter* InCharacter, const struct FActionHumanProcessRootMotionDelegateHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionHumanFunctionLibrary", "UnbindProcessRootMotionPostConvertToWorld");

	Params::ActionHumanFunctionLibrary_UnbindProcessRootMotionPostConvertToWorld Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeCharacterAnimInstance.GetCharacterAnimParameter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterAnimParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterAnimParameter UCharacterCustomizeCharacterAnimInstance::GetCharacterAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeCharacterAnimInstance", "GetCharacterAnimParameter");

	Params::CharacterCustomizeCharacterAnimInstance_GetCharacterAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DramaEventManager.AddEventPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InEventPointUpName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDramaEventManager::AddEventPoint(class FName InEventPointUpName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DramaEventManager", "AddEventPoint");

	Params::DramaEventManager_AddEventPoint Parms{};

	Parms.InEventPointUpName = InEventPointUpName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LookAtAnimInstance.GetLookAtAnimParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimLookAtParameter       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimLookAtParameter ULookAtAnimInstance::GetLookAtAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtAnimInstance", "GetLookAtAnimParameter");

	Params::LookAtAnimInstance_GetLookAtAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimalMovementComponent.GetMoveYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimalMovementComponent::GetMoveYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalMovementComponent", "GetMoveYaw");

	Params::AnimalMovementComponent_GetMoveYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimalMovementComponent.GetTargetMoveSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimalMovementComponent::GetTargetMoveSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalMovementComponent", "GetTargetMoveSpeed");

	Params::AnimalMovementComponent_GetTargetMoveSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimalMovementComponent.GetTargetMoveYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimalMovementComponent::GetTargetMoveYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalMovementComponent", "GetTargetMoveYaw");

	Params::AnimalMovementComponent_GetTargetMoveYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EffectManager.RegisterSystemEffect_BP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::RegisterSystemEffect_BP(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "RegisterSystemEffect_BP");

	Params::EffectManager_RegisterSystemEffect_BP Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EffectManager.RegisterSystemEffectFromActor_BP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::RegisterSystemEffectFromActor_BP(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "RegisterSystemEffectFromActor_BP");

	Params::EffectManager_RegisterSystemEffectFromActor_BP Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EffectManager.UnregisterSystemEffect_BP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::UnregisterSystemEffect_BP(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "UnregisterSystemEffect_BP");

	Params::EffectManager_UnregisterSystemEffect_BP Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EffectManager.UnregisterSystemEffectFromActor_BP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::UnregisterSystemEffectFromActor_BP(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "UnregisterSystemEffectFromActor_BP");

	Params::EffectManager_UnregisterSystemEffectFromActor_BP Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanLookAtAnimInstance.OnStartPhotoMode
// (Final, Native, Protected)

void UActionHumanLookAtAnimInstance::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanLookAtAnimInstance", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanLookAtAnimInstance.OnStartPhotoModeStillMode
// (Final, Native, Protected)

void UActionHumanLookAtAnimInstance::OnStartPhotoModeStillMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanLookAtAnimInstance", "OnStartPhotoModeStillMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanMotionWarping.AddOrUpdateTowardsTarget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionWarpingTowards&     InTowardsTarget                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionHumanMotionWarping::AddOrUpdateTowardsTarget(const struct FMotionWarpingTowards& InTowardsTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMotionWarping", "AddOrUpdateTowardsTarget");

	Params::ActionHumanMotionWarping_AddOrUpdateTowardsTarget Parms{};

	Parms.InTowardsTarget = std::move(InTowardsTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.GetNewDriverCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCharacter* AMountWolfCharacter::GetNewDriverCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "GetNewDriverCharacter");

	Params::MountWolfCharacter_GetNewDriverCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfCharacter.GetRiderSocketLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMountWolfCharacter::GetRiderSocketLocation(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "GetRiderSocketLocation");

	Params::MountWolfCharacter_GetRiderSocketLocation Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfCharacter.IsRidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMountWolfCharacter::IsRidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "IsRidden");

	Params::MountWolfCharacter_IsRidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfCharacter.MakeLocoLoopAnimStart
// (Final, Native, Public, BlueprintCallable)

void AMountWolfCharacter::MakeLocoLoopAnimStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "MakeLocoLoopAnimStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.MakeLocoStopAnimStart
// (Final, Native, Public, BlueprintCallable)

void AMountWolfCharacter::MakeLocoStopAnimStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "MakeLocoStopAnimStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.OnStartCutturn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMountWolfMoveType                      InMoveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMountWolfCharacter::OnStartCutturn(EMountWolfMoveType InMoveType, bool IsRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "OnStartCutturn");

	Params::MountWolfCharacter_OnStartCutturn Parms{};

	Parms.InMoveType = InMoveType;
	Parms.IsRight = IsRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.OnStartStateNode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMountWolfStateType                     InStateType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InResetbPlayLoco                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMountWolfCharacter::OnStartStateNode(EMountWolfStateType InStateType, bool InResetbPlayLoco)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "OnStartStateNode");

	Params::MountWolfCharacter_OnStartStateNode Parms{};

	Parms.InStateType = InStateType;
	Parms.InResetbPlayLoco = InResetbPlayLoco;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.RequestNewGettingOff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              InPlayAnim                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMountWolfCharacter::RequestNewGettingOff(const bool InPlayAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "RequestNewGettingOff");

	Params::MountWolfCharacter_RequestNewGettingOff Parms{};

	Parms.InPlayAnim = InPlayAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.RequestNewRide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerCharacter*                 InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMountWolfCharacter::RequestNewRide(class APlayerCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "RequestNewRide");

	Params::MountWolfCharacter_RequestNewRide Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfCharacter.GetLastJumpApexLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMountWolfCharacter::GetLastJumpApexLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "GetLastJumpApexLocation");

	Params::MountWolfCharacter_GetLastJumpApexLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfCharacter.GetMountWolfMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMountWolfMovementComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMountWolfMovementComponent* AMountWolfCharacter::GetMountWolfMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "GetMountWolfMovement");

	Params::MountWolfCharacter_GetMountWolfMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfCharacter.GetMountWolfSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMountWolfSettings*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMountWolfSettings* AMountWolfCharacter::GetMountWolfSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfCharacter", "GetMountWolfSettings");

	Params::MountWolfCharacter_GetMountWolfSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArticleFunctionAnim.GetAnimation
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UArticleFunctionAnim::GetAnimation(class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleFunctionAnim", "GetAnimation");

	Params::ArticleFunctionAnim_GetAnimation Parms{};

	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerBackAttackComponent.ApplyBackAttackDamage_Buffed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBackAttackComponent::ApplyBackAttackDamage_Buffed(class AEnemyCharacter* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBackAttackComponent", "ApplyBackAttackDamage_Buffed");

	Params::PlayerBackAttackComponent_ApplyBackAttackDamage_Buffed Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerBackAttackComponent.ApplyBackAttackDamage_Normal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBackAttackComponent::ApplyBackAttackDamage_Normal(class AEnemyCharacter* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBackAttackComponent", "ApplyBackAttackDamage_Normal");

	Params::PlayerBackAttackComponent_ApplyBackAttackDamage_Normal Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AlertReceiver.OnAlertEnded
// (Final, Native, Protected)

void AAlertReceiver::OnAlertEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlertReceiver", "OnAlertEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AlertReceiver.OnAlertEndedEvent
// (Event, Protected, BlueprintEvent)

void AAlertReceiver::OnAlertEndedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlertReceiver", "OnAlertEndedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.AlertReceiver.OnAlertStarted
// (Final, Native, Protected)

void AAlertReceiver::OnAlertStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlertReceiver", "OnAlertStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AlertReceiver.OnAlertStartedEvent
// (Event, Protected, BlueprintEvent)

void AAlertReceiver::OnAlertStartedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlertReceiver", "OnAlertStartedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ActionHumanMovementComponent.CancelPreventionOfDelayedMoveStateReturnToIdle
// (Final, Native, Public, BlueprintCallable)

void UActionHumanMovementComponent::CancelPreventionOfDelayedMoveStateReturnToIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "CancelPreventionOfDelayedMoveStateReturnToIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanMovementComponent.DisableOrientRotationToMovementForATick
// (Final, Native, Public, BlueprintCallable)

void UActionHumanMovementComponent::DisableOrientRotationToMovementForATick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "DisableOrientRotationToMovementForATick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanMovementComponent.GetLastHandleImpactNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActionHumanMovementComponent::GetLastHandleImpactNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetLastHandleImpactNormal");

	Params::ActionHumanMovementComponent_GetLastHandleImpactNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetDelayedMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerMoveState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerMoveState UActionHumanMovementComponent::GetDelayedMoveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetDelayedMoveState");

	Params::ActionHumanMovementComponent_GetDelayedMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetFrontSlopeAngleForAnimation
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanMovementComponent::GetFrontSlopeAngleForAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetFrontSlopeAngleForAnimation");

	Params::ActionHumanMovementComponent_GetFrontSlopeAngleForAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetMaxSpeedWithoutOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanMovementComponent::GetMaxSpeedWithoutOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetMaxSpeedWithoutOverride");

	Params::ActionHumanMovementComponent_GetMaxSpeedWithoutOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetMoveDirection_8Way
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActionHumanMovementComponent::GetMoveDirection_8Way() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetMoveDirection_8Way");

	Params::ActionHumanMovementComponent_GetMoveDirection_8Way Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetMoveDirection_Deg
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanMovementComponent::GetMoveDirection_Deg() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetMoveDirection_Deg");

	Params::ActionHumanMovementComponent_GetMoveDirection_Deg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerMoveState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerMoveState UActionHumanMovementComponent::GetMoveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetMoveState");

	Params::ActionHumanMovementComponent_GetMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetMoveStateByAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InAcceleration                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsCrouching                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsStrafing                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerMoveState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerMoveState UActionHumanMovementComponent::GetMoveStateByAcceleration(const struct FVector& InAcceleration, const bool bIsCrouching, const bool bIsStrafing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetMoveStateByAcceleration");

	Params::ActionHumanMovementComponent_GetMoveStateByAcceleration Parms{};

	Parms.InAcceleration = std::move(InAcceleration);
	Parms.bIsCrouching = bIsCrouching;
	Parms.bIsStrafing = bIsStrafing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetNonZeroUnitInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActionHumanMovementComponent::GetNonZeroUnitInputVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetNonZeroUnitInputVector");

	Params::ActionHumanMovementComponent_GetNonZeroUnitInputVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetTargetSpeedByMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EPlayerMoveState                  InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsCrouching                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsStrafing                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanMovementComponent::GetTargetSpeedByMoveState(const EPlayerMoveState InState, const bool bIsCrouching, const bool bIsStrafing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetTargetSpeedByMoveState");

	Params::ActionHumanMovementComponent_GetTargetSpeedByMoveState Parms{};

	Parms.InState = InState;
	Parms.bIsCrouching = bIsCrouching;
	Parms.bIsStrafing = bIsStrafing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionHumanMovementComponent.GetTargetSpeedRateByMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EPlayerMoveState                  InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsCrouching                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsStrafing                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionHumanMovementComponent::GetTargetSpeedRateByMoveState(const EPlayerMoveState InState, const bool bIsCrouching, const bool bIsStrafing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanMovementComponent", "GetTargetSpeedRateByMoveState");

	Params::ActionHumanMovementComponent_GetTargetSpeedRateByMoveState Parms{};

	Parms.InState = InState;
	Parms.bIsCrouching = bIsCrouching;
	Parms.bIsStrafing = bIsStrafing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimParameterInterface.GetCharacterAnimParameter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterAnimParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterAnimParameter IAnimParameterInterface::GetCharacterAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AnimParameterInterface", "GetCharacterAnimParameter");

	Params::AnimParameterInterface_GetCharacterAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_HotSpring.OnHotSpringEnded
// (Final, Native, Private)

void UQSTask_HotSpring::OnHotSpringEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpring", "OnHotSpringEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpring.OnHotSpringMenuClosed
// (Native, Public)

void UQSTask_HotSpring::OnHotSpringMenuClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpring", "OnHotSpringMenuClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionHumanPlayerController.ResetControlRotationToDefault
// (Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bOnlyLocallyControlled                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionHumanPlayerController::ResetControlRotationToDefault(const bool bOnlyLocallyControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionHumanPlayerController", "ResetControlRotationToDefault");

	Params::ActionHumanPlayerController_ResetControlRotationToDefault Parms{};

	Parms.bOnlyLocallyControlled = bOnlyLocallyControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.KeepOutBase.OnRep_ActiveState
// (Final, Native, Public)

void AKeepOutBase::OnRep_ActiveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutBase", "OnRep_ActiveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.KeepOutBase.SetDisplayWallTemporary
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInDisplay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutBase::SetDisplayWallTemporary(bool bInDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutBase", "SetDisplayWallTemporary");

	Params::KeepOutBase_SetDisplayWallTemporary Parms{};

	Parms.bInDisplay = bInDisplay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutBase.UpdateBlueprint
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInPlacementActive                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInitializedPlacementActive                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutBase::UpdateBlueprint(bool bInPlacementActive, bool bInInitializedPlacementActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutBase", "UpdateBlueprint");

	Params::KeepOutBase_UpdateBlueprint Parms{};

	Parms.bInPlacementActive = bInPlacementActive;
	Parms.bInInitializedPlacementActive = bInInitializedPlacementActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutCylinder.OnEndForceMove_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutCylinder::OnEndForceMove_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutCylinder", "OnEndForceMove_BP");

	Params::KeepOutCylinder_OnEndForceMove_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutCylinder.OnForceMoving_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutCylinder::OnForceMoving_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutCylinder", "OnForceMoving_BP");

	Params::KeepOutCylinder_OnForceMoving_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutCylinder.OnStartForceMove_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutCylinder::OnStartForceMove_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutCylinder", "OnStartForceMove_BP");

	Params::KeepOutCylinder_OnStartForceMove_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.AnimInstanceInterface.SetWeaponGearSpeedScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInstanceInterface::SetWeaponGearSpeedScale(float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AnimInstanceInterface", "SetWeaponGearSpeedScale");

	Params::AnimInstanceInterface_SetWeaponGearSpeedScale Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AnimInstanceInterface.GetWeaponGearSpeedScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IAnimInstanceInterface::GetWeaponGearSpeedScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AnimInstanceInterface", "GetWeaponGearSpeedScale");

	Params::AnimInstanceInterface_GetWeaponGearSpeedScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ANS_AttackCollision.GetTransform_BP
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UANS_AttackCollision::GetTransform_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_AttackCollision", "GetTransform_BP");

	Params::ANS_AttackCollision_GetTransform_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ANS_AttackCollision.SetAttachSocketName_BP
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const class FName&                      InAttachSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_AttackCollision::SetAttachSocketName_BP(const class FName& InAttachSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_AttackCollision", "SetAttachSocketName_BP");

	Params::ANS_AttackCollision_SetAttachSocketName_BP Parms{};

	Parms.InAttachSocketName = InAttachSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ANS_AttackCollision.SetTransform_BP
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FTransform&                InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_AttackCollision::SetTransform_BP(const struct FTransform& InTransform) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_AttackCollision", "SetTransform_BP");

	Params::ANS_AttackCollision_SetTransform_BP Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionInputTrgGuideBase.BindOnUpdateKeyAssignEventDelegate
// (Final, Native, Protected, BlueprintCallable)

void UActionInputTrgGuideBase::BindOnUpdateKeyAssignEventDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionInputTrgGuideBase", "BindOnUpdateKeyAssignEventDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionInputTrgGuideBase.OnUpdateKeyAssign
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UActionInputTrgGuideBase::OnUpdateKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionInputTrgGuideBase", "OnUpdateKeyAssign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.GameMessageUIObject.HideGameMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::HideGameMessage(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "HideGameMessage");

	Params::GameMessageUIObject_HideGameMessage Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.RemoveGameMessageQueueByCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMessageCategory                    InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::RemoveGameMessageQueueByCategory(class UObject* InWorldContext, EGameMessageCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "RemoveGameMessageQueueByCategory");

	Params::GameMessageUIObject_RemoveGameMessageQueueByCategory Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.ShowBloodCodeConfirmDialogBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FArticleBulkInfo&          InArticleBulkInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(uint8 DecideOptionNumber)>InDecideDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::ShowBloodCodeConfirmDialogBP(class UObject* InWorldContext, const struct FArticleBulkInfo& InArticleBulkInfo, TDelegate<void(uint8 DecideOptionNumber)> InDecideDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "ShowBloodCodeConfirmDialogBP");

	Params::GameMessageUIObject_ShowBloodCodeConfirmDialogBP Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InArticleBulkInfo = std::move(InArticleBulkInfo);
	Parms.InDecideDelegate = InDecideDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.ShowBuddyConfirmDialog
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InBuddyTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(uint8 DecideOptionNumber)>InDecideDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::ShowBuddyConfirmDialog(class UObject* InWorldContext, const struct FGameplayTag& InBuddyTag, TDelegate<void(uint8 DecideOptionNumber)> InDecideDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "ShowBuddyConfirmDialog");

	Params::GameMessageUIObject_ShowBuddyConfirmDialog Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InDecideDelegate = InDecideDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.ShowEnemyDefeatMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnemyDefeatAppearanceType              InAppearanceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InClosedDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::ShowEnemyDefeatMessage(class UObject* InWorldContext, EEnemyDefeatAppearanceType InAppearanceType, const class FText& InMessage, TDelegate<void()> InClosedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "ShowEnemyDefeatMessage");

	Params::GameMessageUIObject_ShowEnemyDefeatMessage Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InAppearanceType = InAppearanceType;
	Parms.InMessage = std::move(InMessage);
	Parms.InClosedDelegate = InClosedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.ShowGameMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMessageCategory                    InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::ShowGameMessage(class UObject* InWorldContext, const class FText& InTitle, const class FText& InMessage, float InDuration, EGameMessageCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMessageUIObject", "ShowGameMessage");

	Params::GameMessageUIObject_ShowGameMessage Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTitle = std::move(InTitle);
	Parms.InMessage = std::move(InMessage);
	Parms.InDuration = InDuration;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameMessageUIObject.HideGameMessageBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMessageUIObject::HideGameMessageBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMessageUIObject", "HideGameMessageBP");

	Params::GameMessageUIObject_HideGameMessageBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GameMessageUIObject.OnOpenedBuddyDialog
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class UDialogBase*                InBuddyDialog                                          (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMessageUIObject::OnOpenedBuddyDialog(const class UDialogBase* InBuddyDialog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMessageUIObject", "OnOpenedBuddyDialog");

	Params::GameMessageUIObject_OnOpenedBuddyDialog Parms{};

	Parms.InBuddyDialog = InBuddyDialog;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.GameMessageUIObject.RemoveGameMessageQueueByCategoryBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// EGameMessageCategory                    InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMessageUIObject::RemoveGameMessageQueueByCategoryBP(EGameMessageCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMessageUIObject", "RemoveGameMessageQueueByCategoryBP");

	Params::GameMessageUIObject_RemoveGameMessageQueueByCategoryBP Parms{};

	Parms.InCategory = InCategory;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GameMessageUIObject.ShowBloodCodeProficiencyMessageBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FBloodCodeDialogInfo&      InDialogInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMessageUIObject::ShowBloodCodeProficiencyMessageBP(const struct FBloodCodeDialogInfo& InDialogInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMessageUIObject", "ShowBloodCodeProficiencyMessageBP");

	Params::GameMessageUIObject_ShowBloodCodeProficiencyMessageBP Parms{};

	Parms.InDialogInfo = std::move(InDialogInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GameMessageUIObject.ShowGameMessageBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMessageCategory                    InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMessageUIObject::ShowGameMessageBP(const class FText& InTitle, const class FText& InMessage, float InDuration, EGameMessageCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMessageUIObject", "ShowGameMessageBP");

	Params::GameMessageUIObject_ShowGameMessageBP Parms{};

	Parms.InTitle = std::move(InTitle);
	Parms.InMessage = std::move(InMessage);
	Parms.InDuration = InDuration;
	Parms.InCategory = InCategory;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.OnCompletedTurn
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionNPCAnimInstance::OnCompletedTurn(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "OnCompletedTurn");

	Params::ActionNPCAnimInstance_OnCompletedTurn Parms{};

	Parms.Context = std::move(Context);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCAnimInstance.SetCanTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionNPCAnimInstance::SetCanTurn(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "SetCanTurn");

	Params::ActionNPCAnimInstance_SetCanTurn Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCAnimInstance.GetAimPitch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionNPCAnimInstance::GetAimPitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetAimPitch");

	Params::ActionNPCAnimInstance_GetAimPitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetAimWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionNPCAnimInstance::GetAimWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetAimWeight");

	Params::ActionNPCAnimInstance_GetAimWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetAimYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionNPCAnimInstance::GetAimYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetAimYaw");

	Params::ActionNPCAnimInstance_GetAimYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetCanTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionNPCAnimInstance::GetCanTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetCanTurn");

	Params::ActionNPCAnimInstance_GetCanTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetIdleAnimation
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UActionNPCAnimInstance::GetIdleAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetIdleAnimation");

	Params::ActionNPCAnimInstance_GetIdleAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetIsTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionNPCAnimInstance::GetIsTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetIsTurn");

	Params::ActionNPCAnimInstance_GetIsTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetTurnAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionNPCAnimInstance::GetTurnAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetTurnAngle");

	Params::ActionNPCAnimInstance_GetTurnAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCAnimInstance.GetTurnPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionNPCAnimInstance::GetTurnPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCAnimInstance", "GetTurnPlayRate");

	Params::ActionNPCAnimInstance_GetTurnPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.BP_StartRidingMountEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AAppWheeledVehiclePawn*           Vehicle                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionNPCCharacter::BP_StartRidingMountEffect(class AAppWheeledVehiclePawn* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "BP_StartRidingMountEffect");

	Params::ActionNPCCharacter_BP_StartRidingMountEffect Parms{};

	Parms.Vehicle = Vehicle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ActionNPCCharacter.DisableCollision
// (Final, Native, Public, BlueprintCallable)

void AActionNPCCharacter::DisableCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "DisableCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.EnableCollision
// (Final, Native, Public, BlueprintCallable)

void AActionNPCCharacter::EnableCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "EnableCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.GetShadowMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USkeletalMeshComponent*>*  OutShadowMeshes                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActionNPCCharacter::GetShadowMeshes(TArray<class USkeletalMeshComponent*>* OutShadowMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetShadowMeshes");

	Params::ActionNPCCharacter_GetShadowMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShadowMeshes != nullptr)
		*OutShadowMeshes = std::move(Parms.OutShadowMeshes);
}


// Function Extensions.ActionNPCCharacter.GettingOffMount
// (Final, Native, Protected, HasDefaults)
// Parameters:
// const struct FTransform&                LandTransform                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionNPCCharacter::GettingOffMount(const struct FTransform& LandTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GettingOffMount");

	Params::ActionNPCCharacter_GettingOffMount Parms{};

	Parms.LandTransform = std::move(LandTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.HideMesh
// (Final, Native, Protected, BlueprintCallable)

void AActionNPCCharacter::HideMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "HideMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.RequestRidingMount
// (Final, Native, Public, BlueprintCallable)

void AActionNPCCharacter::RequestRidingMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "RequestRidingMount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.RideMount
// (Final, Native, Protected)
// Parameters:
// class AAppWheeledVehiclePawn*           Vehicle                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionNPCCharacter::RideMount(class AAppWheeledVehiclePawn* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "RideMount");

	Params::ActionNPCCharacter_RideMount Parms{};

	Parms.Vehicle = Vehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.ShowMaterialSection
// (Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaterialID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPreviewMesh                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionNPCCharacter::ShowMaterialSection(class USkeletalMeshComponent* TargetMesh, int32 MaterialID, int32 SectionIndex, bool bShow, bool bIsPreviewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "ShowMaterialSection");

	Params::ActionNPCCharacter_ShowMaterialSection Parms{};

	Parms.TargetMesh = TargetMesh;
	Parms.MaterialID = MaterialID;
	Parms.SectionIndex = SectionIndex;
	Parms.bShow = bShow;
	Parms.bIsPreviewMesh = bIsPreviewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.ShowMesh
// (Final, Native, Protected, BlueprintCallable)

void AActionNPCCharacter::ShowMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "ShowMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.ShowMeshEffect
// (Final, Native, Protected, BlueprintCallable)

void AActionNPCCharacter::ShowMeshEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "ShowMeshEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.StartGettingOffMount
// (Final, Native, Public, BlueprintCallable)

void AActionNPCCharacter::StartGettingOffMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "StartGettingOffMount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionNPCCharacter.TurnToFace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionNPCCharacter::TurnToFace(class AActor* Target, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "TurnToFace");

	Params::ActionNPCCharacter_TurnToFace Parms{};

	Parms.Target = Target;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetDistanceFromPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionNPCCharacter::GetDistanceFromPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetDistanceFromPlayer");

	Params::ActionNPCCharacter_GetDistanceFromPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetDownCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActionNPCCharacter::GetDownCooltime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetDownCooltime");

	Params::ActionNPCCharacter_GetDownCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetMountAnimationType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBuddyMountAnimationType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuddyMountAnimationType AActionNPCCharacter::GetMountAnimationType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetMountAnimationType");

	Params::ActionNPCCharacter_GetMountAnimationType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetOverrideFocusedAtLocation
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionNPCCharacter::GetOverrideFocusedAtLocation(struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetOverrideFocusedAtLocation");

	Params::ActionNPCCharacter_GetOverrideFocusedAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetOverrideLookedAtLocation
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionNPCCharacter::GetOverrideLookedAtLocation(struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetOverrideLookedAtLocation");

	Params::ActionNPCCharacter_GetOverrideLookedAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.GetScenarioNPCComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioNPCComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioNPCComponent* AActionNPCCharacter::GetScenarioNPCComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "GetScenarioNPCComponent");

	Params::ActionNPCCharacter_GetScenarioNPCComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionNPCCharacter.IsOverrideMountAnimationType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActionNPCCharacter::IsOverrideMountAnimationType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionNPCCharacter", "IsOverrideMountAnimationType");

	Params::ActionNPCCharacter_IsOverrideMountAnimationType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.OnBeginCutScene
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALightController::OnBeginCutScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "OnBeginCutScene");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.LightController.OnEndCutScene
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALightController::OnEndCutScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "OnEndCutScene");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.LightController.SetMoonLightCastShadow
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCastShadow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetMoonLightCastShadow(bool bCastShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetMoonLightCastShadow");

	Params::LightController_SetMoonLightCastShadow Parms{};

	Parms.bCastShadow = bCastShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.SetMoonLightParameter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FLightParameter&           Value                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALightController::SetMoonLightParameter(const struct FLightParameter& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetMoonLightParameter");

	Params::LightController_SetMoonLightParameter Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.SetStopTracingTransmittanceThreshold
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetStopTracingTransmittanceThreshold(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetStopTracingTransmittanceThreshold");

	Params::LightController_SetStopTracingTransmittanceThreshold Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.SetSunDayAngleUpdateThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InUpdateThreshold                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetSunDayAngleUpdateThreshold(float InUpdateThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetSunDayAngleUpdateThreshold");

	Params::LightController_SetSunDayAngleUpdateThreshold Parms{};

	Parms.InUpdateThreshold = InUpdateThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LightController.SetSunLightCastShadow
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCastShadow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetSunLightCastShadow(bool bCastShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetSunLightCastShadow");

	Params::LightController_SetSunLightCastShadow Parms{};

	Parms.bCastShadow = bCastShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.SetSunLightParameter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FLightParameter&           Value                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALightController::SetSunLightParameter(const struct FLightParameter& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetSunLightParameter");

	Params::LightController_SetSunLightParameter Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.SetTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetTime");

	Params::LightController_SetTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LightController.SetWeatherParameterByTag
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InWeatherTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightController::SetWeatherParameterByTag(const struct FGameplayTag& InWeatherTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "SetWeatherParameterByTag");

	Params::LightController_SetWeatherParameterByTag Parms{};

	Parms.InWeatherTag = std::move(InWeatherTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LightController.UpdateFieldControllVolumeValues
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALightController::UpdateFieldControllVolumeValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "UpdateFieldControllVolumeValues");

	Params::LightController_UpdateFieldControllVolumeValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetExponentialHeightFogComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UExponentialHeightFogComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UExponentialHeightFogComponent* ALightController::GetExponentialHeightFogComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetExponentialHeightFogComponent");

	Params::LightController_GetExponentialHeightFogComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetMoonLightParameterAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightParameter                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLightParameter ALightController::GetMoonLightParameterAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetMoonLightParameterAction");

	Params::LightController_GetMoonLightParameterAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetMoonLightParameterGraphics
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightParameter                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLightParameter ALightController::GetMoonLightParameterGraphics() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetMoonLightParameterGraphics");

	Params::LightController_GetMoonLightParameterGraphics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetRainEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* ALightController::GetRainEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetRainEffect");

	Params::LightController_GetRainEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetSnowEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* ALightController::GetSnowEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetSnowEffect");

	Params::LightController_GetSnowEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetStopTracingTransmittanceThresholdAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALightController::GetStopTracingTransmittanceThresholdAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetStopTracingTransmittanceThresholdAction");

	Params::LightController_GetStopTracingTransmittanceThresholdAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetStopTracingTransmittanceThresholdGraphics
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALightController::GetStopTracingTransmittanceThresholdGraphics() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetStopTracingTransmittanceThresholdGraphics");

	Params::LightController_GetStopTracingTransmittanceThresholdGraphics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetSunDayAngleUpdateThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALightController::GetSunDayAngleUpdateThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetSunDayAngleUpdateThreshold");

	Params::LightController_GetSunDayAngleUpdateThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetSunLightParameterAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightParameter                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLightParameter ALightController::GetSunLightParameterAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetSunLightParameterAction");

	Params::LightController_GetSunLightParameterAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetSunLightParameterGraphics
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightParameter                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLightParameter ALightController::GetSunLightParameterGraphics() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetSunLightParameterGraphics");

	Params::LightController_GetSunLightParameterGraphics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LightController.GetTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALightController::GetTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightController", "GetTime");

	Params::LightController_GetTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LadderClimberComponent.ClientClimbTheLadderFromBottom
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ALadder*                          InLadder                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimberComponent::ClientClimbTheLadderFromBottom(class ALadder* InLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "ClientClimbTheLadderFromBottom");

	Params::LadderClimberComponent_ClientClimbTheLadderFromBottom Parms{};

	Parms.InLadder = InLadder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LadderClimberComponent.ClientClimbTheLadderFromTop
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ALadder*                          InLadder                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimberComponent::ClientClimbTheLadderFromTop(class ALadder* InLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "ClientClimbTheLadderFromTop");

	Params::LadderClimberComponent_ClientClimbTheLadderFromTop Parms{};

	Parms.InLadder = InLadder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LadderClimberComponent.OnClimbMoveBegun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InClimbLedgeNum                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInOnTheLadder                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimberComponent::OnClimbMoveBegun(const int32 InClimbLedgeNum, const bool bInOnTheLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "OnClimbMoveBegun");

	Params::LadderClimberComponent_OnClimbMoveBegun Parms{};

	Parms.InClimbLedgeNum = InClimbLedgeNum;
	Parms.bInOnTheLadder = bInOnTheLadder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LadderClimberComponent.OnRep_ReplicatedLadderImOn
// (Native, Protected)

void ULadderClimberComponent::OnRep_ReplicatedLadderImOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "OnRep_ReplicatedLadderImOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LadderClimberComponent.SetIntermediateLeaveAllowed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bInAllow                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimberComponent::SetIntermediateLeaveAllowed(const bool bInAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "SetIntermediateLeaveAllowed");

	Params::LadderClimberComponent_SetIntermediateLeaveAllowed Parms{};

	Parms.bInAllow = bInAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LadderClimberComponent.GetLadderImOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALadder*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALadder* ULadderClimberComponent::GetLadderImOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimberComponent", "GetLadderImOn");

	Params::LadderClimberComponent_GetLadderImOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AudioVoiceDebugMenu.OnVoicePlay
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FOnAppAudioVoicePlayParam& Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioVoiceDebugMenu::OnVoicePlay(const struct FOnAppAudioVoicePlayParam& Param, bool bPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioVoiceDebugMenu", "OnVoicePlay");

	Params::AudioVoiceDebugMenu_OnVoicePlay Parms{};

	Parms.Param = std::move(Param);
	Parms.bPlay = bPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_Health
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_Health(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_Health");

	Params::ActionStatusAttributeSet_OnRep_Health Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_Ichor
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_Ichor(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_Ichor");

	Params::ActionStatusAttributeSet_OnRep_Ichor Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_MaxHealth
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_MaxHealth");

	Params::ActionStatusAttributeSet_OnRep_MaxHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_MaxIchor
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_MaxIchor(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_MaxIchor");

	Params::ActionStatusAttributeSet_OnRep_MaxIchor Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_MaxStamina
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_MaxStamina(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_MaxStamina");

	Params::ActionStatusAttributeSet_OnRep_MaxStamina Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_MaxSummonPoint
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_MaxSummonPoint(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_MaxSummonPoint");

	Params::ActionStatusAttributeSet_OnRep_MaxSummonPoint Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_Stamina
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_Stamina(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_Stamina");

	Params::ActionStatusAttributeSet_OnRep_Stamina Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionStatusAttributeSet.OnRep_SummonPoint
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusAttributeSet::OnRep_SummonPoint(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusAttributeSet", "OnRep_SummonPoint");

	Params::ActionStatusAttributeSet_OnRep_SummonPoint Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.AutoSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFromYadorigi                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::AutoSave(bool bFromYadorigi)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "AutoSave");

	Params::SaveDataManager_AutoSave Parms{};

	Parms.bFromYadorigi = bFromYadorigi;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.AutoSaveAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFromYadorigi                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::AutoSaveAsync(bool bFromYadorigi)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "AutoSaveAsync");

	Params::SaveDataManager_AutoSaveAsync Parms{};

	Parms.bFromYadorigi = bFromYadorigi;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.ClearLoadedData
// (Final, Native, Public, BlueprintCallable)

void USaveDataManager::ClearLoadedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "ClearLoadedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.ClearVolatileData
// (Final, Native, Public, BlueprintCallable)

void USaveDataManager::ClearVolatileData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "ClearVolatileData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.DoesSaveGameExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::DoesSaveGameExist(const class FString& InSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "DoesSaveGameExist");

	Params::SaveDataManager_DoesSaveGameExist Parms{};

	Parms.InSlotName = std::move(InSlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.DoesSystemSaveGameExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::DoesSystemSaveGameExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "DoesSystemSaveGameExist");

	Params::SaveDataManager_DoesSystemSaveGameExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.GetSaveGameNames
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>*                  OutFoundSaves                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::GetSaveGameNames(TArray<class FString>* OutFoundSaves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "GetSaveGameNames");

	Params::SaveDataManager_GetSaveGameNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFoundSaves != nullptr)
		*OutFoundSaves = std::move(Parms.OutFoundSaves);

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.Load
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::Load(const class FString& InSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "Load");

	Params::SaveDataManager_Load Parms{};

	Parms.InSlotName = std::move(InSlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.LoadSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::LoadSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "LoadSystem");

	Params::SaveDataManager_LoadSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.OnPostAutoSaveSync
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InResult                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataManager::OnPostAutoSaveSync(const class FString& InSlotName, bool InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "OnPostAutoSaveSync");

	Params::SaveDataManager_OnPostAutoSaveSync Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InResult = InResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.OnPostAutoSaveSyncInternal
// (Final, Native, Private)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InResult                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataManager::OnPostAutoSaveSyncInternal(const class FString& InSlotName, bool InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "OnPostAutoSaveSyncInternal");

	Params::SaveDataManager_OnPostAutoSaveSyncInternal Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InResult = InResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.Save
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::Save(const class FString& InSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "Save");

	Params::SaveDataManager_Save Parms{};

	Parms.InSlotName = std::move(InSlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.SaveAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& InSlotName, bool InResult)>InOnAsyncSaved                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataManager::SaveAsync(const class FString& InSlotName, TDelegate<void(const class FString& InSlotName, bool InResult)> InOnAsyncSaved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "SaveAsync");

	Params::SaveDataManager_SaveAsync Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InOnAsyncSaved = InOnAsyncSaved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.SaveSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::SaveSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "SaveSystem");

	Params::SaveDataManager_SaveSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataManager.SaveSystemAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& InSlotName, bool InResult)>InOnAsyncSaved                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataManager::SaveSystemAsync(TDelegate<void(const class FString& InSlotName, bool InResult)> InOnAsyncSaved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "SaveSystemAsync");

	Params::SaveDataManager_SaveSystemAsync Parms{};

	Parms.InOnAsyncSaved = InOnAsyncSaved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataManager.SaveSystemConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataManager::SaveSystemConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataManager", "SaveSystemConfig");

	Params::SaveDataManager_SaveSystemConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionStatusComponent.ClientExecuteBloodFeedEffect
// (Net, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// class AActor*                           InFromActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InEffectLocation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class APawn*>&             InToActors                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UActionStatusComponent::ClientExecuteBloodFeedEffect(class AActor* InFromActor, const struct FVector& InEffectLocation, const TArray<class APawn*>& InToActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStatusComponent", "ClientExecuteBloodFeedEffect");

	Params::ActionStatusComponent_ClientExecuteBloodFeedEffect Parms{};

	Parms.InFromActor = InFromActor;
	Parms.InEffectLocation = std::move(InEffectLocation);
	Parms.InToActors = std::move(InToActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DevelopmentMapDebugMenu.IsBlindfoldWall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDevelopmentMapDebugMenu::IsBlindfoldWall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentMapDebugMenu", "IsBlindfoldWall");

	Params::DevelopmentMapDebugMenu_IsBlindfoldWall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AttackCollisionIF.OnGetDamageParameter
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName                       InAttackID                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageParameter*                OutDamageParameter                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void IAttackCollisionIF::OnGetDamageParameter(const class FName InAttackID, struct FDamageParameter* OutDamageParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AttackCollisionIF", "OnGetDamageParameter");

	Params::AttackCollisionIF_OnGetDamageParameter Parms{};

	Parms.InAttackID = InAttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDamageParameter != nullptr)
		*OutDamageParameter = std::move(Parms.OutDamageParameter);
}


// Function Extensions.AttackCollisionIF.OnGetNoiseVolumeType
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class FName                       InAttackID                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoiseVolumeType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoiseVolumeType IAttackCollisionIF::OnGetNoiseVolumeType(const class FName InAttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AttackCollisionIF", "OnGetNoiseVolumeType");

	Params::AttackCollisionIF_OnGetNoiseVolumeType Parms{};

	Parms.InAttackID = InAttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AttackCollisionIF.OnIsObjectDestructOnly
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class FName                       InAttackID                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAttackCollisionIF::OnIsObjectDestructOnly(const class FName InAttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AttackCollisionIF", "OnIsObjectDestructOnly");

	Params::AttackCollisionIF_OnIsObjectDestructOnly Parms{};

	Parms.InAttackID = InAttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AttackCollisionIF.OnAttackCollisionHitFilter
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FAttackCollisionRequestInfo&InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAttackCollisionHandle&    InHandle                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     InHitActor                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAttackCollisionIF::OnAttackCollisionHitFilter(const struct FAttackCollisionRequestInfo& InInfo, const struct FAttackCollisionHandle& InHandle, const class AActor* InHitActor, const struct FHitResult& InHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AttackCollisionIF", "OnAttackCollisionHitFilter");

	Params::AttackCollisionIF_OnAttackCollisionHitFilter Parms{};

	Parms.InInfo = std::move(InInfo);
	Parms.InHandle = std::move(InHandle);
	Parms.InHitActor = InHitActor;
	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodAmountGaugeInterface.NotifyBleedingAttackSucceeded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBloodAmountGaugeInterface::NotifyBleedingAttackSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BloodAmountGaugeInterface", "NotifyBleedingAttackSucceeded");

	Params::BloodAmountGaugeInterface_NotifyBleedingAttackSucceeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodAmountGaugeInterface.SetBloodAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InBloodAmount                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBloodAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InFactor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBloodAmountGaugeInterface::SetBloodAmount(const float InBloodAmount, const float InMaxBloodAmount, const EResourceChangeFactor InFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BloodAmountGaugeInterface", "SetBloodAmount");

	Params::BloodAmountGaugeInterface_SetBloodAmount Parms{};

	Parms.InBloodAmount = InBloodAmount;
	Parms.InMaxBloodAmount = InMaxBloodAmount;
	Parms.InFactor = InFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodAmountGaugeInterface.UpdateVisibleBloodAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InbVisible                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBloodAmountGaugeInterface::UpdateVisibleBloodAmount(const bool InbVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BloodAmountGaugeInterface", "UpdateVisibleBloodAmount");

	Params::BloodAmountGaugeInterface_UpdateVisibleBloodAmount Parms{};

	Parms.InbVisible = InbVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PickupableActor.UpdateHiddenByGameFlag_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bShouldHide                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickupableActor::UpdateHiddenByGameFlag_BP(const bool bShouldHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupableActor", "UpdateHiddenByGameFlag_BP");

	Params::PickupableActor_UpdateHiddenByGameFlag_BP Parms{};

	Parms.bShouldHide = bShouldHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LostExp.OnPickedUp_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bInSucceeded                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALostExp::OnPickedUp_BP(const bool bInSucceeded, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LostExp", "OnPickedUp_BP");

	Params::LostExp_OnPickedUp_BP Parms{};

	Parms.bInSucceeded = bInSucceeded;
	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LostExp.OnUpdateLocation
// (Event, Public, BlueprintEvent)

void ALostExp::OnUpdateLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LostExp", "OnUpdateLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ActorFunctionLibrary.K2_ClearAllTimersForObjects
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class UObject*                    Object                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorFunctionLibrary::K2_ClearAllTimersForObjects(const class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorFunctionLibrary", "K2_ClearAllTimersForObjects");

	Params::ActorFunctionLibrary_K2_ClearAllTimersForObjects Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddySelectSystem.OnChangeRegion
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTagContainer&     InPreFieldRegion                                       (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InCurrentFieldRegion                                   (Parm, NativeAccessSpecifierPublic)

void UBuddySelectSystem::OnChangeRegion(const struct FGameplayTagContainer& InPreFieldRegion, const struct FGameplayTagContainer& InCurrentFieldRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "OnChangeRegion");

	Params::BuddySelectSystem_OnChangeRegion Parms{};

	Parms.InPreFieldRegion = std::move(InPreFieldRegion);
	Parms.InCurrentFieldRegion = std::move(InCurrentFieldRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddySelectSystem.OnChangeStoryFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     Param                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBuddySelectSystem::OnChangeStoryFlag(const struct FStoryFlagChangeParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "OnChangeStoryFlag");

	Params::BuddySelectSystem_OnChangeStoryFlag Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddySelectSystem.OnChangeTimeSeries
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddySelectSystem::OnChangeTimeSeries(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "OnChangeTimeSeries");

	Params::BuddySelectSystem_OnChangeTimeSeries Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddySelectSystem.OnGameStateSetEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   GameStateBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddySelectSystem::OnGameStateSetEvent(class AGameStateBase* GameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "OnGameStateSetEvent");

	Params::BuddySelectSystem_OnGameStateSetEvent Parms{};

	Parms.GameStateBase = GameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddySelectSystem.UI_ChangeBuddy
// (Final, Native, Protected)
// Parameters:
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddySelectSystem::UI_ChangeBuddy(const int32 InListIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "UI_ChangeBuddy");

	Params::BuddySelectSystem_UI_ChangeBuddy Parms{};

	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddySelectSystem.UI_GetBuddyInfo
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBuddyInfo*                    OutUIBuddyInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UBuddySelectSystem::UI_GetBuddyInfo(const int32 InListIndex, struct FUIBuddyInfo* OutUIBuddyInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "UI_GetBuddyInfo");

	Params::BuddySelectSystem_UI_GetBuddyInfo Parms{};

	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUIBuddyInfo != nullptr)
		*OutUIBuddyInfo = std::move(Parms.OutUIBuddyInfo);
}


// Function Extensions.BuddySelectSystem.UI_GetBuddyNumber
// (Final, Native, Protected)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBuddySelectSystem::UI_GetBuddyNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "UI_GetBuddyNumber");

	Params::BuddySelectSystem_UI_GetBuddyNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddySelectSystem.UI_GetCurrentBuddyIndex
// (Final, Native, Protected)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBuddySelectSystem::UI_GetCurrentBuddyIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "UI_GetCurrentBuddyIndex");

	Params::BuddySelectSystem_UI_GetCurrentBuddyIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddySelectSystem.UI_IsSetForceBuddyType
// (Final, Native, Protected)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddySelectSystem::UI_IsSetForceBuddyType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddySelectSystem", "UI_IsSetForceBuddyType");

	Params::BuddySelectSystem_UI_IsSetForceBuddyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_SmallScenario.OnCloseFinish
// (Final, Native, Public)

void UQSTask_SmallScenario::OnCloseFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SmallScenario", "OnCloseFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SmallScenario.OnScreenMaskCompleted
// (Final, Native, Public)

void UQSTask_SmallScenario::OnScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SmallScenario", "OnScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_InvaderWave.OnComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_InvaderWave::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_InvaderWave", "OnComponentEndOverlap");

	Params::QSTask_InvaderWave_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_InvaderWave.OnDespawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_InvaderWave::OnDespawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_InvaderWave", "OnDespawn");

	Params::QSTask_InvaderWave_OnDespawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_InvaderWave.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// TWeakObjectPtr<class UPrimitiveComponent>InOverlappedComponent                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TWeakObjectPtr<class AActor>            InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_InvaderWave::OnEndOverlap(TWeakObjectPtr<class UPrimitiveComponent> InOverlappedComponent, TWeakObjectPtr<class AActor> InOtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_InvaderWave", "OnEndOverlap");

	Params::QSTask_InvaderWave_OnEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_InvaderWave.OnSpawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_InvaderWave::OnSpawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_InvaderWave", "OnSpawn");

	Params::QSTask_InvaderWave_OnSpawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ANS_DangerArea.CreateDangerAreaObject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Radius                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TimeToAttack                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             AttackDuration                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_DangerArea::CreateDangerAreaObject(const struct FVector& Location, const float Radius, const float TimeToAttack, const float AttackDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_DangerArea", "CreateDangerAreaObject");

	Params::ANS_DangerArea_CreateDangerAreaObject Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.TimeToAttack = TimeToAttack;
	Parms.AttackDuration = AttackDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.K2_CreateDataCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InContextObject                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAdventureTalkDataCollectionBase>InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAdventureTalkDataCollectionType        InDataCollectionType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAdventureTalkDataCollectionBase* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAdventureTalkDataCollectionBase* UAdventureTalkManager::K2_CreateDataCollection(class UObject* InContextObject, TSubclassOf<class UAdventureTalkDataCollectionBase> InClass, EAdventureTalkDataCollectionType InDataCollectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AdventureTalkManager", "K2_CreateDataCollection");

	Params::AdventureTalkManager_K2_CreateDataCollection Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InClass = InClass;
	Parms.InDataCollectionType = InDataCollectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AdventureTalkManager.K2_CreateMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InContextObject                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAdventureTalkMessage>InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAdventureTalkMessage*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAdventureTalkMessage* UAdventureTalkManager::K2_CreateMessage(class UObject* InContextObject, TSubclassOf<class UAdventureTalkMessage> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AdventureTalkManager", "K2_CreateMessage");

	Params::AdventureTalkManager_K2_CreateMessage Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AdventureTalkManager.NetMulticastAttachBuddyVoicePlayerToBuddy
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UAdventureTalkManager::NetMulticastAttachBuddyVoicePlayerToBuddy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "NetMulticastAttachBuddyVoicePlayerToBuddy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.NetMulticastAttachBuddyVoicePlayerToPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UAdventureTalkManager::NetMulticastAttachBuddyVoicePlayerToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "NetMulticastAttachBuddyVoicePlayerToPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.NetMulticastSendPlayBuddyVoiceEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FAdventureTalkVoiceContext&InContext                                              (Parm, NativeAccessSpecifierPublic)

void UAdventureTalkManager::NetMulticastSendPlayBuddyVoiceEvent(const struct FAdventureTalkVoiceContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "NetMulticastSendPlayBuddyVoiceEvent");

	Params::AdventureTalkManager_NetMulticastSendPlayBuddyVoiceEvent Parms{};

	Parms.InContext = std::move(InContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.NetMulticastSendStopBuddyVoiceEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UAdventureTalkManager::NetMulticastSendStopBuddyVoiceEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "NetMulticastSendStopBuddyVoiceEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.OnFastTravelCompleted
// (Final, Native, Private)
// Parameters:
// const bool                              bIsStreaming                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdventureTalkManager::OnFastTravelCompleted(const bool bIsStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "OnFastTravelCompleted");

	Params::AdventureTalkManager_OnFastTravelCompleted Parms{};

	Parms.bIsStreaming = bIsStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.OnPlayerRespawn
// (Final, Native, Private)

void UAdventureTalkManager::OnPlayerRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "OnPlayerRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.OnVoicePlay
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FAppAudioVoicePlayerDelegateInfo&InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAdventureTalkManager::OnVoicePlay(const struct FAppAudioVoicePlayerDelegateInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "OnVoicePlay");

	Params::AdventureTalkManager_OnVoicePlay Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.SendMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UAdventureTalkMessage*      InMessage                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAdventureTalkDataCollectionBase*InDataCollection                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdventureTalkManager::SendMessage(const class UAdventureTalkMessage* InMessage, const class UAdventureTalkDataCollectionBase* InDataCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "SendMessage");

	Params::AdventureTalkManager_SendMessage Parms{};

	Parms.InMessage = InMessage;
	Parms.InDataCollection = InDataCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkManager.ServerSendPlayBuddyVoiceEvent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FAdventureTalkVoiceContext&InContext                                              (Parm, NativeAccessSpecifierPublic)

void UAdventureTalkManager::ServerSendPlayBuddyVoiceEvent(const struct FAdventureTalkVoiceContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkManager", "ServerSendPlayBuddyVoiceEvent");

	Params::AdventureTalkManager_ServerSendPlayBuddyVoiceEvent Parms{};

	Parms.InContext = std::move(InContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractionMenuUIObject.GetInteractionUIInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInteractionUIInfo               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractionUIInfo UInteractionMenuUIObject::GetInteractionUIInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "GetInteractionUIInfo");

	Params::InteractionMenuUIObject_GetInteractionUIInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InteractionMenuUIObject.IsInteractionProhibited
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionMenuUIObject::IsInteractionProhibited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "IsInteractionProhibited");

	Params::InteractionMenuUIObject_IsInteractionProhibited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InteractionMenuUIObject.NotifyInteractionTriggered
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             InTriggerOption                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionMenuUIObject::NotifyInteractionTriggered(const int32 InTriggerOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "NotifyInteractionTriggered");

	Params::InteractionMenuUIObject_NotifyInteractionTriggered Parms{};

	Parms.InTriggerOption = InTriggerOption;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.InteractionMenuUIObject.SetInteractionUIInfo
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInteractionUIInfo&        InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionMenuUIObject::SetInteractionUIInfo(const struct FInteractionUIInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "SetInteractionUIInfo");

	Params::InteractionMenuUIObject_SetInteractionUIInfo Parms{};

	Parms.InInfo = std::move(InInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.InteractionMenuUIObject.SetTargetLocation
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   InTargetWorldLocation                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionMenuUIObject::SetTargetLocation(const struct FVector& InTargetWorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "SetTargetLocation");

	Params::InteractionMenuUIObject_SetTargetLocation Parms{};

	Parms.InTargetWorldLocation = std::move(InTargetWorldLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.InteractionMenuUIObject.TriggerInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InTriggerOption                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionMenuUIObject::TriggerInteraction(const int32 InTriggerOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionMenuUIObject", "TriggerInteraction");

	Params::InteractionMenuUIObject_TriggerInteraction Parms{};

	Parms.InTriggerOption = InTriggerOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AdventureTalkTriggerComponent.MonitorEnemyDistanceInSight
// (Final, Native, Private)
// Parameters:
// const struct FAdventureTalkLocationRule&InRule                                                 (Parm, NativeAccessSpecifierPublic)

void UAdventureTalkTriggerComponent::MonitorEnemyDistanceInSight(const struct FAdventureTalkLocationRule& InRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdventureTalkTriggerComponent", "MonitorEnemyDistanceInSight");

	Params::AdventureTalkTriggerComponent_MonitorEnemyDistanceInSight Parms{};

	Parms.InRule = std::move(InRule);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ObjectOpacityComponent.AddOpacityObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InObject                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectOpacityComponent::AddOpacityObject(class UMeshComponent* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "AddOpacityObject");

	Params::ObjectOpacityComponent_AddOpacityObject Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ObjectOpacityComponent.FindOpacityMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UObjectOpacityComponent::FindOpacityMaterial(class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "FindOpacityMaterial");

	Params::ObjectOpacityComponent_FindOpacityMaterial Parms{};

	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ObjectOpacityComponent.GetOpacityObjectArray
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UMeshComponent*>*          InResult                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectOpacityComponent::GetOpacityObjectArray(TArray<class UMeshComponent*>* InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "GetOpacityObjectArray");

	Params::ObjectOpacityComponent_GetOpacityObjectArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InResult != nullptr)
		*InResult = std::move(Parms.InResult);
}


// Function Extensions.ObjectOpacityComponent.RemoveOpacityObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InObject                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectOpacityComponent::RemoveOpacityObject(class UMeshComponent* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "RemoveOpacityObject");

	Params::ObjectOpacityComponent_RemoveOpacityObject Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ObjectOpacityComponent.RemoveOpacityObjectAll
// (Final, Native, Public, BlueprintCallable)

void UObjectOpacityComponent::RemoveOpacityObjectAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "RemoveOpacityObjectAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ObjectOpacityComponent.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InObject                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectOpacityComponent::SetOpacity(class UMeshComponent* InObject, float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "SetOpacity");

	Params::ObjectOpacityComponent_SetOpacity Parms{};

	Parms.InObject = InObject;
	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ObjectOpacityComponent.SetOpacityAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectOpacityComponent::SetOpacityAll(float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "SetOpacityAll");

	Params::ObjectOpacityComponent_SetOpacityAll Parms{};

	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ObjectOpacityComponent.SetVisibilityAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectOpacityComponent::SetVisibilityAll(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectOpacityComponent", "SetVisibilityAll");

	Params::ObjectOpacityComponent_SetVisibilityAll Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicCharacter.FreezePose
// (Final, Native, Public, BlueprintCallable)

void ACinematicCharacter::FreezePose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicCharacter", "FreezePose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicCharacter.OnCutSceneMessageSkip
// (Native, Public)

void ACinematicCharacter::OnCutSceneMessageSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicCharacter", "OnCutSceneMessageSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicCharacter.ResetDynamics
// (Final, Native, Public, BlueprintCallable)

void ACinematicCharacter::ResetDynamics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicCharacter", "ResetDynamics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicCharacter.GetWeaponMesh
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bLeftHand                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACinematicCharacter::GetWeaponMesh(bool bLeftHand) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicCharacter", "GetWeaponMesh");

	Params::CinematicCharacter_GetWeaponMesh Parms{};

	Parms.bLeftHand = bLeftHand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AttributeSet_Test.OnRep_Test
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    InOldData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAttributeSet_Test::OnRep_Test(const struct FGameplayAttributeData& InOldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSet_Test", "OnRep_Test");

	Params::AttributeSet_Test_OnRep_Test Parms{};

	Parms.InOldData = std::move(InOldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionAbility.GetEmotionMontage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimMontage* UEmotionAbility::GetEmotionMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionAbility", "GetEmotionMontage");

	Params::EmotionAbility_GetEmotionMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionAbility.RequestMontageSection
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class UAnimMontage*               InAnimMontage                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStartSection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionAbility::RequestMontageSection(const class UAnimMontage* InAnimMontage, class FName InStartSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionAbility", "RequestMontageSection");

	Params::EmotionAbility_RequestMontageSection Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InStartSection = InStartSection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EmotionAbility.StopEmotion
// (Final, Native, Protected, BlueprintCallable)

void UEmotionAbility::StopEmotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionAbility", "StopEmotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.AttackHit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::AttackHit(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "AttackHit");

	Params::BGMLibrary_AttackHit Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.Damaged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::Damaged(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "Damaged");

	Params::BGMLibrary_Damaged Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.IsPlayingFieldBGM
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBGMLibrary::IsPlayingFieldBGM(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "IsPlayingFieldBGM");

	Params::BGMLibrary_IsPlayingFieldBGM Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BGMLibrary.IsPlayingInteractiveBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBGMLibrary::IsPlayingInteractiveBGM(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "IsPlayingInteractiveBGM");

	Params::BGMLibrary_IsPlayingInteractiveBGM Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BGMLibrary.PlayEventBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBGMLibrary::PlayEventBGM(const class UObject* WorldContextObject, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "PlayEventBGM");

	Params::BGMLibrary_PlayEventBGM Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BGMLibrary.PlayFieldBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::PlayFieldBGM(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "PlayFieldBGM");

	Params::BGMLibrary_PlayFieldBGM Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.PlayInteractiveBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::PlayInteractiveBGM(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "PlayInteractiveBGM");

	Params::BGMLibrary_PlayInteractiveBGM Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.PopFieldArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::PopFieldArea(const class UObject* WorldContextObject, class FName AreaName, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "PopFieldArea");

	Params::BGMLibrary_PopFieldArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AreaName = AreaName;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.PushFieldArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::PushFieldArea(const class UObject* WorldContextObject, class FName AreaName, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "PushFieldArea");

	Params::BGMLibrary_PushFieldArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AreaName = AreaName;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SendEnemyDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InParam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SendEnemyDistance(const class UObject* InWorldContextObject, const float InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SendEnemyDistance");

	Params::BGMLibrary_SendEnemyDistance Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SendEnemyHealthParam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InHealthParam                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SendEnemyHealthParam(const class UObject* InWorldContextObject, const float InHealthParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SendEnemyHealthParam");

	Params::BGMLibrary_SendEnemyHealthParam Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InHealthParam = InHealthParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SetFieldArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SetFieldArea(const class UObject* WorldContextObject, class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SetFieldArea");

	Params::BGMLibrary_SetFieldArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SetRTPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InRTPC                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InParam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SetRTPC(const class UObject* InWorldContextObject, const class FName InRTPC, const float InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SetRTPC");

	Params::BGMLibrary_SetRTPC Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InRTPC = InRTPC;
	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SetState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FName                       InStateGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SetState(const class FName InStateGroup, const class FName InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SetState");

	Params::BGMLibrary_SetState Parms{};

	Parms.InStateGroup = InStateGroup;
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SetSwitchInteractiveBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InSwitchGroup                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InSwitch                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SetSwitchInteractiveBGM(const class UObject* InWorldContextObject, const class FName InSwitchGroup, const class FName InSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SetSwitchInteractiveBGM");

	Params::BGMLibrary_SetSwitchInteractiveBGM Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InSwitchGroup = InSwitchGroup;
	Parms.InSwitch = InSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SetVolumeRTPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InRTPC                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InParam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SetVolumeRTPC(const class UObject* InWorldContextObject, const class FName InRTPC, const float InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SetVolumeRTPC");

	Params::BGMLibrary_SetVolumeRTPC Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InRTPC = InRTPC;
	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.StopAllEventBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::StopAllEventBGM(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "StopAllEventBGM");

	Params::BGMLibrary_StopAllEventBGM Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.StopEventBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::StopEventBGM(int32 PlayID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "StopEventBGM");

	Params::BGMLibrary_StopEventBGM Parms{};

	Parms.PlayID = PlayID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.StopFieldBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::StopFieldBGM(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "StopFieldBGM");

	Params::BGMLibrary_StopFieldBGM Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.StopInteractiveBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::StopInteractiveBGM(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "StopInteractiveBGM");

	Params::BGMLibrary_StopInteractiveBGM Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SwitchBattleBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInPlayMain                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SwitchBattleBGM(const class UObject* InWorldContextObject, const bool bInPlayMain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SwitchBattleBGM");

	Params::BGMLibrary_SwitchBattleBGM Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.bInPlayMain = bInPlayMain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SwitchInteractiveBGMInferiority
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInInferiority                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SwitchInteractiveBGMInferiority(const class UObject* InWorldContextObject, const bool bInInferiority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SwitchInteractiveBGMInferiority");

	Params::BGMLibrary_SwitchInteractiveBGMInferiority Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.bInInferiority = bInInferiority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BGMLibrary.SwitchInteractiveBGMMain
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInPlayMain                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBGMLibrary::SwitchInteractiveBGMMain(const class UObject* InWorldContextObject, const bool bInPlayMain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BGMLibrary", "SwitchInteractiveBGMMain");

	Params::BGMLibrary_SwitchInteractiveBGMMain Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.bInPlayMain = bInPlayMain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArticleFunctionEffect.Execute
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InNotifyMessage                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArticleFunctionEffect::Execute(class AActor* InOwner, const class FName InNotifyMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleFunctionEffect", "Execute");

	Params::ArticleFunctionEffect_Execute Parms{};

	Parms.InOwner = InOwner;
	Parms.InNotifyMessage = InNotifyMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.GetCharacterName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDigestDataManager::GetCharacterName(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetCharacterName");

	Params::DigestDataManager_GetCharacterName Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetCodeName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDigestDataManager::GetCodeName(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetCodeName");

	Params::DigestDataManager_GetCodeName Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetFieldArea
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDigestDataManager::GetFieldArea(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetFieldArea");

	Params::DigestDataManager_GetFieldArea Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetLastSavedYadorigi
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDigestDataManager::GetLastSavedYadorigi(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetLastSavedYadorigi");

	Params::DigestDataManager_GetLastSavedYadorigi Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDigestDataManager::GetLevel(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetLevel");

	Params::DigestDataManager_GetLevel Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetPlayTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDigestDataManager::GetPlayTime(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetPlayTime");

	Params::DigestDataManager_GetPlayTime Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetSaveLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDigestDataManager::GetSaveLocation(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetSaveLocation");

	Params::DigestDataManager_GetSaveLocation Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetThumbnailData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDigestDataTextureData           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDigestDataTextureData UDigestDataManager::GetThumbnailData(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetThumbnailData");

	Params::DigestDataManager_GetThumbnailData Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetThumbnailTexture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDigestDataTextureData&    InTextureData                                          (Parm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UDigestDataManager::GetThumbnailTexture(const class UObject* InWorldContextObject, const struct FDigestDataTextureData& InTextureData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetThumbnailTexture");

	Params::DigestDataManager_GetThumbnailTexture Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InTextureData = std::move(InTextureData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetTimeSeries
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDigestDataManager::GetTimeSeries(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetTimeSeries");

	Params::DigestDataManager_GetTimeSeries Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.GetTitleProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETitleProgressType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETitleProgressType UDigestDataManager::GetTitleProgress(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "GetTitleProgress");

	Params::DigestDataManager_GetTitleProgress Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsCleardCursedMoon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsCleardCursedMoon(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsCleardCursedMoon");

	Params::DigestDataManager_IsCleardCursedMoon Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsCleardHarmonyMoon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsCleardHarmonyMoon(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsCleardHarmonyMoon");

	Params::DigestDataManager_IsCleardHarmonyMoon Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsCleardSealingTower
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsCleardSealingTower(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsCleardSealingTower");

	Params::DigestDataManager_IsCleardSealingTower Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsCleardSealingTowerNotAllRescued
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsCleardSealingTowerNotAllRescued(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsCleardSealingTowerNotAllRescued");

	Params::DigestDataManager_IsCleardSealingTowerNotAllRescued Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsPlayTimeEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsPlayTimeEnable(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsPlayTimeEnable");

	Params::DigestDataManager_IsPlayTimeEnable Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.IsSaveAndReturnToTitle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDigestDataManager::IsSaveAndReturnToTitle(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "IsSaveAndReturnToTitle");

	Params::DigestDataManager_IsSaveAndReturnToTitle Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.RenderTargetToTexture2D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           InRenderTarget                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UDigestDataManager::RenderTargetToTexture2D(const class UObject* InWorldContextObject, class UTextureRenderTarget2D* InRenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "RenderTargetToTexture2D");

	Params::DigestDataManager_RenderTargetToTexture2D Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InRenderTarget = InRenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DigestDataManager.Reset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::Reset(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "Reset");

	Params::DigestDataManager_Reset Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.ResetPlayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::ResetPlayTime(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "ResetPlayTime");

	Params::DigestDataManager_ResetPlayTime Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCharacterName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InCharacterName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCharacterName(const class UObject* InWorldContextObject, const class FString& InCharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCharacterName");

	Params::DigestDataManager_SetCharacterName Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCharacterName = std::move(InCharacterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCleardCursedMoon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleared                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCleardCursedMoon(const class UObject* InWorldContextObject, bool InCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCleardCursedMoon");

	Params::DigestDataManager_SetCleardCursedMoon Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCleared = InCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCleardHarmonyMoon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleared                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCleardHarmonyMoon(const class UObject* InWorldContextObject, bool InCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCleardHarmonyMoon");

	Params::DigestDataManager_SetCleardHarmonyMoon Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCleared = InCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCleardSealingTower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleared                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCleardSealingTower(const class UObject* InWorldContextObject, bool InCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCleardSealingTower");

	Params::DigestDataManager_SetCleardSealingTower Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCleared = InCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCleardSealingTowerNotAllRescued
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleared                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCleardSealingTowerNotAllRescued(const class UObject* InWorldContextObject, bool InCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCleardSealingTowerNotAllRescued");

	Params::DigestDataManager_SetCleardSealingTowerNotAllRescued Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCleared = InCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetCodeName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InCodeName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetCodeName(const class UObject* InWorldContextObject, const class FString& InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetCodeName");

	Params::DigestDataManager_SetCodeName Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCodeName = std::move(InCodeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetFieldArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InFieldArea                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetFieldArea(const class UObject* InWorldContextObject, const struct FGameplayTag& InFieldArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetFieldArea");

	Params::DigestDataManager_SetFieldArea Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InFieldArea = std::move(InFieldArea);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetLastSavedYadorigi
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InLastSavedYadorigi                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetLastSavedYadorigi(const class UObject* InWorldContextObject, class FName InLastSavedYadorigi)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetLastSavedYadorigi");

	Params::DigestDataManager_SetLastSavedYadorigi Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InLastSavedYadorigi = InLastSavedYadorigi;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetLevel(const class UObject* InWorldContextObject, int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetLevel");

	Params::DigestDataManager_SetLevel Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetPlayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  InNewTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetPlayTime(const class UObject* InWorldContextObject, double InNewTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetPlayTime");

	Params::DigestDataManager_SetPlayTime Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InNewTime = InNewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetPlayTimeEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetPlayTimeEnable(const class UObject* InWorldContextObject, bool InIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetPlayTimeEnable");

	Params::DigestDataManager_SetPlayTimeEnable Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InIsEnable = InIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetSaveAndReturnToTitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSaved                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetSaveAndReturnToTitle(const class UObject* InWorldContextObject, bool InSaved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetSaveAndReturnToTitle");

	Params::DigestDataManager_SetSaveAndReturnToTitle Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InSaved = InSaved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetSaveLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InSaveLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetSaveLocation(const class UObject* InWorldContextObject, const struct FVector& InSaveLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetSaveLocation");

	Params::DigestDataManager_SetSaveLocation Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InSaveLocation = std::move(InSaveLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetThumbnailData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       InTexture                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetThumbnailData(const class UObject* InWorldContextObject, class UTexture2D* InTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetThumbnailData");

	Params::DigestDataManager_SetThumbnailData Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetThumbnailDataFromRenderTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           InRenderTarget                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetThumbnailDataFromRenderTarget(const class UObject* InWorldContextObject, class UTextureRenderTarget2D* InRenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetThumbnailDataFromRenderTarget");

	Params::DigestDataManager_SetThumbnailDataFromRenderTarget Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InRenderTarget = InRenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetTimeSeries
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InTimeSeries                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetTimeSeries(const class UObject* InWorldContextObject, const struct FGameplayTag& InTimeSeries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetTimeSeries");

	Params::DigestDataManager_SetTimeSeries Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InTimeSeries = std::move(InTimeSeries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.SetTitleProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETitleProgressType                      InTitleProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::SetTitleProgress(const class UObject* InWorldContextObject, ETitleProgressType InTitleProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DigestDataManager", "SetTitleProgress");

	Params::DigestDataManager_SetTitleProgress Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InTitleProgress = InTitleProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.OnWorldBeginPlay
// (Final, Native, Protected)

void UDigestDataManager::OnWorldBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DigestDataManager", "OnWorldBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DigestDataManager.OnWorldChanged
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InOldWorld                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InNewWorld                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDigestDataManager::OnWorldChanged(class UWorld* InOldWorld, class UWorld* InNewWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DigestDataManager", "OnWorldChanged");

	Params::DigestDataManager_OnWorldChanged Parms{};

	Parms.InOldWorld = InOldWorld;
	Parms.InNewWorld = InNewWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptPlayer.PauseScenario
// (Final, Native, Public, BlueprintCallable)

void AEdenEventScriptPlayer::PauseScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "PauseScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptPlayer.PlayScenario
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEdenEventScriptScenario>ScenarioClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEdenEventScriptPlayer::PlayScenario(TSubclassOf<class UEdenEventScriptScenario> ScenarioClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "PlayScenario");

	Params::EdenEventScriptPlayer_PlayScenario Parms{};

	Parms.ScenarioClass = ScenarioClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptPlayer.ResumeScenario
// (Final, Native, Public, BlueprintCallable)

void AEdenEventScriptPlayer::ResumeScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "ResumeScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptPlayer.StopScenario
// (Final, Native, Public, BlueprintCallable)

void AEdenEventScriptPlayer::StopScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "StopScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptPlayer.IsPaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEdenEventScriptPlayer::IsPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "IsPaused");

	Params::EdenEventScriptPlayer_IsPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EdenEventScriptPlayer.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEdenEventScriptPlayer::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "IsPlaying");

	Params::EdenEventScriptPlayer_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EdenEventScriptPlayer.IsStopped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEdenEventScriptPlayer::IsStopped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptPlayer", "IsStopped");

	Params::EdenEventScriptPlayer_IsStopped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SystemMessageUIObject.HideSystemMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USystemMessageUIObject::HideSystemMessage(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemMessageUIObject", "HideSystemMessage");

	Params::SystemMessageUIObject_HideSystemMessage Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SystemMessageUIObject.ShowSystemMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USystemMessageUIObject::ShowSystemMessage(class UObject* InWorldContext, const class FText& InTitle, const class FText& InMessage, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SystemMessageUIObject", "ShowSystemMessage");

	Params::SystemMessageUIObject_ShowSystemMessage Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTitle = std::move(InTitle);
	Parms.InMessage = std::move(InMessage);
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SystemMessageUIObject.HideSystemMessageBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemMessageUIObject::HideSystemMessageBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SystemMessageUIObject", "HideSystemMessageBP");

	Params::SystemMessageUIObject_HideSystemMessageBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SystemMessageUIObject.ShowSystemMessageBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USystemMessageUIObject::ShowSystemMessageBP(const class FText& InTitle, const class FText& InMessage, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SystemMessageUIObject", "ShowSystemMessageBP");

	Params::SystemMessageUIObject_ShowSystemMessageBP Parms{};

	Parms.InTitle = std::move(InTitle);
	Parms.InMessage = std::move(InMessage);
	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatGroupComponent.K2_OnChangeBloodSuckBatState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EBloodSuckBatState                InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodSuckBatGroupComponent::K2_OnChangeBloodSuckBatState(const EBloodSuckBatState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatGroupComponent", "K2_OnChangeBloodSuckBatState");

	Params::BloodSuckBatGroupComponent_K2_OnChangeBloodSuckBatState Parms{};

	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BloodSuckBatGroupComponent.K2_GetBloodSuckBatState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBloodSuckBatState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBloodSuckBatState UBloodSuckBatGroupComponent::K2_GetBloodSuckBatState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatGroupComponent", "K2_GetBloodSuckBatState");

	Params::BloodSuckBatGroupComponent_K2_GetBloodSuckBatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePostProcessActor.GetPostProcessCount
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhotoModePostProcessActor::GetPostProcessCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "GetPostProcessCount");

	Params::PhotoModePostProcessActor_GetPostProcessCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePostProcessActor.GetPostProcessDisplayNameByIndex
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APhotoModePostProcessActor::GetPostProcessDisplayNameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "GetPostProcessDisplayNameByIndex");

	Params::PhotoModePostProcessActor_GetPostProcessDisplayNameByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePostProcessActor.GetPostProcessNameByIndex
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APhotoModePostProcessActor::GetPostProcessNameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "GetPostProcessNameByIndex");

	Params::PhotoModePostProcessActor_GetPostProcessNameByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePostProcessActor.ResetPostProcess
// (Native, Event, Public, BlueprintEvent)

void APhotoModePostProcessActor::ResetPostProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "ResetPostProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModePostProcessActor.SelectPostProcessByIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhotoModePostProcessActor::SelectPostProcessByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "SelectPostProcessByIndex");

	Params::PhotoModePostProcessActor_SelectPostProcessByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PhotoModePostProcessActor.SetPostProcessBlendWeight
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const float                             InBlendWeight                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhotoModePostProcessActor::SetPostProcessBlendWeight(const float InBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "SetPostProcessBlendWeight");

	Params::PhotoModePostProcessActor_SetPostProcessBlendWeight Parms{};

	Parms.InBlendWeight = InBlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModePostProcessActor.SetPostProcessSettingsDataEx
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPostProcessSettingsDataEx&DataEx                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void APhotoModePostProcessActor::SetPostProcessSettingsDataEx(const struct FPostProcessSettingsDataEx& DataEx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "SetPostProcessSettingsDataEx");

	Params::PhotoModePostProcessActor_SetPostProcessSettingsDataEx Parms{};

	Parms.DataEx = std::move(DataEx);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModePostProcessActor.GetPostProcessComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPostProcessComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPostProcessComponent* APhotoModePostProcessActor::GetPostProcessComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "GetPostProcessComponent");

	Params::PhotoModePostProcessActor_GetPostProcessComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePostProcessActor.IsDebugEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APhotoModePostProcessActor::IsDebugEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePostProcessActor", "IsDebugEnabled");

	Params::PhotoModePostProcessActor_IsDebugEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ANS_SpawnBulletAttachedTemporary.GetSocketName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            OutSocketName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_SpawnBulletAttachedTemporary::GetSocketName(class FName* OutSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_SpawnBulletAttachedTemporary", "GetSocketName");

	Params::ANS_SpawnBulletAttachedTemporary_GetSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSocketName != nullptr)
		*OutSocketName = Parms.OutSocketName;
}


// Function Extensions.ANS_SpawnBulletAttachedTemporary.SetSocketName
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_SpawnBulletAttachedTemporary::SetSocketName(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_SpawnBulletAttachedTemporary", "SetSocketName");

	Params::ANS_SpawnBulletAttachedTemporary_SetSocketName Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenQuestSystemLibrary.GetQuestEnemys
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AEnemyCharacter*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AEnemyCharacter*> UEdenQuestSystemLibrary::GetQuestEnemys(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EdenQuestSystemLibrary", "GetQuestEnemys");

	Params::EdenQuestSystemLibrary_GetQuestEnemys Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetDefenceGadgetEnchantNumber
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEnhancementMenuTestActor::GetDefenceGadgetEnchantNumber(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetDefenceGadgetEnchantNumber");

	Params::EnhancementMenuTestActor_GetDefenceGadgetEnchantNumber Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetDefenceGadgetEnchantUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetDefenceGadgetEnchantUIInfo(const int32 InJailIndex, const int32 InEnchantIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetDefenceGadgetEnchantUIInfo");

	Params::EnhancementMenuTestActor_GetDefenceGadgetEnchantUIInfo Parms{};

	Parms.InJailIndex = InJailIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetDefenceGadgetNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AEnhancementMenuTestActor::GetDefenceGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetDefenceGadgetNumber");

	Params::EnhancementMenuTestActor_GetDefenceGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetDefenceGadgetUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetDefenceGadgetUIInfo(const int32 InIndex, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetDefenceGadgetUIInfo");

	Params::EnhancementMenuTestActor_GetDefenceGadgetUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetExp
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AEnhancementMenuTestActor::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetExp");

	Params::EnhancementMenuTestActor_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetIsUsingTestData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::GetIsUsingTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetIsUsingTestData");

	Params::EnhancementMenuTestActor_GetIsUsingTestData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetJailLevelUpUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetJailLevelUpUIInfo(const int32 InIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetJailLevelUpUIInfo");

	Params::EnhancementMenuTestActor_GetJailLevelUpUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetJailNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AEnhancementMenuTestActor::GetJailNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetJailNumber");

	Params::EnhancementMenuTestActor_GetJailNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetJailUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetJailUIInfo(const int32 InIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetJailUIInfo");

	Params::EnhancementMenuTestActor_GetJailUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetPlayerStatusSummaryInfo");

	Params::EnhancementMenuTestActor_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetStandAloneLevelUpUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetStandAloneLevelUpUIInfo(const int32 InIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetStandAloneLevelUpUIInfo");

	Params::EnhancementMenuTestActor_GetStandAloneLevelUpUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetStandAloneNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AEnhancementMenuTestActor::GetStandAloneNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetStandAloneNumber");

	Params::EnhancementMenuTestActor_GetStandAloneNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetStandAloneUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetStandAloneUIInfo(const int32 InIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetStandAloneUIInfo");

	Params::EnhancementMenuTestActor_GetStandAloneUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetWeaponEnchantNumber
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEnhancementMenuTestActor::GetWeaponEnchantNumber(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetWeaponEnchantNumber");

	Params::EnhancementMenuTestActor_GetWeaponEnchantNumber Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetWeaponEnchantUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetWeaponEnchantUIInfo(const int32 InWeaponIndex, const int32 InEnchantIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetWeaponEnchantUIInfo");

	Params::EnhancementMenuTestActor_GetWeaponEnchantUIInfo Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetWeaponLevelUpUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetWeaponLevelUpUIInfo(const int32 InIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetWeaponLevelUpUIInfo");

	Params::EnhancementMenuTestActor_GetWeaponLevelUpUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.GetWeaponNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AEnhancementMenuTestActor::GetWeaponNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetWeaponNumber");

	Params::EnhancementMenuTestActor_GetWeaponNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.GetWeaponUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AEnhancementMenuTestActor::GetWeaponUIInfo(const int32 InIndex, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "GetWeaponUIInfo");

	Params::EnhancementMenuTestActor_GetWeaponUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuTestActor.JailLevelUpRequest
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::JailLevelUpRequest(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "JailLevelUpRequest");

	Params::EnhancementMenuTestActor_JailLevelUpRequest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.RequestDefenceGadgetEnchant
// (Final, Native, Public)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::RequestDefenceGadgetEnchant(const int32 InJailIndex, const int32 InEnchantIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "RequestDefenceGadgetEnchant");

	Params::EnhancementMenuTestActor_RequestDefenceGadgetEnchant Parms{};

	Parms.InJailIndex = InJailIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.RequestUseTestData
// (Final, Native, Public, BlueprintCallable)

void AEnhancementMenuTestActor::RequestUseTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "RequestUseTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnhancementMenuTestActor.RequestWeaponEnchant
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::RequestWeaponEnchant(const int32 InWeaponIndex, const int32 InEnchantIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "RequestWeaponEnchant");

	Params::EnhancementMenuTestActor_RequestWeaponEnchant Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.StandAloneLevelUpRequest
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::StandAloneLevelUpRequest(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "StandAloneLevelUpRequest");

	Params::EnhancementMenuTestActor_StandAloneLevelUpRequest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuTestActor.WeaponLevelUpRequest
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEnhancementMenuTestActor::WeaponLevelUpRequest(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuTestActor", "WeaponLevelUpRequest");

	Params::EnhancementMenuTestActor_WeaponLevelUpRequest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AIFwEnemyAIController.RequestReplanning
// (Final, Native, Public, BlueprintCallable)

void AAIFwEnemyAIController::RequestReplanning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyAIController", "RequestReplanning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.GetPatrolPointGroup
// (Final, Native, Public)
// Parameters:
// const class APatrolPointGroup*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class APatrolPointGroup* UAIFwEnemyPatrolComponent::GetPatrolPointGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "GetPatrolPointGroup");

	Params::AIFwEnemyPatrolComponent_GetPatrolPointGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnChangePatrolPointGroup
// (Final, Native, Private)
// Parameters:
// class APatrolPointGroup*                NextPatrolPointGroup                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnChangePatrolPointGroup(class APatrolPointGroup* NextPatrolPointGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnChangePatrolPointGroup");

	Params::AIFwEnemyPatrolComponent_OnChangePatrolPointGroup Parms{};

	Parms.NextPatrolPointGroup = NextPatrolPointGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseAerialCage
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseAerialCage(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseAerialCage");

	Params::AIFwEnemyPatrolComponent_OnReleaseAerialCage Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseAerialCageDoor
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InImmediately                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseAerialCageDoor(class AActor* InActor, bool InImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseAerialCageDoor");

	Params::AIFwEnemyPatrolComponent_OnReleaseAerialCageDoor Parms{};

	Parms.InActor = InActor;
	Parms.InImmediately = InImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHangToClimb
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHangToClimb(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHangToClimb");

	Params::AIFwEnemyPatrolComponent_OnReleaseHangToClimb Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHangToClimbDoor
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InImmediately                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHangToClimbDoor(class AActor* InActor, bool InImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHangToClimbDoor");

	Params::AIFwEnemyPatrolComponent_OnReleaseHangToClimbDoor Parms{};

	Parms.InActor = InActor;
	Parms.InImmediately = InImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHangToFall
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHangToFall(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHangToFall");

	Params::AIFwEnemyPatrolComponent_OnReleaseHangToFall Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHangToFallDoor
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InImmediately                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHangToFallDoor(class AActor* InActor, bool InImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHangToFallDoor");

	Params::AIFwEnemyPatrolComponent_OnReleaseHangToFallDoor Parms{};

	Parms.InActor = InActor;
	Parms.InImmediately = InImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHiding
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHiding(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHiding");

	Params::AIFwEnemyPatrolComponent_OnReleaseHiding Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseHidingDoor
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InImmediately                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseHidingDoor(class AActor* InActor, bool InImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseHidingDoor");

	Params::AIFwEnemyPatrolComponent_OnReleaseHidingDoor Parms{};

	Parms.InActor = InActor;
	Parms.InImmediately = InImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseIdleWait
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseIdleWait(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseIdleWait");

	Params::AIFwEnemyPatrolComponent_OnReleaseIdleWait Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnReleaseIdleWaitDoor
// (Final, Native, Public)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InImmediately                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnReleaseIdleWaitDoor(class AActor* InActor, bool InImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnReleaseIdleWaitDoor");

	Params::AIFwEnemyPatrolComponent_OnReleaseIdleWaitDoor Parms{};

	Parms.InActor = InActor;
	Parms.InImmediately = InImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AIFwEnemyPatrolComponent.OnResumePatrolPointWait
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIFwEnemyPatrolComponent::OnResumePatrolPointWait(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIFwEnemyPatrolComponent", "OnResumePatrolPointWait");

	Params::AIFwEnemyPatrolComponent_OnResumePatrolPointWait Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletAnimNotifyInterface.SetSocketName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnBulletAnimNotifyInterface::SetSocketName(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletAnimNotifyInterface", "SetSocketName");

	Params::SpawnBulletAnimNotifyInterface_SetSocketName Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletAnimNotifyInterface.GetSocketName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            OutSocketName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnBulletAnimNotifyInterface::GetSocketName(class FName* OutSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletAnimNotifyInterface", "GetSocketName");

	Params::SpawnBulletAnimNotifyInterface_GetSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSocketName != nullptr)
		*OutSocketName = Parms.OutSocketName;
}


// Function Extensions.AnimalCharacter.BP_FindNavMoveDestination
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool*                                   OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimalCharacter::BP_FindNavMoveDestination(bool* OutIsValid, struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalCharacter", "BP_FindNavMoveDestination");

	Params::AnimalCharacter_BP_FindNavMoveDestination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);
}


// Function Extensions.AnimalCharacter.GetNavMoveTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MinDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AAnimalCharacter::GetNavMoveTarget(float MinDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalCharacter", "GetNavMoveTarget");

	Params::AnimalCharacter_GetNavMoveTarget Parms{};

	Parms.MinDistance = MinDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BulletSpawnActor.SpawnBullet_Client
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FBulletCreateInfo&         InInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletSpawnActor::SpawnBullet_Client(const struct FBulletCreateInfo& InInfo, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletSpawnActor", "SpawnBullet_Client");

	Params::BulletSpawnActor_SpawnBullet_Client Parms{};

	Parms.InInfo = std::move(InInfo);
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletSpawnActor.SpawnBullet_Server
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// const struct FBulletCreateInfo&         InInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletSpawnActor::SpawnBullet_Server(const struct FBulletCreateInfo& InInfo, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletSpawnActor", "SpawnBullet_Server");

	Params::BulletSpawnActor_SpawnBullet_Server Parms{};

	Parms.InInfo = std::move(InInfo);
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ClosenessManager.OnChangeStoryFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     Param                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UClosenessManager::OnChangeStoryFlag(const struct FStoryFlagChangeParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosenessManager", "OnChangeStoryFlag");

	Params::ClosenessManager_OnChangeStoryFlag Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ClosenessManager.OnCharacterEpisodeFlagChanged
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagEvaluationFormula&EvaluationFormula                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClosenessManager::OnCharacterEpisodeFlagChanged(const struct FStoryFlagEvaluationFormula& EvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosenessManager", "OnCharacterEpisodeFlagChanged");

	Params::ClosenessManager_OnCharacterEpisodeFlagChanged Parms{};

	Parms.EvaluationFormula = std::move(EvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AnimDynamicsPostProcessAnimInstance.GetBlinkParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimBlinkParameter        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimBlinkParameter UAnimDynamicsPostProcessAnimInstance::GetBlinkParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDynamicsPostProcessAnimInstance", "GetBlinkParameter");

	Params::AnimDynamicsPostProcessAnimInstance_GetBlinkParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimDynamicsPostProcessAnimInstance.GetCurveValueOnEvaluation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InCurveName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimDynamicsPostProcessAnimInstance::GetCurveValueOnEvaluation(class FName InCurveName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDynamicsPostProcessAnimInstance", "GetCurveValueOnEvaluation");

	Params::AnimDynamicsPostProcessAnimInstance_GetCurveValueOnEvaluation Parms{};

	Parms.InCurveName = InCurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimDynamicsPostProcessAnimInstance.GetHeadScaleParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimHeadScaleParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimHeadScaleParameter UAnimDynamicsPostProcessAnimInstance::GetHeadScaleParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDynamicsPostProcessAnimInstance", "GetHeadScaleParam");

	Params::AnimDynamicsPostProcessAnimInstance_GetHeadScaleParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AnimDynamicsPostProcessAnimInstance.GetMainAnimInstance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAppAnimInstance*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAppAnimInstance* UAnimDynamicsPostProcessAnimInstance::GetMainAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDynamicsPostProcessAnimInstance", "GetMainAnimInstance");

	Params::AnimDynamicsPostProcessAnimInstance_GetMainAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckBatController.Flocking
// (Final, Native, Public, BlueprintCallable)

void UBloodSuckBatController::Flocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatController", "Flocking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckBatController.K2_GetBloodSuckBatContext
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBloodSuckBatContext       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBloodSuckBatContext UBloodSuckBatController::K2_GetBloodSuckBatContext() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckBatController", "K2_GetBloodSuckBatContext");

	Params::BloodSuckBatController_K2_GetBloodSuckBatContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSettings.GetEyeClosingPatternThumbnail
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEyeClosingPattern                      InPattern                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UCharacterCustomizeSettings::GetEyeClosingPatternThumbnail(EEyeClosingPattern InPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSettings", "GetEyeClosingPatternThumbnail");

	Params::CharacterCustomizeSettings_GetEyeClosingPatternThumbnail Parms{};

	Parms.InPattern = InPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ScreenEffectActor.PlayEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AScreenEffectActor::PlayEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenEffectActor", "PlayEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ANS_ChangePitch.ReplaceBoneName_BP
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const class FName&                      InFindName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InReplaceName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsReplace                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UANS_ChangePitch::ReplaceBoneName_BP(const class FName& InFindName, const class FName& InReplaceName, const bool IsReplace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_ChangePitch", "ReplaceBoneName_BP");

	Params::ANS_ChangePitch_ReplaceBoneName_BP Parms{};

	Parms.InFindName = InFindName;
	Parms.InReplaceName = InReplaceName;
	Parms.IsReplace = IsReplace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyTradeManager.GetViewTradePoint
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UBuddyTradeManager::GetViewTradePoint(const struct FGameplayTag& InBuddyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyTradeManager", "GetViewTradePoint");

	Params::BuddyTradeManager_GetViewTradePoint Parms{};

	Parms.InBuddyType = std::move(InBuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnBloodCodeNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnBloodCodeNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnBloodCodeNumberGetRequest");

	Params::FieldMenuTestActor_OnBloodCodeNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnBoosterNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnBoosterNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnBoosterNumberGetRequest");

	Params::FieldMenuTestActor_OnBoosterNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnDefensiveGadgetNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnDefensiveGadgetNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnDefensiveGadgetNumberGetRequest");

	Params::FieldMenuTestActor_OnDefensiveGadgetNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnEquipBloodCodeRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipBloodCodeRequest(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipBloodCodeRequest");

	Params::FieldMenuTestActor_OnEquipBloodCodeRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipBoosterRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InBoosterIindex                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipBoosterRequest(const EUIBoosterSlot InSlot, const int32 InBoosterIindex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipBoosterRequest");

	Params::FieldMenuTestActor_OnEquipBoosterRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterIindex = InBoosterIindex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipDefensiveGadgetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipDefensiveGadgetRequest(const int32 InDefensiveGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipDefensiveGadgetRequest");

	Params::FieldMenuTestActor_OnEquipDefensiveGadgetRequest Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipIndependentGadgetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipIndependentGadgetRequest(const int32 InIndependentGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipIndependentGadgetRequest");

	Params::FieldMenuTestActor_OnEquipIndependentGadgetRequest Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipShortcutItemRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipShortcutItemRequest(const EUIItemShortcutSlot InSlot, const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipShortcutItemRequest");

	Params::FieldMenuTestActor_OnEquipShortcutItemRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipSuckingBloodRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InSuckingBloodID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipSuckingBloodRequest(const int32 InSuckingBloodID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipSuckingBloodRequest");

	Params::FieldMenuTestActor_OnEquipSuckingBloodRequest Parms{};

	Parms.InSuckingBloodID = InSuckingBloodID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnEquipWeaponRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnEquipWeaponRequest(const EUIWeaponSlot InSlot, const int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnEquipWeaponRequest");

	Params::FieldMenuTestActor_OnEquipWeaponRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnGetBloodCodeIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetBloodCodeIDByIndexRequest(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBloodCodeIDByIndexRequest");

	Params::FieldMenuTestActor_OnGetBloodCodeIDByIndexRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetBloodCodeInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetBloodCodeInfoByIndexRequest(const int32 InBloodCodeIndex, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBloodCodeInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetBloodCodeInfoByIndexRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetBloodCodeInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InBloodCodeID                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetBloodCodeInfoRequest(const class FName InBloodCodeID, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBloodCodeInfoRequest");

	Params::FieldMenuTestActor_OnGetBloodCodeInfoRequest Parms{};

	Parms.InBloodCodeID = InBloodCodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetBoosterIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetBoosterIDByIndexRequest(const int32 InBoosterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBoosterIDByIndexRequest");

	Params::FieldMenuTestActor_OnGetBoosterIDByIndexRequest Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetBoosterInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetBoosterInfoByIndexRequest(const int32 InBoosterIndex, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBoosterInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetBoosterInfoByIndexRequest Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetBoosterInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InBoosterID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetBoosterInfoRequest(const class FName InBoosterID, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetBoosterInfoRequest");

	Params::FieldMenuTestActor_OnGetBoosterInfoRequest Parms{};

	Parms.InBoosterID = InBoosterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetDefensiveGadgetInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutDefensiveGadgetInfo                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetDefensiveGadgetInfoByIndexRequest(const int32 InDefensiveGadgetIndex, struct FUIDefensiveGadgetInfo* OutDefensiveGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetDefensiveGadgetInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetDefensiveGadgetInfoByIndexRequest Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefensiveGadgetInfo != nullptr)
		*OutDefensiveGadgetInfo = std::move(Parms.OutDefensiveGadgetInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetEquippableItemIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InItemIndext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetEquippableItemIDByIndexRequest(const int32 InItemIndext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippableItemIDByIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippableItemIDByIndexRequest Parms{};

	Parms.InItemIndext = InItemIndext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippableItemInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetEquippableItemInfoByIndexRequest(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippableItemInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippableItemInfoByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetEquippableItemNumberRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippableItemNumberRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippableItemNumberRequest");

	Params::FieldMenuTestActor_OnGetEquippableItemNumberRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedBloodCodeIDRequest
// (Final, Native, Protected)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetEquippedBloodCodeIDRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedBloodCodeIDRequest");

	Params::FieldMenuTestActor_OnGetEquippedBloodCodeIDRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedBloodCodeIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedBloodCodeIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedBloodCodeIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedBloodCodeIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedBoosterIDRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetEquippedBoosterIDRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedBoosterIDRequest");

	Params::FieldMenuTestActor_OnGetEquippedBoosterIDRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedBoosterIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedBoosterIndexRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedBoosterIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedBoosterIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedDefensiveGadgetIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedDefensiveGadgetIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedDefensiveGadgetIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedDefensiveGadgetIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedIndependentGadgetIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedIndependentGadgetIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedIndependentGadgetIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedIndependentGadgetIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedSuckingBloodIDRequest
// (Final, Native, Protected)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetEquippedSuckingBloodIDRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedSuckingBloodIDRequest");

	Params::FieldMenuTestActor_OnGetEquippedSuckingBloodIDRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedSuckingBloodIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedSuckingBloodIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedSuckingBloodIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedSuckingBloodIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetEquippedWeaponIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetEquippedWeaponIndexRequest(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetEquippedWeaponIndexRequest");

	Params::FieldMenuTestActor_OnGetEquippedWeaponIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetIndependentGadgetInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutIndependentGadgetInfo                               (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetIndependentGadgetInfoByIndexRequest(const int32 InIndependentGadgetIndex, struct FUIIndependentGadgetInfo* OutIndependentGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetIndependentGadgetInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetIndependentGadgetInfoByIndexRequest Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndependentGadgetInfo != nullptr)
		*OutIndependentGadgetInfo = std::move(Parms.OutIndependentGadgetInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetItemIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetItemIDByIndexRequest(const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetItemIDByIndexRequest");

	Params::FieldMenuTestActor_OnGetItemIDByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetItemInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetItemInfoByIndexRequest(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetItemInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetItemInfoByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetItemInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InItemName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetItemInfoRequest(const class FName InItemName, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetItemInfoRequest");

	Params::FieldMenuTestActor_OnGetItemInfoRequest Parms{};

	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetPlayerStatusInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FUIPlayerStatusInfo*             OutStatusInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetPlayerStatusInfoRequest(struct FUIPlayerStatusInfo* OutStatusInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetPlayerStatusInfoRequest");

	Params::FieldMenuTestActor_OnGetPlayerStatusInfoRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStatusInfo != nullptr)
		*OutStatusInfo = std::move(Parms.OutStatusInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetPlayerStatusSummaryInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetPlayerStatusSummaryInfoRequest(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetPlayerStatusSummaryInfoRequest");

	Params::FieldMenuTestActor_OnGetPlayerStatusSummaryInfoRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetShortcutItemIDRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetShortcutItemIDRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetShortcutItemIDRequest");

	Params::FieldMenuTestActor_OnGetShortcutItemIDRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetShortcutItemIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnGetShortcutItemIndexRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetShortcutItemIndexRequest");

	Params::FieldMenuTestActor_OnGetShortcutItemIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetSuckingBloodIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor::OnGetSuckingBloodIDByIndexRequest(const int32 InSuckingBloodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetSuckingBloodIDByIndexRequest");

	Params::FieldMenuTestActor_OnGetSuckingBloodIDByIndexRequest Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnGetSuckingBloodInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetSuckingBloodInfoByIndexRequest(const int32 InSuckingBloodIndex, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetSuckingBloodInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetSuckingBloodInfoByIndexRequest Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetSuckingBloodInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InSuckingBloodID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetSuckingBloodInfoRequest(const class FName InSuckingBloodID, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetSuckingBloodInfoRequest");

	Params::FieldMenuTestActor_OnGetSuckingBloodInfoRequest Parms{};

	Parms.InSuckingBloodID = InSuckingBloodID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuTestActor.OnGetWeaponInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnGetWeaponInfoByIndexRequest(const int32 InWeaponIndex, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnGetWeaponInfoByIndexRequest");

	Params::FieldMenuTestActor_OnGetWeaponInfoByIndexRequest Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.FieldMenuTestActor.OnIndependentGadgetNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnIndependentGadgetNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnIndependentGadgetNumberGetRequest");

	Params::FieldMenuTestActor_OnIndependentGadgetNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnItemNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnItemNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnItemNumberGetRequest");

	Params::FieldMenuTestActor_OnItemNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnSuckingBloodNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnSuckingBloodNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnSuckingBloodNumberGetRequest");

	Params::FieldMenuTestActor_OnSuckingBloodNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor.OnUnequipBoosterRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnUnequipBoosterRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipBoosterRequest");

	Params::FieldMenuTestActor_OnUnequipBoosterRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnUnequipDefensiveGadgetRequest
// (Final, Native, Protected)

void AFieldMenuTestActor::OnUnequipDefensiveGadgetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipDefensiveGadgetRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnUnequipIndependentGadgetRequest
// (Final, Native, Protected)

void AFieldMenuTestActor::OnUnequipIndependentGadgetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipIndependentGadgetRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnUnequipShortcutItemRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnUnequipShortcutItemRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipShortcutItemRequest");

	Params::FieldMenuTestActor_OnUnequipShortcutItemRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnUnequipSuckingBloodRequest
// (Final, Native, Protected)

void AFieldMenuTestActor::OnUnequipSuckingBloodRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipSuckingBloodRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnUnequipWeaponRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor::OnUnequipWeaponRequest(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnUnequipWeaponRequest");

	Params::FieldMenuTestActor_OnUnequipWeaponRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor.OnWeaponNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor::OnWeaponNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor", "OnWeaponNumberGetRequest");

	Params::FieldMenuTestActor_OnWeaponNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelSubsystem.K2_AsyncFastTravel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewPlayerLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  NewPlayerRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CameraYaw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFindGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScreenMaskSettings&       ScreenMaskSettings                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTimeSeriesSettings&       TimeSeriesSettings                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUseIncrementalFastTravel                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFastTravelProxy*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFastTravelProxy* UFastTravelSubsystem::K2_AsyncFastTravel(const class UObject* InWorldContext, const struct FVector& NewPlayerLocation, const struct FRotator& NewPlayerRotation, float CameraYaw, bool bIsFindGround, const struct FScreenMaskSettings& ScreenMaskSettings, const struct FTimeSeriesSettings& TimeSeriesSettings, bool bUseIncrementalFastTravel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FastTravelSubsystem", "K2_AsyncFastTravel");

	Params::FastTravelSubsystem_K2_AsyncFastTravel Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.NewPlayerLocation = std::move(NewPlayerLocation);
	Parms.NewPlayerRotation = std::move(NewPlayerRotation);
	Parms.CameraYaw = CameraYaw;
	Parms.bIsFindGround = bIsFindGround;
	Parms.ScreenMaskSettings = std::move(ScreenMaskSettings);
	Parms.TimeSeriesSettings = std::move(TimeSeriesSettings);
	Parms.bUseIncrementalFastTravel = bUseIncrementalFastTravel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelSubsystem.RegisterFastTravelable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IFastTravelableInterface>FastTravelable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFastTravelSubsystem::RegisterFastTravelable(const class UObject* InWorldContext, TScriptInterface<class IFastTravelableInterface> FastTravelable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FastTravelSubsystem", "RegisterFastTravelable");

	Params::FastTravelSubsystem_RegisterFastTravelable Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.FastTravelable = FastTravelable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FastTravelSubsystem.UnregisterFastTravelable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IFastTravelableInterface>FastTravelable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFastTravelSubsystem::UnregisterFastTravelable(const class UObject* InWorldContext, TScriptInterface<class IFastTravelableInterface> FastTravelable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FastTravelSubsystem", "UnregisterFastTravelable");

	Params::FastTravelSubsystem_UnregisterFastTravelable Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.FastTravelable = FastTravelable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FastTravelSubsystem.OnFastTravelCompleted
// (Final, Native, Public)

void UFastTravelSubsystem::OnFastTravelCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FastTravelSubsystem", "OnFastTravelCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BoosterDialogUIObject.ShowBoosterDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UBloodCodeArticleData*      InBloodCodeData                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UBoosterArticleData*        InBoosterData                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBoosterDialogUIObject::ShowBoosterDialog(const class UObject* InWorldContext, const class UBloodCodeArticleData* InBloodCodeData, const class UBoosterArticleData* InBoosterData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BoosterDialogUIObject", "ShowBoosterDialog");

	Params::BoosterDialogUIObject_ShowBoosterDialog Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InBloodCodeData = InBloodCodeData;
	Parms.InBoosterData = InBoosterData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BoosterDialogUIObject.ShowBoosterDialogByAddInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FArticleAddInfo_BloodCode& InBloodCodeAddInfo                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FArticleBulkInfo&          InBoosterArticleBulkInfo                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBoosterDialogUIObject::ShowBoosterDialogByAddInfo(const class UObject* InWorldContext, const struct FArticleAddInfo_BloodCode& InBloodCodeAddInfo, const struct FArticleBulkInfo& InBoosterArticleBulkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BoosterDialogUIObject", "ShowBoosterDialogByAddInfo");

	Params::BoosterDialogUIObject_ShowBoosterDialogByAddInfo Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InBloodCodeAddInfo = std::move(InBloodCodeAddInfo);
	Parms.InBoosterArticleBulkInfo = std::move(InBoosterArticleBulkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BoosterDialogUIObject.GetBoosterDialogInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBoosterDialogInfo*              OutDialogInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBoosterDialogUIObject::GetBoosterDialogInfo(struct FBoosterDialogInfo* OutDialogInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoosterDialogUIObject", "GetBoosterDialogInfo");

	Params::BoosterDialogUIObject_GetBoosterDialogInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDialogInfo != nullptr)
		*OutDialogInfo = std::move(Parms.OutDialogInfo);

	return Parms.ReturnValue;
}


// Function Extensions.BoosterDialogUIObject.OnDialogClosed
// (Final, Native, Public, BlueprintCallable)

void UBoosterDialogUIObject::OnDialogClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoosterDialogUIObject", "OnDialogClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemIndicatorUIObject.IsItemShortcutPanelVisible
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::IsItemShortcutPanelVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "IsItemShortcutPanelVisible");

	Params::ItemIndicatorUIObject_IsItemShortcutPanelVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemIndicatorUIObject.NotifyGainItem
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FUIItemGainInfo&           InItemInfo                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::NotifyGainItem(const struct FUIItemGainInfo& InItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "NotifyGainItem");

	Params::ItemIndicatorUIObject_NotifyGainItem Parms{};

	Parms.InItemInfo = std::move(InItemInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemIndicatorUIObject.NotifyItemCountChanged
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FUIShortcutItemInfo&       InItemInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::NotifyItemCountChanged(const struct FUIShortcutItemInfo& InItemInfo, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "NotifyItemCountChanged");

	Params::ItemIndicatorUIObject_NotifyItemCountChanged Parms{};

	Parms.InItemInfo = std::move(InItemInfo);
	Parms.InNewCount = InNewCount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemIndicatorUIObject.NotifyItemEquipmentSet
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FUIShortcutItemInfo&       InPrevItemInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FUIShortcutItemInfo&       InItemInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FUIShortcutItemInfo&       InNextItemInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::NotifyItemEquipmentSet(const struct FUIShortcutItemInfo& InPrevItemInfo, const struct FUIShortcutItemInfo& InItemInfo, const struct FUIShortcutItemInfo& InNextItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "NotifyItemEquipmentSet");

	Params::ItemIndicatorUIObject_NotifyItemEquipmentSet Parms{};

	Parms.InPrevItemInfo = std::move(InPrevItemInfo);
	Parms.InItemInfo = std::move(InItemInfo);
	Parms.InNextItemInfo = std::move(InNextItemInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemIndicatorUIObject.NotifyItemSelectionChanged
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EUIItemSelectionMoveDir           InDir                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIShortcutItemInfo&       InPrevItemInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FUIShortcutItemInfo&       InItemInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FUIShortcutItemInfo&       InNextItemInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemIndicatorUIObject::NotifyItemSelectionChanged(const EUIItemSelectionMoveDir InDir, const struct FUIShortcutItemInfo& InPrevItemInfo, const struct FUIShortcutItemInfo& InItemInfo, const struct FUIShortcutItemInfo& InNextItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "NotifyItemSelectionChanged");

	Params::ItemIndicatorUIObject_NotifyItemSelectionChanged Parms{};

	Parms.InDir = InDir;
	Parms.InPrevItemInfo = std::move(InPrevItemInfo);
	Parms.InItemInfo = std::move(InItemInfo);
	Parms.InNextItemInfo = std::move(InNextItemInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ItemIndicatorUIObject.NotifyItemValidityChanged
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FUIShortcutItemInfo&       InItemInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    InItemValid                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::NotifyItemValidityChanged(const struct FUIShortcutItemInfo& InItemInfo, bool InItemValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "NotifyItemValidityChanged");

	Params::ItemIndicatorUIObject_NotifyItemValidityChanged Parms{};

	Parms.InItemInfo = std::move(InItemInfo);
	Parms.InItemValid = InItemValid;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemIndicatorUIObject.ShowItemShortcutPanel
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemIndicatorUIObject::ShowItemShortcutPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemIndicatorUIObject", "ShowItemShortcutPanel");

	Params::ItemIndicatorUIObject_ShowItemShortcutPanel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GameFlowManager.OnAudioDeviceDialogDecided
// (Final, Native, Protected)
// Parameters:
// const uint8                             DecideOptionNumber                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnAudioDeviceDialogDecided(const uint8 DecideOptionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnAudioDeviceDialogDecided");

	Params::GameFlowManager_OnAudioDeviceDialogDecided Parms{};

	Parms.DecideOptionNumber = DecideOptionNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnCharacterPreLoadCompletedScreenMask
// (Final, Native, Protected)

void UGameFlowManager::OnCharacterPreLoadCompletedScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnCharacterPreLoadCompletedScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnCharacterPreLoadCompletedShowSubLevel
// (Final, Native, Protected)

void UGameFlowManager::OnCharacterPreLoadCompletedShowSubLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnCharacterPreLoadCompletedShowSubLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnCharacterPreLoadCompletedWait
// (Final, Native, Protected)

void UGameFlowManager::OnCharacterPreLoadCompletedWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnCharacterPreLoadCompletedWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnCharacterPreLoadSimpleLoadWait
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnCharacterPreLoadSimpleLoadWait(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnCharacterPreLoadSimpleLoadWait");

	Params::GameFlowManager_OnCharacterPreLoadSimpleLoadWait Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnDebugTitleFlowCompletedScreenMask
// (Final, Native, Protected)

void UGameFlowManager::OnDebugTitleFlowCompletedScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnDebugTitleFlowCompletedScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnDLCRuntimeInstalled
// (Final, Native, Private)
// Parameters:
// class FName                             DLCName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlatformUserId&           PlatformUserId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnDLCRuntimeInstalled(class FName DLCName, const struct FPlatformUserId& PlatformUserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnDLCRuntimeInstalled");

	Params::GameFlowManager_OnDLCRuntimeInstalled Parms{};

	Parms.DLCName = DLCName;
	Parms.PlatformUserId = std::move(PlatformUserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnLogoSectionFinished
// (Final, Native, Protected)

void UGameFlowManager::OnLogoSectionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnLogoSectionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnMultiplayLoadedMap
// (Final, Native, Public)
// Parameters:
// class UWorld*                           InLoadedWorld                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnMultiplayLoadedMap(class UWorld* InLoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnMultiplayLoadedMap");

	Params::GameFlowManager_OnMultiplayLoadedMap Parms{};

	Parms.InLoadedWorld = InLoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnNewGamePlusCompletedScreenMask
// (Final, Native, Protected)

void UGameFlowManager::OnNewGamePlusCompletedScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnNewGamePlusCompletedScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnPlayablePreparationTick
// (Final, Native, Protected)

void UGameFlowManager::OnPlayablePreparationTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnPlayablePreparationTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnPostWorldCleanup
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSessionEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleanupResources                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnPostWorldCleanup(class UWorld* InWorld, bool InSessionEnded, bool InCleanupResources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnPostWorldCleanup");

	Params::GameFlowManager_OnPostWorldCleanup Parms{};

	Parms.InWorld = InWorld;
	Parms.InSessionEnded = InSessionEnded;
	Parms.InCleanupResources = InCleanupResources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnReturnToTitleCompletedScreenMask
// (Final, Native, Protected)

void UGameFlowManager::OnReturnToTitleCompletedScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnReturnToTitleCompletedScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnReturnToTitlePostWorldCleanup
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSessionEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleanupResources                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnReturnToTitlePostWorldCleanup(class UWorld* InWorld, bool InSessionEnded, bool InCleanupResources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnReturnToTitlePostWorldCleanup");

	Params::GameFlowManager_OnReturnToTitlePostWorldCleanup Parms{};

	Parms.InWorld = InWorld;
	Parms.InSessionEnded = InSessionEnded;
	Parms.InCleanupResources = InCleanupResources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnReturnToTitleSaveCompleted
// (Final, Native, Protected)
// Parameters:
// const class FString&                    InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InResult                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnReturnToTitleSaveCompleted(const class FString& InSlotName, bool InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnReturnToTitleSaveCompleted");

	Params::GameFlowManager_OnReturnToTitleSaveCompleted Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InResult = InResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnShaderCompileWaitFinished
// (Final, Native, Protected)

void UGameFlowManager::OnShaderCompileWaitFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnShaderCompileWaitFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnTitlePostLoadedMap
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InLoadedWorld                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnTitlePostLoadedMap(class UWorld* InLoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnTitlePostLoadedMap");

	Params::GameFlowManager_OnTitlePostLoadedMap Parms{};

	Parms.InLoadedWorld = InLoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnTitleScreenMasked
// (Final, Native, Protected)

void UGameFlowManager::OnTitleScreenMasked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnTitleScreenMasked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnWorldBeginPlayEvent
// (Final, Native, Protected)

void UGameFlowManager::OnWorldBeginPlayEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnWorldBeginPlayEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.OnWorldCleanup
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSessionEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCleanupResources                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::OnWorldCleanup(class UWorld* InWorld, bool InSessionEnded, bool InCleanupResources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "OnWorldCleanup");

	Params::GameFlowManager_OnWorldCleanup Parms{};

	Parms.InWorld = InWorld;
	Parms.InSessionEnded = InSessionEnded;
	Parms.InCleanupResources = InCleanupResources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.RequestBeginTitle
// (Final, Native, Public, BlueprintCallable)

void UGameFlowManager::RequestBeginTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "RequestBeginTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameFlowManager.RequestReturnToTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsSave                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameFlowManager::RequestReturnToTitle(bool InIsSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFlowManager", "RequestReturnToTitle");

	Params::GameFlowManager_RequestReturnToTitle Parms{};

	Parms.InIsSave = InIsSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FastTravelableInterface.GetFastTravelCameraYaw
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IFastTravelableInterface::GetFastTravelCameraYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "GetFastTravelCameraYaw");

	Params::FastTravelableInterface_GetFastTravelCameraYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelableInterface.GetFastTravelCategory
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IFastTravelableInterface::GetFastTravelCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "GetFastTravelCategory");

	Params::FastTravelableInterface_GetFastTravelCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelableInterface.GetFastTravelLocation
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IFastTravelableInterface::GetFastTravelLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "GetFastTravelLocation");

	Params::FastTravelableInterface_GetFastTravelLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelableInterface.GetFastTravelName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IFastTravelableInterface::GetFastTravelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "GetFastTravelName");

	Params::FastTravelableInterface_GetFastTravelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelableInterface.GetFastTravelRotation
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator IFastTravelableInterface::GetFastTravelRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "GetFastTravelRotation");

	Params::FastTravelableInterface_GetFastTravelRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FastTravelableInterface.IsNoFindGround
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFastTravelableInterface::IsNoFindGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FastTravelableInterface", "IsNoFindGround");

	Params::FastTravelableInterface_IsNoFindGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArticleFunction_UsableItem.ApplySpecialBuffs
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     InArticleID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArticleFunction_UsableItem::ApplySpecialBuffs(class AActor* InOwner, const struct FGuid& InArticleID, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleFunction_UsableItem", "ApplySpecialBuffs");

	Params::ArticleFunction_UsableItem_ApplySpecialBuffs Parms{};

	Parms.InOwner = InOwner;
	Parms.InArticleID = std::move(InArticleID);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyEquipmentVisualControlComponent.OnDropWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyEquipmentVisualControlComponent::OnDropWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipmentVisualControlComponent", "OnDropWeapon");

	Params::EnemyEquipmentVisualControlComponent_OnDropWeapon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipmentVisualControlComponent.OnDying
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyEquipmentVisualControlComponent::OnDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipmentVisualControlComponent", "OnDying");

	Params::EnemyEquipmentVisualControlComponent_OnDying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ANS_SpawnBullet.GetSocketName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            OutSocketName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_SpawnBullet::GetSocketName(class FName* OutSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_SpawnBullet", "GetSocketName");

	Params::ANS_SpawnBullet_GetSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSocketName != nullptr)
		*OutSocketName = Parms.OutSocketName;
}


// Function Extensions.ANS_SpawnBullet.SetSocketName
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_SpawnBullet::SetSocketName(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_SpawnBullet", "SetSocketName");

	Params::ANS_SpawnBullet_SetSocketName Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ANS_TrailNiagaraEffect.GetSpawnedEffect
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UANS_TrailNiagaraEffect::GetSpawnedEffect(class UMeshComponent* MeshComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_TrailNiagaraEffect", "GetSpawnedEffect");

	Params::ANS_TrailNiagaraEffect_GetSpawnedEffect Parms{};

	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CheatOperatorInputSubsystem.GetLastMouseDelta
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCheatOperatorInputSubsystem::GetLastMouseDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatOperatorInputSubsystem", "GetLastMouseDelta");

	Params::CheatOperatorInputSubsystem_GetLastMouseDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CheatOperatorInputSubsystem.GetLastMouseScreenPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCheatOperatorInputSubsystem::GetLastMouseScreenPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatOperatorInputSubsystem", "GetLastMouseScreenPosition");

	Params::CheatOperatorInputSubsystem_GetLastMouseScreenPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CheatOperatorInputSubsystem.GetLastMouseWheelDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCheatOperatorInputSubsystem::GetLastMouseWheelDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatOperatorInputSubsystem", "GetLastMouseWheelDelta");

	Params::CheatOperatorInputSubsystem_GetLastMouseWheelDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CheatOperatorInputSubsystem.IsGamepadConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCheatOperatorInputSubsystem::IsGamepadConnected(int32 ControllerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatOperatorInputSubsystem", "IsGamepadConnected");

	Params::CheatOperatorInputSubsystem_IsGamepadConnected Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicHandIKSection.GetCinematicHandIKParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCinematicHandIKParams           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCinematicHandIKParams UCinematicHandIKSection::GetCinematicHandIKParams(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicHandIKSection", "GetCinematicHandIKParams");

	Params::CinematicHandIKSection_GetCinematicHandIKParams Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyPawnSensingComponent.OnOriHearNoise
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyPawnSensingComponent::OnOriHearNoise(class APawn* Instigator, const struct FVector& Location, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyPawnSensingComponent", "OnOriHearNoise");

	Params::EnemyPawnSensingComponent_OnOriHearNoise Parms{};

	Parms.Instigator = Instigator;
	Parms.Location = std::move(Location);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeDataManager.GetCharacterCustomizeDataManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterCustomizeDataManager*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCustomizeDataManager* UCharacterCustomizeDataManager::GetCharacterCustomizeDataManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeDataManager", "GetCharacterCustomizeDataManager");

	Params::CharacterCustomizeDataManager_GetCharacterCustomizeDataManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>*       OutAnimClass                                           (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryAnimClass(const class FName& CategoryName, const class FName& AccessoryRowName, TSubclassOf<class UAnimInstance>* OutAnimClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryAnimClass");

	Params::CharacterCustomizeDataManager_GetAccessoryAnimClass Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimClass != nullptr)
		*OutAnimClass = Parms.OutAnimClass;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryAttachToDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText*                            OutDisplayName                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryAttachToDisplayName(const class FName& RowName, class FText* OutDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryAttachToDisplayName");

	Params::CharacterCustomizeDataManager_GetAccessoryAttachToDisplayName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDisplayName != nullptr)
		*OutDisplayName = std::move(Parms.OutDisplayName);
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryAttachToList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryAttachToList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryAttachToList");

	Params::CharacterCustomizeDataManager_GetAccessoryAttachToList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryAttachToSocketInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachTargetMesh*                      OutAttachTarget                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCustomizeAttachToMoveType*    OutMoveType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryAttachToSocketInfo(const class FName& RowName, class FName* OutName, EAttachTargetMesh* OutAttachTarget, struct FTransform* OutTransform, ECharacterCustomizeAttachToMoveType* OutMoveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryAttachToSocketInfo");

	Params::CharacterCustomizeDataManager_GetAccessoryAttachToSocketInfo Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = Parms.OutName;

	if (OutAttachTarget != nullptr)
		*OutAttachTarget = Parms.OutAttachTarget;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	if (OutMoveType != nullptr)
		*OutMoveType = Parms.OutMoveType;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryCategoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryCategoryList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryCategoryList");

	Params::CharacterCustomizeDataManager_GetAccessoryCategoryList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryCategoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryCategoryThumbnail(const class FName& CategoryName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryCategoryThumbnail");

	Params::CharacterCustomizeDataManager_GetAccessoryCategoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryColorSlotNum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutSlotNum                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryColorSlotNum(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryColorSlotNum");

	Params::CharacterCustomizeDataManager_GetAccessoryColorSlotNum Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlotNum != nullptr)
		*OutSlotNum = Parms.OutSlotNum;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryCost
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCost                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryCost(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryCost");

	Params::CharacterCustomizeDataManager_GetAccessoryCost Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCost != nullptr)
		*OutCost = Parms.OutCost;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCategoryIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutAccessoryIndex                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryIndex(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutCategoryIndex, int32* OutAccessoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryIndex");

	Params::CharacterCustomizeDataManager_GetAccessoryIndex Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCategoryIndex != nullptr)
		*OutCategoryIndex = Parms.OutCategoryIndex;

	if (OutAccessoryIndex != nullptr)
		*OutAccessoryIndex = Parms.OutAccessoryIndex;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryList(const class FName& CategoryName, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryList");

	Params::CharacterCustomizeDataManager_GetAccessoryList Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryMaxCapacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCustomizeDataManager::GetAccessoryMaxCapacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryMaxCapacity");

	Params::CharacterCustomizeDataManager_GetAccessoryMaxCapacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryMesh(const class FName& CategoryName, const class FName& AccessoryRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryMesh");

	Params::CharacterCustomizeDataManager_GetAccessoryMesh Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      PresetRowName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableAccessoryPreset*OutAccessoryPreset                                     (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeDataManager::GetAccessoryPreset(const class FName& CategoryName, const class FName& PresetRowName, struct FCharacterCustomizeDataTableAccessoryPreset* OutAccessoryPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryPreset");

	Params::CharacterCustomizeDataManager_GetAccessoryPreset Parms{};

	Parms.CategoryName = CategoryName;
	Parms.PresetRowName = PresetRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAccessoryPreset != nullptr)
		*OutAccessoryPreset = std::move(Parms.OutAccessoryPreset);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetAccessoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAccessoryThumbnail(const class FName& CategoryName, const class FName& AccessoryRowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAccessoryThumbnail");

	Params::CharacterCustomizeDataManager_GetAccessoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetAppAvatarPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeAppAvatarPresetSlotInSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTablePresetDetail*OutPreset                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAppAvatarPreset(const ECharacterCustomizeGender InGender, const ECharacterCustomizeAppAvatarPresetSlot InSlot, struct FCharacterCustomizeDataTablePresetDetail* OutPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAppAvatarPreset");

	Params::CharacterCustomizeDataManager_GetAppAvatarPreset Parms{};

	Parms.InGender = InGender;
	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPreset != nullptr)
		*OutPreset = std::move(Parms.OutPreset);
}


// Function Extensions.CharacterCustomizeDataManager.GetAppAvatarPresetThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeAppAvatarPresetSlotInSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetAppAvatarPresetThumbnail(const ECharacterCustomizeGender InGender, const ECharacterCustomizeAppAvatarPresetSlot InSlot, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetAppAvatarPresetThumbnail");

	Params::CharacterCustomizeDataManager_GetAppAvatarPresetThumbnail Parms{};

	Parms.InGender = InGender;
	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetBeardForFace
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InFaceName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeBeardType      InBeardType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCharacterCustomizeDataManager::GetBeardForFace(const class FName& InFaceName, const ECharacterCustomizeBeardType InBeardType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBeardForFace");

	Params::CharacterCustomizeDataManager_GetBeardForFace Parms{};

	Parms.InFaceName = InFaceName;
	Parms.InBeardType = InBeardType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetBootsColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable7ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable7ColorPreset UCharacterCustomizeDataManager::GetBootsColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBootsColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetBootsColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetBootsColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetBootsColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBootsColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetBootsColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetBootsDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BootsName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableBootsListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableBootsList UCharacterCustomizeDataManager::GetBootsDataByRowName(const ECharacterCustomizeGender InGender, class FName BootsName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBootsDataByRowName");

	Params::CharacterCustomizeDataManager_GetBootsDataByRowName Parms{};

	Parms.InGender = InGender;
	Parms.BootsName = BootsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetBootsDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetBootsDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBootsDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetBootsDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetBootsMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      BootsRowName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetBootsMesh(const ECharacterCustomizeGender InGender, const class FName& BootsRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetBootsMesh");

	Params::CharacterCustomizeDataManager_GetBootsMesh Parms{};

	Parms.InGender = InGender;
	Parms.BootsRowName = BootsRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetColorPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableColorPaletteList*OutPalette                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetColorPalette(const class FName& PaletteRowName, struct FCharacterCustomizeDataTableColorPaletteList* OutPalette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetColorPalette");

	Params::CharacterCustomizeDataManager_GetColorPalette Parms{};

	Parms.PaletteRowName = PaletteRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPalette != nullptr)
		*OutPalette = std::move(Parms.OutPalette);
}


// Function Extensions.CharacterCustomizeDataManager.GetColorPaletteData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableColorPaletteListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableColorPaletteList UCharacterCustomizeDataManager::GetColorPaletteData(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetColorPaletteData");

	Params::CharacterCustomizeDataManager_GetColorPaletteData Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetColorPalettePack
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       PackRowName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterCustomizeDataTableColorPalettePackDetail>*OutPaletteList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetColorPalettePack(const class FName PackRowName, TArray<struct FCharacterCustomizeDataTableColorPalettePackDetail>* OutPaletteList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetColorPalettePack");

	Params::CharacterCustomizeDataManager_GetColorPalettePack Parms{};

	Parms.PackRowName = PackRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPaletteList != nullptr)
		*OutPaletteList = std::move(Parms.OutPaletteList);
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableBeardList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableBeardList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableBeardList");

	Params::CharacterCustomizeDataManager_GetDataTableBeardList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableBootsColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableBootsColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableBootsColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableBootsColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableBootsList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableBootsList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableBootsList");

	Params::CharacterCustomizeDataManager_GetDataTableBootsList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableColorPaletteList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableColorPaletteList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableColorPaletteList");

	Params::CharacterCustomizeDataManager_GetDataTableColorPaletteList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeBaseList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeBaseList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeBaseList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeBaseList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyebrowList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyebrowList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyebrowList");

	Params::CharacterCustomizeDataManager_GetDataTableEyebrowList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyebrowRaisingPatternList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyebrowRaisingPatternList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyebrowRaisingPatternList");

	Params::CharacterCustomizeDataManager_GetDataTableEyebrowRaisingPatternList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeDetailList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeDetailList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeDetailList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeDetailList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeHighLightList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeHighLightList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeHighLightList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeHighLightList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyelashList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyelashList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyelashList");

	Params::CharacterCustomizeDataManager_GetDataTableEyelashList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeMouthBalanceList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeMouthBalanceList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeMouthBalanceList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeMouthBalanceList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableEyeShapeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableEyeShapeList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableEyeShapeList");

	Params::CharacterCustomizeDataManager_GetDataTableEyeShapeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableFacePaintMaskPackList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableFacePaintMaskPackList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableFacePaintMaskPackList");

	Params::CharacterCustomizeDataManager_GetDataTableFacePaintMaskPackList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableFaceScarList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableFaceScarList(const class FName& CategoryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableFaceScarList");

	Params::CharacterCustomizeDataManager_GetDataTableFaceScarList Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableFaceTypeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableFaceTypeList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableFaceTypeList");

	Params::CharacterCustomizeDataManager_GetDataTableFaceTypeList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableGlovesColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableGlovesColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableGlovesColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableGlovesColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableGlovesList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableGlovesList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableGlovesList");

	Params::CharacterCustomizeDataManager_GetDataTableGlovesList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairBackList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairBackList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairBackList");

	Params::CharacterCustomizeDataManager_GetDataTableHairBackList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairBaseList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairBaseList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairBaseList");

	Params::CharacterCustomizeDataManager_GetDataTableHairBaseList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairColorAppendPatternList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairColorAppendPatternList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairColorAppendPatternList");

	Params::CharacterCustomizeDataManager_GetDataTableHairColorAppendPatternList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairCurlPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairCurlPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairCurlPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableHairCurlPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairFrontList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairFrontList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairFrontList");

	Params::CharacterCustomizeDataManager_GetDataTableHairFrontList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairFrontSideList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairFrontSideList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairFrontSideList");

	Params::CharacterCustomizeDataManager_GetDataTableHairFrontSideList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairOtherList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairOtherList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairOtherList");

	Params::CharacterCustomizeDataManager_GetDataTableHairOtherList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairSetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairSetList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairSetList");

	Params::CharacterCustomizeDataManager_GetDataTableHairSetList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairSideList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairSideList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairSideList");

	Params::CharacterCustomizeDataManager_GetDataTableHairSideList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairTaperPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairTaperPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairTaperPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableHairTaperPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableHairTopList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableHairTopList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableHairTopList");

	Params::CharacterCustomizeDataManager_GetDataTableHairTopList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableInnerColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableInnerColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableInnerColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableInnerColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableInnerList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableInnerList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableInnerList");

	Params::CharacterCustomizeDataManager_GetDataTableInnerList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableKintsugiList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableKintsugiList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableKintsugiList");

	Params::CharacterCustomizeDataManager_GetDataTableKintsugiList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableManicureList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableManicureList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableManicureList");

	Params::CharacterCustomizeDataManager_GetDataTableManicureList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableMaskColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableMaskColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableMaskColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableMaskColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableMaskList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableMaskList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableMaskList");

	Params::CharacterCustomizeDataManager_GetDataTableMaskList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableMouthTypeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableMouthTypeList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableMouthTypeList");

	Params::CharacterCustomizeDataManager_GetDataTableMouthTypeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableOuterColorPresetList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableOuterColorPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableOuterColorPresetList");

	Params::CharacterCustomizeDataManager_GetDataTableOuterColorPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableOuterList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableOuterList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableOuterList");

	Params::CharacterCustomizeDataManager_GetDataTableOuterList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableSpecialColorPaletteList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableSpecialColorPaletteList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableSpecialColorPaletteList");

	Params::CharacterCustomizeDataManager_GetDataTableSpecialColorPaletteList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetDataTableVoiceList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCharacterCustomizeDataManager::GetDataTableVoiceList(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetDataTableVoiceList");

	Params::CharacterCustomizeDataManager_GetDataTableVoiceList Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetEyeColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable3ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable3ColorPreset UCharacterCustomizeDataManager::GetEyeColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetEyeColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetEyeColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetEyeColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetEyeColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetEyeColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetEyeColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      PresetRowName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableFacePaintMaskPreset*OutMaskPreset                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeDataManager::GetFacePaintMaskPreset(const class FName& CategoryName, const class FName& PresetRowName, struct FCharacterCustomizeDataTableFacePaintMaskPreset* OutMaskPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskPreset");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskPreset Parms{};

	Parms.CategoryName = CategoryName;
	Parms.PresetRowName = PresetRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaskPreset != nullptr)
		*OutMaskPreset = std::move(Parms.OutMaskPreset);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTexture
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      TextureRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutTexture                                             (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTexture(const class FName& CategoryName, const class FName& TextureRowName, TSoftObjectPtr<class UTexture2D>* OutTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTexture");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTexture Parms{};

	Parms.CategoryName = CategoryName;
	Parms.TextureRowName = TextureRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = Parms.OutTexture;
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTextureCategoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTextureCategoryList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTextureCategoryList");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTextureCategoryList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTextureCategoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTextureCategoryThumbnail(const class FName& CategoryName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTextureCategoryThumbnail");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTextureCategoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTextureIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      TextureRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCategoryIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutTextureIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTextureIndex(const class FName& CategoryName, const class FName& TextureRowName, int32* OutCategoryIndex, int32* OutTextureIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTextureIndex");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTextureIndex Parms{};

	Parms.CategoryName = CategoryName;
	Parms.TextureRowName = TextureRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCategoryIndex != nullptr)
		*OutCategoryIndex = Parms.OutCategoryIndex;

	if (OutTextureIndex != nullptr)
		*OutTextureIndex = Parms.OutTextureIndex;
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTextureList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTextureList(const class FName& CategoryName, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTextureList");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTextureList Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetFacePaintMaskTextureThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      TextureRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetFacePaintMaskTextureThumbnail(const class FName& CategoryName, const class FName& TextureRowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetFacePaintMaskTextureThumbnail");

	Params::CharacterCustomizeDataManager_GetFacePaintMaskTextureThumbnail Parms{};

	Parms.CategoryName = CategoryName;
	Parms.TextureRowName = TextureRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetGlovesColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable3ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable3ColorPreset UCharacterCustomizeDataManager::GetGlovesColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetGlovesColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetGlovesColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetGlovesColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetGlovesColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetGlovesColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetGlovesColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetGlovesDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GlovesName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableGlovesListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableGlovesList UCharacterCustomizeDataManager::GetGlovesDataByRowName(const ECharacterCustomizeGender InGender, class FName GlovesName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetGlovesDataByRowName");

	Params::CharacterCustomizeDataManager_GetGlovesDataByRowName Parms{};

	Parms.InGender = InGender;
	Parms.GlovesName = GlovesName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetGlovesDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetGlovesDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetGlovesDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetGlovesDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetGlovesMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      GlovesRowName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetGlovesMesh(const ECharacterCustomizeGender InGender, const class FName& GlovesRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetGlovesMesh");

	Params::CharacterCustomizeDataManager_GetGlovesMesh Parms{};

	Parms.InGender = InGender;
	Parms.GlovesRowName = GlovesRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetInnerColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable7ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable7ColorPreset UCharacterCustomizeDataManager::GetInnerColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetInnerColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetInnerColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetInnerColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetInnerColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetInnerColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetInnerColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetInnerDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InnerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableInnerListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableInnerList UCharacterCustomizeDataManager::GetInnerDataByRowName(const ECharacterCustomizeGender InGender, class FName InnerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetInnerDataByRowName");

	Params::CharacterCustomizeDataManager_GetInnerDataByRowName Parms{};

	Parms.InGender = InGender;
	Parms.InnerName = InnerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetInnerDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetInnerDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetInnerDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetInnerDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetInnerMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InnerRowName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetInnerMesh(const ECharacterCustomizeGender InGender, const class FName& InnerRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetInnerMesh");

	Params::CharacterCustomizeDataManager_GetInnerMesh Parms{};

	Parms.InGender = InGender;
	Parms.InnerRowName = InnerRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetKintsugiRowNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetKintsugiRowNames(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetKintsugiRowNames");

	Params::CharacterCustomizeDataManager_GetKintsugiRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetKintsugiTexture
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      KintsugiRowName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutTexture                                             (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetKintsugiTexture(const class FName& KintsugiRowName, TSoftObjectPtr<class UTexture2D>* OutTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetKintsugiTexture");

	Params::CharacterCustomizeDataManager_GetKintsugiTexture Parms{};

	Parms.KintsugiRowName = KintsugiRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = Parms.OutTexture;
}


// Function Extensions.CharacterCustomizeDataManager.GetKintsugiTextureIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      KintsugiRowName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutTextureIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetKintsugiTextureIndex(const class FName& KintsugiRowName, int32* OutTextureIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetKintsugiTextureIndex");

	Params::CharacterCustomizeDataManager_GetKintsugiTextureIndex Parms{};

	Parms.KintsugiRowName = KintsugiRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTextureIndex != nullptr)
		*OutTextureIndex = Parms.OutTextureIndex;
}


// Function Extensions.CharacterCustomizeDataManager.GetKintsugiThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      KintsugiRowName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetKintsugiThumbnail(const class FName& KintsugiRowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetKintsugiThumbnail");

	Params::CharacterCustomizeDataManager_GetKintsugiThumbnail Parms{};

	Parms.KintsugiRowName = KintsugiRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetMaskColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable7ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable7ColorPreset UCharacterCustomizeDataManager::GetMaskColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetMaskColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetMaskColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetMaskColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetMaskColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetMaskColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetMaskColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetMaskDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaskName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableMaskListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableMaskList UCharacterCustomizeDataManager::GetMaskDataByRowName(const ECharacterCustomizeGender InGender, class FName MaskName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetMaskDataByRowName");

	Params::CharacterCustomizeDataManager_GetMaskDataByRowName Parms{};

	Parms.InGender = InGender;
	Parms.MaskName = MaskName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetMaskDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetMaskDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetMaskDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetMaskDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetMaskMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      MaskRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetMaskMesh(const ECharacterCustomizeGender InGender, const class FName& MaskRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetMaskMesh");

	Params::CharacterCustomizeDataManager_GetMaskMesh Parms{};

	Parms.InGender = InGender;
	Parms.MaskRowName = MaskRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetOuterColorPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTable3ColorPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTable3ColorPreset UCharacterCustomizeDataManager::GetOuterColorPresetDataByRowName(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetOuterColorPresetDataByRowName");

	Params::CharacterCustomizeDataManager_GetOuterColorPresetDataByRowName Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetOuterColorPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetOuterColorPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetOuterColorPresetDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetOuterColorPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetOuterDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OuterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableOuterListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableOuterList UCharacterCustomizeDataManager::GetOuterDataByRowName(const ECharacterCustomizeGender InGender, class FName OuterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetOuterDataByRowName");

	Params::CharacterCustomizeDataManager_GetOuterDataByRowName Parms{};

	Parms.InGender = InGender;
	Parms.OuterName = OuterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetOuterDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetOuterDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetOuterDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetOuterDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetOuterMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      OuterRowName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>*    OutMesh                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetOuterMesh(const ECharacterCustomizeGender InGender, const class FName& OuterRowName, TSoftObjectPtr<class USkeletalMesh>* OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetOuterMesh");

	Params::CharacterCustomizeDataManager_GetOuterMesh Parms{};

	Parms.InGender = InGender;
	Parms.OuterRowName = OuterRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;
}


// Function Extensions.CharacterCustomizeDataManager.GetScarCategoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarCategoryList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarCategoryList");

	Params::CharacterCustomizeDataManager_GetScarCategoryList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetScarCategoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarCategoryThumbnail(const class FName& CategoryName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarCategoryThumbnail");

	Params::CharacterCustomizeDataManager_GetScarCategoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetScarRowNameListByCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarRowNameListByCategory(const class FName& CategoryName, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarRowNameListByCategory");

	Params::CharacterCustomizeDataManager_GetScarRowNameListByCategory Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeDataManager.GetScarTexture
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ScarRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutTexture                                             (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarTexture(const class FName& CategoryName, const class FName& ScarRowName, TSoftObjectPtr<class UTexture2D>* OutTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarTexture");

	Params::CharacterCustomizeDataManager_GetScarTexture Parms{};

	Parms.CategoryName = CategoryName;
	Parms.ScarRowName = ScarRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = Parms.OutTexture;
}


// Function Extensions.CharacterCustomizeDataManager.GetScarTextureIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ScarRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCategoryIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutTextureIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarTextureIndex(const class FName& CategoryName, const class FName& ScarRowName, int32* OutCategoryIndex, int32* OutTextureIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarTextureIndex");

	Params::CharacterCustomizeDataManager_GetScarTextureIndex Parms{};

	Parms.CategoryName = CategoryName;
	Parms.ScarRowName = ScarRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCategoryIndex != nullptr)
		*OutCategoryIndex = Parms.OutCategoryIndex;

	if (OutTextureIndex != nullptr)
		*OutTextureIndex = Parms.OutTextureIndex;
}


// Function Extensions.CharacterCustomizeDataManager.GetScarThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ScarRowName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetScarThumbnail(const class FName& CategoryName, const class FName& ScarRowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetScarThumbnail");

	Params::CharacterCustomizeDataManager_GetScarThumbnail Parms{};

	Parms.CategoryName = CategoryName;
	Parms.ScarRowName = ScarRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.GetSpecialColorPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableSpecialColorPaletteList*OutPalette                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetSpecialColorPalette(const class FName& PaletteRowName, struct FCharacterCustomizeDataTableSpecialColorPaletteList* OutPalette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetSpecialColorPalette");

	Params::CharacterCustomizeDataManager_GetSpecialColorPalette Parms{};

	Parms.PaletteRowName = PaletteRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPalette != nullptr)
		*OutPalette = std::move(Parms.OutPalette);
}


// Function Extensions.CharacterCustomizeDataManager.GetSpecialColorPaletteData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableSpecialColorPaletteListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableSpecialColorPaletteList UCharacterCustomizeDataManager::GetSpecialColorPaletteData(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetSpecialColorPaletteData");

	Params::CharacterCustomizeDataManager_GetSpecialColorPaletteData Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetVoiceDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCharacterCustomizeDataManager::GetVoiceDataTableRowNames(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetVoiceDataTableRowNames");

	Params::CharacterCustomizeDataManager_GetVoiceDataTableRowNames Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeDataManager.GetVoiceThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::GetVoiceThumbnail(const ECharacterCustomizeGender InGender, const class FName& RowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "GetVoiceThumbnail");

	Params::CharacterCustomizeDataManager_GetVoiceThumbnail Parms{};

	Parms.InGender = InGender;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeDataManager.IsAccessoryTransformable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutTransformable                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeDataManager::IsAccessoryTransformable(const class FName& CategoryName, const class FName& AccessoryRowName, bool* OutTransformable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeDataManager", "IsAccessoryTransformable");

	Params::CharacterCustomizeDataManager_IsAccessoryTransformable Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransformable != nullptr)
		*OutTransformable = Parms.OutTransformable;
}


// Function Extensions.HotSpringNPCManager.OnGameStateSetEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   GameStateBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHotSpringNPCManager::OnGameStateSetEvent(class AGameStateBase* GameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HotSpringNPCManager", "OnGameStateSetEvent");

	Params::HotSpringNPCManager_OnGameStateSetEvent Parms{};

	Parms.GameStateBase = GameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NPCAIController.Activate
// (Native, Public, BlueprintCallable)

void ANPCAIController::Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "Activate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NPCAIController.Deactivate
// (Native, Public, BlueprintCallable)

void ANPCAIController::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ImpactEffectSystem.AddImpact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FImpactProperties&         InProperties                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UImpactEffectSystem::AddImpact(const struct FImpactProperties& InProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactEffectSystem", "AddImpact");

	Params::ImpactEffectSystem_AddImpact Parms{};

	Parms.InProperties = std::move(InProperties);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ImpactEffectSystem.GetSurfaceType
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InCheckStart                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InCheckEnd                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InFrom                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPhysicalSurface*                       OutSurfaceType                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImpactEffectSystem::GetSurfaceType(const struct FVector& InCheckStart, const struct FVector& InCheckEnd, class AActor* InFrom, struct FHitResult* OutHitResult, EPhysicalSurface* OutSurfaceType, bool bTraceComplex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactEffectSystem", "GetSurfaceType");

	Params::ImpactEffectSystem_GetSurfaceType Parms{};

	Parms.InCheckStart = std::move(InCheckStart);
	Parms.InCheckEnd = std::move(InCheckEnd);
	Parms.InFrom = InFrom;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	if (OutSurfaceType != nullptr)
		*OutSurfaceType = Parms.OutSurfaceType;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicCharacterAnimInstance.GetCharacterAnimParameter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterAnimParameter    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterAnimParameter UCinematicCharacterAnimInstance::GetCharacterAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicCharacterAnimInstance", "GetCharacterAnimParameter");

	Params::CinematicCharacterAnimInstance_GetCharacterAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AN_ImpactEffect.GetSurfaceTraceSocketName_BP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAN_ImpactEffect::GetSurfaceTraceSocketName_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AN_ImpactEffect", "GetSurfaceTraceSocketName_BP");

	Params::AN_ImpactEffect_GetSurfaceTraceSocketName_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AN_ImpactEffect.SetSurfaceTraceSocketName_BP
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const class FName&                      InParentSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAN_ImpactEffect::SetSurfaceTraceSocketName_BP(const class FName& InParentSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AN_ImpactEffect", "SetSurfaceTraceSocketName_BP");

	Params::AN_ImpactEffect_SetSurfaceTraceSocketName_BP Parms{};

	Parms.InParentSocketName = InParentSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyMotionWarpingComponent.GetDestination
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      InOutDestination                                       (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInConsume                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyMotionWarpingComponent::GetDestination(const class FName InName, struct FTransform* InOutDestination, const bool bInConsume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyMotionWarpingComponent", "GetDestination");

	Params::EnemyMotionWarpingComponent_GetDestination Parms{};

	Parms.InName = InName;
	Parms.bInConsume = bInConsume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InOutDestination != nullptr)
		*InOutDestination = std::move(Parms.InOutDestination);

	return Parms.ReturnValue;
}


// Function Extensions.EnemyMotionWarpingComponent.SetDestination
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InDestination                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyMotionWarpingComponent::SetDestination(const class FName InName, const struct FTransform& InDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyMotionWarpingComponent", "SetDestination");

	Params::EnemyMotionWarpingComponent_SetDestination Parms{};

	Parms.InName = InName;
	Parms.InDestination = std::move(InDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ANS_ImpactEffect.GetCheckLocationOffset_BP
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UANS_ImpactEffect::GetCheckLocationOffset_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_ImpactEffect", "GetCheckLocationOffset_BP");

	Params::ANS_ImpactEffect_GetCheckLocationOffset_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ANS_ImpactEffect.GetParentSocketName_BP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UANS_ImpactEffect::GetParentSocketName_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_ImpactEffect", "GetParentSocketName_BP");

	Params::ANS_ImpactEffect_GetParentSocketName_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ANS_ImpactEffect.SetCheckLocationOffset_BP
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FVector&                   InOffset                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_ImpactEffect::SetCheckLocationOffset_BP(const struct FVector& InOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_ImpactEffect", "SetCheckLocationOffset_BP");

	Params::ANS_ImpactEffect_SetCheckLocationOffset_BP Parms{};

	Parms.InOffset = std::move(InOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ANS_ImpactEffect.SetParentSocketName_BP
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const class FName&                      InParentSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UANS_ImpactEffect::SetParentSocketName_BP(const class FName& InParentSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_ImpactEffect", "SetParentSocketName_BP");

	Params::ANS_ImpactEffect_SetParentSocketName_BP Parms{};

	Parms.InParentSocketName = InParentSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpecialBloodSuckAbility.GetLevelSequenceTransform_BP
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AAppCharacter*              InSelfCharacter                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialBloodSuckAbility::GetLevelSequenceTransform_BP(const class AAppCharacter* InSelfCharacter, struct FTransform* OutTransform) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBloodSuckAbility", "GetLevelSequenceTransform_BP");

	Params::SpecialBloodSuckAbility_GetLevelSequenceTransform_BP Parms{};

	Parms.InSelfCharacter = InSelfCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function Extensions.SpecialBloodSuckAbility.IsCameraEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialBloodSuckAbility::IsCameraEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBloodSuckAbility", "IsCameraEnabled");

	Params::SpecialBloodSuckAbility_IsCameraEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GA_Gadget.ApplySpecialBuffs
// (Final, Native, Public, BlueprintCallable)

void UGA_Gadget::ApplySpecialBuffs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget", "ApplySpecialBuffs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Gadget.ApplySpecialBuffsByAnimNotify
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNotifyEvent&          InEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_Gadget::ApplySpecialBuffsByAnimNotify(const struct FAnimNotifyEvent& InEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget", "ApplySpecialBuffsByAnimNotify");

	Params::GA_Gadget_ApplySpecialBuffsByAnimNotify Parms{};

	Parms.InEvent = std::move(InEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Gadget.ConsumeSustainableCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInConsumeStamina                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInConsumeIchor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_Gadget::ConsumeSustainableCost(bool bInConsumeStamina, bool bInConsumeIchor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget", "ConsumeSustainableCost");

	Params::GA_Gadget_ConsumeSustainableCost Parms{};

	Parms.bInConsumeStamina = bInConsumeStamina;
	Parms.bInConsumeIchor = bInConsumeIchor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Gadget.IsSustainableAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEventData&        InEventData                                            (Parm, NativeAccessSpecifierPublic)
// bool                                    bInCheckStamina                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCheckIchor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_Gadget::IsSustainableAction(const struct FGameplayEventData& InEventData, bool bInCheckStamina, bool bInCheckIchor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget", "IsSustainableAction");

	Params::GA_Gadget_IsSustainableAction Parms{};

	Parms.InEventData = std::move(InEventData);
	Parms.bInCheckStamina = bInCheckStamina;
	Parms.bInCheckIchor = bInCheckIchor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GA_Gadget_RuneBlade.GetMainWeaponRuneBlade
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARuneBlade*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuneBlade* UGA_Gadget_RuneBlade::GetMainWeaponRuneBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget_RuneBlade", "GetMainWeaponRuneBlade");

	Params::GA_Gadget_RuneBlade_GetMainWeaponRuneBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GA_Gadget_RuneBlade.RequestIndependentAction
// (Final, Native, Private, BlueprintCallable)

void UGA_Gadget_RuneBlade::RequestIndependentAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget_RuneBlade", "RequestIndependentAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Gadget_RuneBlade.GetEquipSlot
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InAvatar                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponEquipSlot                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponEquipSlot UGA_Gadget_RuneBlade::GetEquipSlot(class AActor* InAvatar) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Gadget_RuneBlade", "GetEquipSlot");

	Params::GA_Gadget_RuneBlade_GetEquipSlot Parms{};

	Parms.InAvatar = InAvatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.EmotionPaletteEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteMenu::EmotionPaletteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "EmotionPaletteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_Center
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_Center()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_Center");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_Center Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_L1
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_L1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_L1");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_L1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_L2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_L2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_L2");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_L2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_L3
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_L3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_L3");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_L3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_L4
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_L4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_L4");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_L4 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_L5
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_L5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_L5");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_L5 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_R1
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_R1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_R1");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_R1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_R2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_R2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_R2");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_R2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_R3
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_R3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_R3");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_R3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_R4
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_R4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_R4");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_R4 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetEmotionPaletteSlot_R5
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteMenu::GetEmotionPaletteSlot_R5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetEmotionPaletteSlot_R5");

	Params::EmotionPaletteMenu_GetEmotionPaletteSlot_R5 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetRotateLeftAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UEmotionPaletteMenu::GetRotateLeftAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetRotateLeftAnimation");

	Params::EmotionPaletteMenu_GetRotateLeftAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.GetRotateRightAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UEmotionPaletteMenu::GetRotateRightAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "GetRotateRightAnimation");

	Params::EmotionPaletteMenu_GetRotateRightAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteMenu.RequestCurrentPaletteSlotEdit
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteMenu::RequestCurrentPaletteSlotEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "RequestCurrentPaletteSlotEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteMenu.RequestPlayEmotion
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteMenu::RequestPlayEmotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "RequestPlayEmotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteMenu.RequestSwitchItemPalette
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteMenu::RequestSwitchItemPalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "RequestSwitchItemPalette");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteMenu.RotateSlotLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteMenu::RotateSlotLeft(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "RotateSlotLeft");

	Params::EmotionPaletteMenu_RotateSlotLeft Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteMenu.RotateSlotRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteMenu::RotateSlotRight(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteMenu", "RotateSlotRight");

	Params::EmotionPaletteMenu_RotateSlotRight Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BodyLight.GetAttachToSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ABodyLight::GetAttachToSocketName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BodyLight", "GetAttachToSocketName");

	Params::BodyLight_GetAttachToSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AN_SpawnBullet.GetSocketName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            OutSocketName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAN_SpawnBullet::GetSocketName(class FName* OutSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AN_SpawnBullet", "GetSocketName");

	Params::AN_SpawnBullet_GetSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSocketName != nullptr)
		*OutSocketName = Parms.OutSocketName;
}


// Function Extensions.AN_SpawnBullet.SetSocketName
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAN_SpawnBullet::SetSocketName(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AN_SpawnBullet", "SetSocketName");

	Params::AN_SpawnBullet_SetSocketName Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.GetBloodVeilEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActionHumanEquipment_Vampire*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanEquipment_Vampire* UBloodSuckDeform::GetBloodVeilEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "GetBloodVeilEquipment");

	Params::BloodSuckDeform_GetBloodVeilEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.GetBloodVeilMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UBloodSuckDeform::GetBloodVeilMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "GetBloodVeilMesh");

	Params::BloodSuckDeform_GetBloodVeilMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* UBloodSuckDeform::GetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "GetCharacter");

	Params::BloodSuckDeform_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.GetCharacterMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UBloodSuckDeform::GetCharacterMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "GetCharacterMesh");

	Params::BloodSuckDeform_GetCharacterMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActionHumanCharacter*            InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActionHumanEquipment_Vampire*    InBloodVeilEquipment                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodSuckDeform::Initialize(class AActionHumanCharacter* InCharacter, class AActionHumanEquipment_Vampire* InBloodVeilEquipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "Initialize");

	Params::BloodSuckDeform_Initialize Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InBloodVeilEquipment = InBloodVeilEquipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.NotifyOnNetLocoAnimNotifyBegin
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodSuckDeform::NotifyOnNetLocoAnimNotifyBegin(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, float InTotalDuration, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "NotifyOnNetLocoAnimNotifyBegin");

	Params::BloodSuckDeform_NotifyOnNetLocoAnimNotifyBegin Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InTotalDuration = InTotalDuration;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.NotifyOnNetLocoAnimNotifyEnd
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodSuckDeform::NotifyOnNetLocoAnimNotifyEnd(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "NotifyOnNetLocoAnimNotifyEnd");

	Params::BloodSuckDeform_NotifyOnNetLocoAnimNotifyEnd Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.NotifyOnNetLocoAnimNotifyTick
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InNotifyName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMeshComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFrameDeltaTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimNotifyEventReference& InEventReference                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodSuckDeform::NotifyOnNetLocoAnimNotifyTick(const class FName InNotifyName, class USkeletalMeshComponent* InMeshComp, class UAnimSequenceBase* InAnimation, float InFrameDeltaTime, const struct FAnimNotifyEventReference& InEventReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "NotifyOnNetLocoAnimNotifyTick");

	Params::BloodSuckDeform_NotifyOnNetLocoAnimNotifyTick Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InMeshComp = InMeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InFrameDeltaTime = InFrameDeltaTime;
	Parms.InEventReference = std::move(InEventReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.OnAnimInitialized
// (Final, Native, Public)

void UBloodSuckDeform::OnAnimInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "OnAnimInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodSuckDeform.OnBloodSuckDeform_Begin
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InTypeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InPartTypeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckDeform::OnBloodSuckDeform_Begin(class FName InTypeName, class FName InPartTypeName, class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* InAnimation, float InTotalDuration, bool bFromPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "OnBloodSuckDeform_Begin");

	Params::BloodSuckDeform_OnBloodSuckDeform_Begin Parms{};

	Parms.InTypeName = InTypeName;
	Parms.InPartTypeName = InPartTypeName;
	Parms.MeshComp = MeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InTotalDuration = InTotalDuration;
	Parms.bFromPlayer = bFromPlayer;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.OnBloodSuckDeform_End
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InTypeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InPartTypeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckDeform::OnBloodSuckDeform_End(class FName InTypeName, class FName InPartTypeName, class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* InAnimation, bool bFromPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "OnBloodSuckDeform_End");

	Params::BloodSuckDeform_OnBloodSuckDeform_End Parms{};

	Parms.InTypeName = InTypeName;
	Parms.InPartTypeName = InPartTypeName;
	Parms.MeshComp = MeshComp;
	Parms.InAnimation = InAnimation;
	Parms.bFromPlayer = bFromPlayer;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.OnBloodSuckDeform_Tick
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InTypeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InPartTypeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBloodSuckDeform::OnBloodSuckDeform_Tick(class FName InTypeName, class FName InPartTypeName, class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* InAnimation, float InDeltaTime, bool bFromPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "OnBloodSuckDeform_Tick");

	Params::BloodSuckDeform_OnBloodSuckDeform_Tick Parms{};

	Parms.InTypeName = InTypeName;
	Parms.InPartTypeName = InPartTypeName;
	Parms.MeshComp = MeshComp;
	Parms.InAnimation = InAnimation;
	Parms.InDeltaTime = InDeltaTime;
	Parms.bFromPlayer = bFromPlayer;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BloodSuckDeform.OnInitialize
// (Event, Public, BlueprintEvent)

void UBloodSuckDeform::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSuckDeform", "OnInitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PatrolPointGroup.DrawPatrolRoute
// (Final, Native, Public)

void APatrolPointGroup::DrawPatrolRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PatrolPointGroup", "DrawPatrolRoute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PatrolPointGroup.OnStartPatrol
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APatrolPointGroup::OnStartPatrol(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PatrolPointGroup", "OnStartPatrol");

	Params::PatrolPointGroup_OnStartPatrol Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppAchievementsManager.NotificationAchievement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAchievementId                          AchievementId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppAchievementsManager::NotificationAchievement(class UObject* WorldContextObject, EAchievementId AchievementId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppAchievementsManager", "NotificationAchievement");

	Params::AppAchievementsManager_NotificationAchievement Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AchievementId = AchievementId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppAnimationBlueprintLibrary.CalcWeaponGearWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             DefaultValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAppAnimationBlueprintLibrary::CalcWeaponGearWeight(const class UAnimInstance* AnimInstance, class FName CurveName, const float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppAnimationBlueprintLibrary", "CalcWeaponGearWeight");

	Params::AppAnimationBlueprintLibrary_CalcWeaponGearWeight Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.CurveName = CurveName;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppAnimationBlueprintLibrary.GetBonePoseForFrameCS
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimSequenceBase*          AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Pose                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppAnimationBlueprintLibrary::GetBonePoseForFrameCS(const class UAnimSequenceBase* AnimationSequenceBase, class FName BoneName, int32 Frame, bool bExtractRootMotion, struct FTransform* Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppAnimationBlueprintLibrary", "GetBonePoseForFrameCS");

	Params::AppAnimationBlueprintLibrary_GetBonePoseForFrameCS Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneName = BoneName;
	Parms.Frame = Frame;
	Parms.bExtractRootMotion = bExtractRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Pose != nullptr)
		*Pose = std::move(Parms.Pose);
}


// Function Extensions.AppAnimationBlueprintLibrary.HasRootMotionDelta
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimSequence*              AnimSequence                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppAnimationBlueprintLibrary::HasRootMotionDelta(const class UAnimSequence* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppAnimationBlueprintLibrary", "HasRootMotionDelta");

	Params::AppAnimationBlueprintLibrary_HasRootMotionDelta Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AudioVoiceSubsystem.OnSkipSubtitles
// (Final, Native, Protected)

void UAudioVoiceSubsystem::OnSkipSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioVoiceSubsystem", "OnSkipSubtitles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AudioVoiceSubsystem.OnVoicePlay
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FOnAppAudioVoicePlayParam& Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioVoiceSubsystem::OnVoicePlay(const struct FOnAppAudioVoicePlayParam& Param, bool bPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioVoiceSubsystem", "OnVoicePlay");

	Params::AudioVoiceSubsystem_OnVoicePlay Parms{};

	Parms.Param = std::move(Param);
	Parms.bPlay = bPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.OnAfterPlayFastTravelCompleted
// (Final, Native, Public)

void UCinematicInstance::OnAfterPlayFastTravelCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "OnAfterPlayFastTravelCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.OnBeforePlayFastTravelCompleted
// (Final, Native, Public)

void UCinematicInstance::OnBeforePlayFastTravelCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "OnBeforePlayFastTravelCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.OnFinishCutScene
// (Final, Native, Public)

void UCinematicInstance::OnFinishCutScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "OnFinishCutScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.OnLoadedAsset
// (Final, Native, Public)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicInstance::OnLoadedAsset(class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "OnLoadedAsset");

	Params::CinematicInstance_OnLoadedAsset Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.OnPlayCutScene
// (Final, Native, Public)

void UCinematicInstance::OnPlayCutScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "OnPlayCutScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicInstance.GetCurrentTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQualifiedFrameTime              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UCinematicInstance::GetCurrentTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "GetCurrentTime");

	Params::CinematicInstance_GetCurrentTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicInstance.GetDuration
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQualifiedFrameTime              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UCinematicInstance::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "GetDuration");

	Params::CinematicInstance_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicInstance.GetFrameDuration
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCinematicInstance::GetFrameDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "GetFrameDuration");

	Params::CinematicInstance_GetFrameDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicInstance.GetSequenceName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCinematicInstance::GetSequenceName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "GetSequenceName");

	Params::CinematicInstance_GetSequenceName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicInstance.GetSequencePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAppLevelSequencePlayer*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppLevelSequencePlayer* UCinematicInstance::GetSequencePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicInstance", "GetSequencePlayer");

	Params::CinematicInstance_GetSequencePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppCheatManager.PlayAnimation
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             AnimationName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppCheatManager::PlayAnimation(class FName AnimationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppCheatManager", "PlayAnimation");

	Params::AppCheatManager_PlayAnimation Parms{};

	Parms.AnimationName = AnimationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicIKConditionSection.AddIKConditionKey
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FFrameNumber&              KeyTime                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAppAnimationAdjustMask                 InAdjustType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicIKConditionSection::AddIKConditionKey(const struct FFrameNumber& KeyTime, EAppAnimationAdjustMask InAdjustType, bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicIKConditionSection", "AddIKConditionKey");

	Params::CinematicIKConditionSection_AddIKConditionKey Parms{};

	Parms.KeyTime = std::move(KeyTime);
	Parms.InAdjustType = InAdjustType;
	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicIKConditionSection.GetChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCinematicIKConditionSectionChannelReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCinematicIKConditionSectionChannel UCinematicIKConditionSection::GetChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicIKConditionSection", "GetChannel");

	Params::CinematicIKConditionSection_GetChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppDamageIF.OnApplyDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FDamageMessage&            InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FDamageResult*                   OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void IAppDamageIF::OnApplyDamage(const struct FDamageMessage& InMessage, struct FDamageResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AppDamageIF", "OnApplyDamage");

	Params::AppDamageIF_OnApplyDamage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function Extensions.AppDamageIF.OnApplyDirectlyDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FDirectlyDamageMessage&    InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDamageResult*                   OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void IAppDamageIF::OnApplyDirectlyDamage(const struct FDirectlyDamageMessage& InMessage, struct FDamageResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AppDamageIF", "OnApplyDirectlyDamage");

	Params::AppDamageIF_OnApplyDirectlyDamage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function Extensions.DamageUtil.IsDestruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FObjectDestructLevelType&  InFromObject                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FObjectDestructLevelType&  InFromAttack                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageUtil::IsDestruct(const struct FObjectDestructLevelType& InFromObject, const struct FObjectDestructLevelType& InFromAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageUtil", "IsDestruct");

	Params::DamageUtil_IsDestruct Parms{};

	Parms.InFromObject = std::move(InFromObject);
	Parms.InFromAttack = std::move(InFromAttack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DamageUtil.SendDamageByAttackID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSendDamageInfoByAttackID& InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FDamageMessage*                  OutDamageMessage                                       (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FDamageResult*                   OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageUtil::SendDamageByAttackID(const struct FSendDamageInfoByAttackID& InInfo, struct FDamageMessage* OutDamageMessage, struct FDamageResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageUtil", "SendDamageByAttackID");

	Params::DamageUtil_SendDamageByAttackID Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDamageMessage != nullptr)
		*OutDamageMessage = std::move(Parms.OutDamageMessage);

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function Extensions.DamageUtil.SendDirectlyDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSendDirectlyDamageInfo&   InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageUtil::SendDirectlyDamage(const struct FSendDirectlyDamageInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageUtil", "SendDirectlyDamage");

	Params::DamageUtil_SendDirectlyDamage Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DamageUtil.SendDirectlyDamageByAttackID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSendDirectlyDamageInfoByAttackID&InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageUtil::SendDirectlyDamageByAttackID(const struct FSendDirectlyDamageInfoByAttackID& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageUtil", "SendDirectlyDamageByAttackID");

	Params::DamageUtil_SendDirectlyDamageByAttackID Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppDestructibleActor.Destruct
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAppDestructibleActorDamageInfo&InDamageInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAppDestructibleActor::Destruct(const struct FAppDestructibleActorDamageInfo& InDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "Destruct");

	Params::AppDestructibleActor_Destruct Parms{};

	Parms.InDamageInfo = std::move(InDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.ExecuteResetDestruct
// (Final, Native, Public, BlueprintCallable)

void AAppDestructibleActor::ExecuteResetDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "ExecuteResetDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.ExecuteSetDestructed
// (Final, Native, Public, BlueprintCallable)

void AAppDestructibleActor::ExecuteSetDestructed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "ExecuteSetDestructed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.OnBeginDestructTickProcess
// (Final, Native, Public, BlueprintCallable)

void AAppDestructibleActor::OnBeginDestructTickProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnBeginDestructTickProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.OnDestruct
// (Final, Native, Public, BlueprintCallable)

void AAppDestructibleActor::OnDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.OnEndDestructTickProcess
// (Final, Native, Public, BlueprintCallable)

void AAppDestructibleActor::OnEndDestructTickProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnEndDestructTickProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.OnHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAppDestructibleActorDamageInfo&InDamageInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAppDestructibleActor::OnHit(const struct FAppDestructibleActorDamageInfo& InDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnHit");

	Params::AppDestructibleActor_OnHit Parms{};

	Parms.InDamageInfo = std::move(InDamageInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.AppDestructibleActor.OnRep_ReplicatedDestructInfo
// (Final, Native, Protected)

void AAppDestructibleActor::OnRep_ReplicatedDestructInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnRep_ReplicatedDestructInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppDestructibleActor.OnResetDestruct
// (Event, Public, BlueprintEvent)

void AAppDestructibleActor::OnResetDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnResetDestruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.AppDestructibleActor.OnSetDestructed
// (Event, Public, BlueprintEvent)

void AAppDestructibleActor::OnSetDestructed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnSetDestructed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.AppDestructibleActor.OnTick_DestructStateProcess
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppDestructibleActor::OnTick_DestructStateProcess(float InDeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnTick_DestructStateProcess");

	Params::AppDestructibleActor_OnTick_DestructStateProcess Parms{};

	Parms.InDeltaSeconds = InDeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.AppDestructibleActor.OnTick_ResetDestructProcess
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppDestructibleActor::OnTick_ResetDestructProcess(float InDeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnTick_ResetDestructProcess");

	Params::AppDestructibleActor_OnTick_ResetDestructProcess Parms{};

	Parms.InDeltaSeconds = InDeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.AppDestructibleActor.OnTick_VanishStateProcess
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppDestructibleActor::OnTick_VanishStateProcess(float InDeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "OnTick_VanishStateProcess");

	Params::AppDestructibleActor_OnTick_VanishStateProcess Parms{};

	Parms.InDeltaSeconds = InDeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.AppDestructibleActor.IsDrawDebug
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppDestructibleActor::IsDrawDebug() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "IsDrawDebug");

	Params::AppDestructibleActor_IsDrawDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppDestructibleActor.IsEnableDestructAllDebug
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppDestructibleActor::IsEnableDestructAllDebug() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDestructibleActor", "IsEnableDestructAllDebug");

	Params::AppDestructibleActor_IsEnableDestructAllDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterMeshPostProcessAnimInstance.GetFacialParameter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimFacialParameter       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimFacialParameter UCharacterMeshPostProcessAnimInstance::GetFacialParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMeshPostProcessAnimInstance", "GetFacialParameter");

	Params::CharacterMeshPostProcessAnimInstance_GetFacialParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpBuffEndCondition_TimerBase.OnEndTimer
// (Final, Native, Protected)

void USpBuffEndCondition_TimerBase::OnEndTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffEndCondition_TimerBase", "OnEndTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppGameMode.SetAppGameSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAppGameSettings*                 InSettings                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppGameMode::SetAppGameSettings(class UAppGameSettings* InSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameMode", "SetAppGameSettings");

	Params::AppGameMode_SetAppGameSettings Parms{};

	Parms.InSettings = InSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppGameMode.GetAppGameSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAppGameSettings*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppGameSettings* AAppGameMode::GetAppGameSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameMode", "GetAppGameSettings");

	Params::AppGameMode_GetAppGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PettableAnimalFunctionLibrary.GetPettableAnimal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APettableAnimal*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APettableAnimal* UPettableAnimalFunctionLibrary::GetPettableAnimal(const class AActionHumanCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PettableAnimalFunctionLibrary", "GetPettableAnimal");

	Params::PettableAnimalFunctionLibrary_GetPettableAnimal Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnCanChangeWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UInventoryObject::OnCanChangeWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnCanChangeWeaponAddOnGadget");

	Params::InventoryObject_OnCanChangeWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnCheckCanEquipWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnCheckCanEquipWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const struct FUIWeaponGadgetQueryInfo& InGadgetQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnCheckCanEquipWeaponAddOnGadget");

	Params::InventoryObject_OnCheckCanEquipWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnCheckEquipedWeaponAddOnGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnCheckEquipedWeaponAddOnGadget(const struct FUIWeaponGadgetQueryInfo& InQuery, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnCheckEquipedWeaponAddOnGadget");

	Params::InventoryObject_OnCheckEquipedWeaponAddOnGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnCloseItemShortcutUI
// (Final, Native, Private)

void UInventoryObject::OnCloseItemShortcutUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnCloseItemShortcutUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnDiscardBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardBooster(const struct FUIBoosterQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardBooster");

	Params::InventoryObject_OnDiscardBooster Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardDefenceGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardDefenceGadget(const int32 InInventoryIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardDefenceGadget");

	Params::InventoryObject_OnDiscardDefenceGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIItemQueryInfo&          InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardItem(const struct FUIItemQueryInfo& InQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardItem");

	Params::InventoryObject_OnDiscardItem Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnDiscardJail
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardJail(const int32 InInventoryIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardJail");

	Params::InventoryObject_OnDiscardJail Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedBooster(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedBooster");

	Params::InventoryObject_OnDiscardRecentlyObtainedBooster Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedDefenceGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedDefenceGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedDefenceGadget");

	Params::InventoryObject_OnDiscardRecentlyObtainedDefenceGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedItem");

	Params::InventoryObject_OnDiscardRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedJail
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedJail(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedJail");

	Params::InventoryObject_OnDiscardRecentlyObtainedJail Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedStandAloneGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedStandAloneGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedStandAloneGadget");

	Params::InventoryObject_OnDiscardRecentlyObtainedStandAloneGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedWeapon(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedWeapon");

	Params::InventoryObject_OnDiscardRecentlyObtainedWeapon Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardRecentlyObtainedWeaponGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardRecentlyObtainedWeaponGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardRecentlyObtainedWeaponGadget");

	Params::InventoryObject_OnDiscardRecentlyObtainedWeaponGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardStandAloneGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardStandAloneGadget(const int32 InInventoryIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardStandAloneGadget");

	Params::InventoryObject_OnDiscardStandAloneGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardWeapon(const struct FUIWeaponQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardWeapon");

	Params::InventoryObject_OnDiscardWeapon Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnDiscardWeaponGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnDiscardWeaponGadget(const struct FUIWeaponGadgetQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnDiscardWeaponGadget");

	Params::InventoryObject_OnDiscardWeaponGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.InventoryObject.OnEquipedArticleIndexGetByMainCategoryRequestForShop
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnEquipedArticleIndexGetByMainCategoryRequestForShop(const EUIMainCategory InCategory, TArray<int32>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnEquipedArticleIndexGetByMainCategoryRequestForShop");

	Params::InventoryObject_OnEquipedArticleIndexGetByMainCategoryRequestForShop Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);
}


// Function Extensions.InventoryObject.OnEquipedArticleIndexGetByMainCategoryRequestForStorage
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnEquipedArticleIndexGetByMainCategoryRequestForStorage(const EUIMainCategory InCategory, TArray<int32>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnEquipedArticleIndexGetByMainCategoryRequestForStorage");

	Params::InventoryObject_OnEquipedArticleIndexGetByMainCategoryRequestForStorage Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);
}


// Function Extensions.InventoryObject.OnEquipItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIItemShortcutSlot               InItemSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnEquipItem(const EUIItemShortcutSlot InItemSlot, const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnEquipItem");

	Params::InventoryObject_OnEquipItem Parms{};

	Parms.InItemSlot = InItemSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnEquipItemPalette
// (Final, Native, Private)
// Parameters:
// const EUIItemPaletteSlot                InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnEquipItemPalette(const EUIItemPaletteSlot InSlot, const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnEquipItemPalette");

	Params::InventoryObject_OnEquipItemPalette Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnGetBloodCodeInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetBloodCodeInfo(const int32 InInventoryIndex, struct FUIBloodCodeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetBloodCodeInfo");

	Params::InventoryObject_OnGetBloodCodeInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetBoosterInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetBoosterInfo(const struct FUIBoosterQueryInfo& InQuery, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetBoosterInfo");

	Params::InventoryObject_OnGetBoosterInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetDefaultWeaponAddOnGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetDefaultWeaponAddOnGadgetInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetDefaultWeaponAddOnGadgetInfo");

	Params::InventoryObject_OnGetDefaultWeaponAddOnGadgetInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetDefenceGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetDefenceGadgetInfo(const int32 InInventoryIndex, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetDefenceGadgetInfo");

	Params::InventoryObject_OnGetDefenceGadgetInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetDefenceGadgetTransformNum
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryObject::OnGetDefenceGadgetTransformNum(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetDefenceGadgetTransformNum");

	Params::InventoryObject_OnGetDefenceGadgetTransformNum Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetDefenceGadgetTransformUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetDefenceGadgetTransformUIInfo(const int32 InInventoryIndex, const int32 InTransformIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetDefenceGadgetTransformUIInfo");

	Params::InventoryObject_OnGetDefenceGadgetTransformUIInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetDefenceTransformAfterUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetDefenceTransformAfterUIInfo(const int32 InInventoryIndex, const int32 InTransformIndex, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetDefenceTransformAfterUIInfo");

	Params::InventoryObject_OnGetDefenceTransformAfterUIInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetEnhanceableJailInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetEnhanceableJailInfo(const int32 InInventoryIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableJailInfo");

	Params::InventoryObject_OnGetEnhanceableJailInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetEnhanceableJailNum
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetEnhanceableJailNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableJailNum");

	Params::InventoryObject_OnGetEnhanceableJailNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetEnhanceableStandAloneGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetEnhanceableStandAloneGadgetInfo(const int32 InInventoryIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableStandAloneGadgetInfo");

	Params::InventoryObject_OnGetEnhanceableStandAloneGadgetInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetEnhanceableStandAloneGadgetNum
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetEnhanceableStandAloneGadgetNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableStandAloneGadgetNum");

	Params::InventoryObject_OnGetEnhanceableStandAloneGadgetNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetEnhanceableWeaponInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetEnhanceableWeaponInfo(const struct FUIWeaponQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableWeaponInfo");

	Params::InventoryObject_OnGetEnhanceableWeaponInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetEnhanceableWeaponNum
// (Final, Native, Private)
// Parameters:
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetEnhanceableWeaponNum(const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEnhanceableWeaponNum");

	Params::InventoryObject_OnGetEnhanceableWeaponNum Parms{};

	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetEquipItemIndex
// (Final, Native, Private)
// Parameters:
// const EUIItemShortcutSlot               InItemSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetEquipItemIndex(const EUIItemShortcutSlot InItemSlot, const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEquipItemIndex");

	Params::InventoryObject_OnGetEquipItemIndex Parms{};

	Parms.InItemSlot = InItemSlot;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetEquipItemInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetEquipItemInfo(const struct FUIEquippableItemQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEquipItemInfo");

	Params::InventoryObject_OnGetEquipItemInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetEquipItemNumber
// (Final, Native, Private)
// Parameters:
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetEquipItemNumber(const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEquipItemNumber");

	Params::InventoryObject_OnGetEquipItemNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetEquipWeaponAddOnGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnGetEquipWeaponAddOnGadgetInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetEquipWeaponAddOnGadgetInfo");

	Params::InventoryObject_OnGetEquipWeaponAddOnGadgetInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetInventoryArticleUIInfo(const struct FUIArticleQueryInfo& InArticleQuery, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryArticleUIInfo");

	Params::InventoryObject_OnGetInventoryArticleUIInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetInventoryBloodCodeNumber
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryBloodCodeNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryBloodCodeNumber");

	Params::InventoryObject_OnGetInventoryBloodCodeNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryBoosterNumber
// (Final, Native, Private)
// Parameters:
// const EUIBoosterCategory                InBoosterCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryBoosterNumber(const EUIBoosterCategory InBoosterCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryBoosterNumber");

	Params::InventoryObject_OnGetInventoryBoosterNumber Parms{};

	Parms.InBoosterCategory = InBoosterCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryDefenceGadgetNumber
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryDefenceGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryDefenceGadgetNumber");

	Params::InventoryObject_OnGetInventoryDefenceGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryIndexOfItemPaletteEquipped
// (Final, Native, Private)
// Parameters:
// const EUIItemPaletteSlot                InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIExpendableItemCategory         InUICategory                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryIndexOfItemPaletteEquipped(const EUIItemPaletteSlot InUISlot, const EUIExpendableItemCategory InUICategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryIndexOfItemPaletteEquipped");

	Params::InventoryObject_OnGetInventoryIndexOfItemPaletteEquipped Parms{};

	Parms.InUISlot = InUISlot;
	Parms.InUICategory = InUICategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryJailNum
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryJailNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryJailNum");

	Params::InventoryObject_OnGetInventoryJailNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryNum
// (Final, Native, Private)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryNum(const EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryNum");

	Params::InventoryObject_OnGetInventoryNum Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryStandAloneGadgetNumber
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryStandAloneGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryStandAloneGadgetNumber");

	Params::InventoryObject_OnGetInventoryStandAloneGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryWeaponAddOnGadgetNum
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetCategory           InGadgetCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryWeaponAddOnGadgetNum(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetCategory InGadgetCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryWeaponAddOnGadgetNum");

	Params::InventoryObject_OnGetInventoryWeaponAddOnGadgetNum Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetCategory = InGadgetCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetInventoryWeaponNum
// (Final, Native, Private)
// Parameters:
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetInventoryWeaponNum(const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetInventoryWeaponNum");

	Params::InventoryObject_OnGetInventoryWeaponNum Parms{};

	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetItemInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIItemQueryInfo&          InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetItemInfo(const struct FUIItemQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetItemInfo");

	Params::InventoryObject_OnGetItemInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetItemNumber
// (Final, Native, Private)
// Parameters:
// const EUIItemCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetItemNumber(const EUIItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetItemNumber");

	Params::InventoryObject_OnGetItemNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetJailEnhancedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetJailEnhancedInfo(const int32 InInventoryIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetJailEnhancedInfo");

	Params::InventoryObject_OnGetJailEnhancedInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetJailInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetJailInfo(const int32 InInventoryIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetJailInfo");

	Params::InventoryObject_OnGetJailInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetJailLevelUpInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetJailLevelUpInfo(const int32 InInventoryIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetJailLevelUpInfo");

	Params::InventoryObject_OnGetJailLevelUpInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedBloodCodeInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedBloodCodeInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIBloodCodeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedBloodCodeInfo");

	Params::InventoryObject_OnGetRecentlyObtainedBloodCodeInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedBoosterInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedBoosterInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedBoosterInfo");

	Params::InventoryObject_OnGetRecentlyObtainedBoosterInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedDefenceGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedDefenceGadgetInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedDefenceGadgetInfo");

	Params::InventoryObject_OnGetRecentlyObtainedDefenceGadgetInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIRecentlyObtainedInfo*         OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedInfo(const struct FUIArticleQueryInfo& InQuery, struct FUIRecentlyObtainedInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedInfo");

	Params::InventoryObject_OnGetRecentlyObtainedInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedItemInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedItemInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedItemInfo");

	Params::InventoryObject_OnGetRecentlyObtainedItemInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedJailInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedJailInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedJailInfo");

	Params::InventoryObject_OnGetRecentlyObtainedJailInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedNum
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetRecentlyObtainedNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedNum");

	Params::InventoryObject_OnGetRecentlyObtainedNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedStandAloneGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedStandAloneGadgetInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedStandAloneGadgetInfo");

	Params::InventoryObject_OnGetRecentlyObtainedStandAloneGadgetInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedWeaponGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedWeaponGadgetInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedWeaponGadgetInfo");

	Params::InventoryObject_OnGetRecentlyObtainedWeaponGadgetInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetRecentlyObtainedWeaponInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InArticleQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetRecentlyObtainedWeaponInfo(const struct FUIRecentlyObtainedQueryInfo& InArticleQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetRecentlyObtainedWeaponInfo");

	Params::InventoryObject_OnGetRecentlyObtainedWeaponInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetStandAloneGadgetEnhancedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetStandAloneGadgetEnhancedInfo(const int32 InInventoryIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetStandAloneGadgetEnhancedInfo");

	Params::InventoryObject_OnGetStandAloneGadgetEnhancedInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetStandAloneGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetStandAloneGadgetInfo(const int32 InInventoryIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetStandAloneGadgetInfo");

	Params::InventoryObject_OnGetStandAloneGadgetInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetStandAloneGadgetLevelUpInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetStandAloneGadgetLevelUpInfo(const int32 InInventoryIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetStandAloneGadgetLevelUpInfo");

	Params::InventoryObject_OnGetStandAloneGadgetLevelUpInfo Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetStorageArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetStorageArticleUIInfo(const struct FUIArticleQueryInfo& InArticleQuery, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetStorageArticleUIInfo");

	Params::InventoryObject_OnGetStorageArticleUIInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetStorageNum
// (Final, Native, Private)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UInventoryObject::OnGetStorageNum(const EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetStorageNum");

	Params::InventoryObject_OnGetStorageNum Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetWeaponAddOnGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponAddOnGadgetInfo(const struct FUIWeaponGadgetQueryInfo& InQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponAddOnGadgetInfo");

	Params::InventoryObject_OnGetWeaponAddOnGadgetInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetWeaponEnhancedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponEnhancedInfo(const struct FUIWeaponQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponEnhancedInfo");

	Params::InventoryObject_OnGetWeaponEnhancedInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetWeaponInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponInfo(const struct FUIWeaponQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponInfo");

	Params::InventoryObject_OnGetWeaponInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetWeaponLevelUpInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponLevelUpInfo(const struct FUIWeaponQueryInfo& InQuery, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponLevelUpInfo");

	Params::InventoryObject_OnGetWeaponLevelUpInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetWeaponTransformAfterUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponTransformAfterUIInfo(const struct FUIWeaponQueryInfo& InQuery, const int32 InTransformIndex, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponTransformAfterUIInfo");

	Params::InventoryObject_OnGetWeaponTransformAfterUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnGetWeaponTransformNum
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryObject::OnGetWeaponTransformNum(const struct FUIWeaponQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponTransformNum");

	Params::InventoryObject_OnGetWeaponTransformNum Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnGetWeaponTransformUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventoryObject::OnGetWeaponTransformUIInfo(const struct FUIWeaponQueryInfo& InQuery, const int32 InTransformIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnGetWeaponTransformUIInfo");

	Params::InventoryObject_OnGetWeaponTransformUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.InventoryObject.OnHasDefaultWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnHasDefaultWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnHasDefaultWeaponAddOnGadget");

	Params::InventoryObject_OnHasDefaultWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnIsUsableItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIItemQueryInfo&          InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnIsUsableItem(const struct FUIItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnIsUsableItem");

	Params::InventoryObject_OnIsUsableItem Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnIsUsableItemPallet
// (Final, Native, Private)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnIsUsableItemPallet(const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnIsUsableItemPallet");

	Params::InventoryObject_OnIsUsableItemPallet Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnIsUsableRecentlyObtainedItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnIsUsableRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnIsUsableRecentlyObtainedItem");

	Params::InventoryObject_OnIsUsableRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnMoveToInventory
// (Final, Native, Private)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnMoveToInventory(const struct FUIArticleQueryInfo& InArticleQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnMoveToInventory");

	Params::InventoryObject_OnMoveToInventory Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnMoveToStorage
// (Final, Native, Private)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnMoveToStorage(const struct FUIArticleQueryInfo& InArticleQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnMoveToStorage");

	Params::InventoryObject_OnMoveToStorage Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnOpenItemShortcutUI
// (Final, Native, Private)

void UInventoryObject::OnOpenItemShortcutUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnOpenItemShortcutUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnPlayerSetup
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FPlayerEvent&              InEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryObject::OnPlayerSetup(const struct FPlayerEvent& InEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnPlayerSetup");

	Params::InventoryObject_OnPlayerSetup Parms{};

	Parms.InEvent = std::move(InEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnRequestDefenceGadgetTransform
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnRequestDefenceGadgetTransform(const int32 InInventoryIndex, const int32 InTransformIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnRequestDefenceGadgetTransform");

	Params::InventoryObject_OnRequestDefenceGadgetTransform Parms{};

	Parms.InInventoryIndex = InInventoryIndex;
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnRequestJailLevelUp
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnRequestJailLevelUp(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnRequestJailLevelUp");

	Params::InventoryObject_OnRequestJailLevelUp Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnRequestStandAloneGadgetLevelUp
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnRequestStandAloneGadgetLevelUp(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnRequestStandAloneGadgetLevelUp");

	Params::InventoryObject_OnRequestStandAloneGadgetLevelUp Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnRequestWeaponLevelUp
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnRequestWeaponLevelUp(const struct FUIWeaponQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnRequestWeaponLevelUp");

	Params::InventoryObject_OnRequestWeaponLevelUp Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnRequestWeaponTransform
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InTransformIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnRequestWeaponTransform(const struct FUIWeaponQueryInfo& InQuery, const int32 InTransformIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnRequestWeaponTransform");

	Params::InventoryObject_OnRequestWeaponTransform Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InTransformIndex = InTransformIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnToggleAutoReplenishByInventory
// (Final, Native, Private)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnToggleAutoReplenishByInventory(const struct FUIArticleQueryInfo& InArticleQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnToggleAutoReplenishByInventory");

	Params::InventoryObject_OnToggleAutoReplenishByInventory Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnToggleAutoReplenishByStorage
// (Final, Native, Private)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnToggleAutoReplenishByStorage(const struct FUIArticleQueryInfo& InArticleQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnToggleAutoReplenishByStorage");

	Params::InventoryObject_OnToggleAutoReplenishByStorage Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnUnequipItem
// (Final, Native, Private)
// Parameters:
// const EUIItemShortcutSlot               InItemSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnUnequipItem(const EUIItemShortcutSlot InItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUnequipItem");

	Params::InventoryObject_OnUnequipItem Parms{};

	Parms.InItemSlot = InItemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnUnequipItemPalette
// (Final, Native, Private)
// Parameters:
// const EUIItemPaletteSlot                InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryObject::OnUnequipItemPalette(const EUIItemPaletteSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUnequipItemPalette");

	Params::InventoryObject_OnUnequipItemPalette Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryObject.OnUseItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIItemQueryInfo&          InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnUseItem(const struct FUIItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUseItem");

	Params::InventoryObject_OnUseItem Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnUseItemByItemPalette
// (Final, Native, Private)
// Parameters:
// const EUIItemPaletteSlot                InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnUseItemByItemPalette(const EUIItemPaletteSlot InUISlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUseItemByItemPalette");

	Params::InventoryObject_OnUseItemByItemPalette Parms{};

	Parms.InUISlot = InUISlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnUseItemStack
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIItemQueryInfo&          InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InUseCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnUseItemStack(const struct FUIItemQueryInfo& InQuery, const int32 InUseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUseItemStack");

	Params::InventoryObject_OnUseItemStack Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InUseCount = InUseCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryObject.OnUseRecentlyObtainedItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InUseCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryObject::OnUseRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery, const int32 InUseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryObject", "OnUseRecentlyObtainedItem");

	Params::InventoryObject_OnUseRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InUseCount = InUseCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppGameState.SetInDreamWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInEnable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppGameState::SetInDreamWorld(const class UObject* InWorldContextObject, const bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppGameState", "SetInDreamWorld");

	Params::AppGameState_SetInDreamWorld Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppGameState.SetInMuseumField
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInEnable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppGameState::SetInMuseumField(const class UObject* InWorldContextObject, const bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppGameState", "SetInMuseumField");

	Params::AppGameState_SetInMuseumField Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppGameState.IsCutScenePlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppGameState::IsCutScenePlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameState", "IsCutScenePlaying");

	Params::AppGameState_IsCutScenePlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppGameState.SetGameFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInEnable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppGameState::SetGameFlag(const struct FGameplayTag& InTag, const bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameState", "SetGameFlag");

	Params::AppGameState_SetGameFlag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppLevelSequenceActor.OnPlay
// (Final, Native, Protected)

void AAppLevelSequenceActor::OnPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppLevelSequenceActor", "OnPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppLevelSequenceActor.OnStop
// (Final, Native, Protected)

void AAppLevelSequenceActor::OnStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppLevelSequenceActor", "OnStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Furniture.CancelLookAtOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UAimOffsetBlendSpace*       InAimOffset                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_Furniture::CancelLookAtOverride(const class UAimOffsetBlendSpace* InAimOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Furniture", "CancelLookAtOverride");

	Params::GA_Furniture_CancelLookAtOverride Parms{};

	Parms.InAimOffset = InAimOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GA_Furniture.SetLookAtOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UAimOffsetBlendSpace*       InAimOffset                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_Furniture::SetLookAtOverride(const class UAimOffsetBlendSpace* InAimOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Furniture", "SetLookAtOverride");

	Params::GA_Furniture_SetLookAtOverride Parms{};

	Parms.InAimOffset = InAimOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppNavLinkProxy.OnLinkReached
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           MovingActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DestinationPoint                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppNavLinkProxy::OnLinkReached(class AActor* MovingActor, const struct FVector& DestinationPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppNavLinkProxy", "OnLinkReached");

	Params::AppNavLinkProxy_OnLinkReached Parms{};

	Parms.MovingActor = MovingActor;
	Parms.DestinationPoint = std::move(DestinationPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppNiagaraFunctionLibrary.ANF_NiagaraComponent_GetParticleCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppNiagaraFunctionLibrary::ANF_NiagaraComponent_GetParticleCount(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppNiagaraFunctionLibrary", "ANF_NiagaraComponent_GetParticleCount");

	Params::AppNiagaraFunctionLibrary_ANF_NiagaraComponent_GetParticleCount Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppPackedLevelActorInterface.GetFootIKTraceHeightOffset
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IAppPackedLevelActorInterface::GetFootIKTraceHeightOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AppPackedLevelActorInterface", "GetFootIKTraceHeightOffset");

	Params::AppPackedLevelActorInterface_GetFootIKTraceHeightOffset Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.AppPlayerController.GetAssignKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionTag&           InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInIsGamePad                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FKey>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FKey> AAppPlayerController::GetAssignKeys(const class UObject* InWorldContext, const struct FInputActionTag& InTag, const bool bInIsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppPlayerController", "GetAssignKeys");

	Params::AppPlayerController_GetAssignKeys Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTag = std::move(InTag);
	Parms.bInIsGamePad = bInIsGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppPlayerController.GetController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAppPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAppPlayerController* AAppPlayerController::GetController(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppPlayerController", "GetController");

	Params::AppPlayerController_GetController Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppPlayerController.GetPlayerInputType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerInputType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerInputType AAppPlayerController::GetPlayerInputType(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppPlayerController", "GetPlayerInputType");

	Params::AppPlayerController_GetPlayerInputType Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppPlayerController.SetPlayerInputType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPlayerInputType                  InPlayerInputType                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetPlayerInputType(const class UObject* InWorldContext, const EPlayerInputType InPlayerInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppPlayerController", "SetPlayerInputType");

	Params::AppPlayerController_SetPlayerInputType Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InPlayerInputType = InPlayerInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.FlushPlayerInput
// (Final, Native, Public, BlueprintCallable)

void AAppPlayerController::FlushPlayerInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "FlushPlayerInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.PlayForceFeedback
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InID                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInLooping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::PlayForceFeedback(const class FName& InID, bool bInLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "PlayForceFeedback");

	Params::AppPlayerController_PlayForceFeedback Parms{};

	Parms.InID = InID;
	Parms.bInLooping = bInLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.RegisterGameInputMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InRequestor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGameInputMode                    InMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::RegisterGameInputMode(const class UObject* InRequestor, const EGameInputMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "RegisterGameInputMode");

	Params::AppPlayerController_RegisterGameInputMode Parms{};

	Parms.InRequestor = InRequestor;
	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.SetForceFeedbackEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetForceFeedbackEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "SetForceFeedbackEnabled");

	Params::AppPlayerController_SetForceFeedbackEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.SetGameInputModeAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EGameInputMode                    InMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGameInputAttribute               InAttribute                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetGameInputModeAttribute(const EGameInputMode InMode, const EGameInputAttribute InAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "SetGameInputModeAttribute");

	Params::AppPlayerController_SetGameInputModeAttribute Parms{};

	Parms.InMode = InMode;
	Parms.InAttribute = InAttribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.SetOverrideGameInputAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EGameInputMode                    InMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGameInputAttribute               InAttribute                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetOverrideGameInputAttribute(const EGameInputMode InMode, const EGameInputAttribute InAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "SetOverrideGameInputAttribute");

	Params::AppPlayerController_SetOverrideGameInputAttribute Parms{};

	Parms.InMode = InMode;
	Parms.InAttribute = InAttribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.StopForceFeedback
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InID                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::StopForceFeedback(const class FName& InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "StopForceFeedback");

	Params::AppPlayerController_StopForceFeedback Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.UnregisterGameInputMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InRequestor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::UnregisterGameInputMode(const class UObject* InRequestor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "UnregisterGameInputMode");

	Params::AppPlayerController_UnregisterGameInputMode Parms{};

	Parms.InRequestor = InRequestor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppPlayerController.GetGameInputMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameInputMode                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameInputMode AAppPlayerController::GetGameInputMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "GetGameInputMode");

	Params::AppPlayerController_GetGameInputMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppPlayerController.GetGameInputModeAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EGameInputMode                    InMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameInputAttribute*                    ResultAttribute                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppPlayerController::GetGameInputModeAttribute(const EGameInputMode InMode, EGameInputAttribute* ResultAttribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "GetGameInputModeAttribute");

	Params::AppPlayerController_GetGameInputModeAttribute Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultAttribute != nullptr)
		*ResultAttribute = Parms.ResultAttribute;

	return Parms.ReturnValue;
}


// Function Extensions.PressurePlate.OnRep_bReplicatedPressed
// (Final, Native, Protected)

void APressurePlate::OnRep_bReplicatedPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PressurePlate", "OnRep_bReplicatedPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppSessionProxy.Ack_ClientBreakUpReason
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppSessionProxy::Ack_ClientBreakUpReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppSessionProxy", "Ack_ClientBreakUpReason");

	Params::AppSessionProxy_Ack_ClientBreakUpReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppSessionProxy.Ack_ServerBreakUpReason
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppSessionProxy::Ack_ServerBreakUpReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppSessionProxy", "Ack_ServerBreakUpReason");

	Params::AppSessionProxy_Ack_ServerBreakUpReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppSessionProxy.ClientBreakUpReason
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppSessionProxy::ClientBreakUpReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppSessionProxy", "ClientBreakUpReason");

	Params::AppSessionProxy_ClientBreakUpReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppSessionProxy.ServerBreakUpReason
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// ESessionBreakUpReason                   InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppSessionProxy::ServerBreakUpReason(ESessionBreakUpReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppSessionProxy", "ServerBreakUpReason");

	Params::AppSessionProxy_ServerBreakUpReason Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BTTask_NPCTurnTo.OnFinishTurn
// (Final, Native, Protected)

void UBTTask_NPCTurnTo::OnFinishTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_NPCTurnTo", "OnFinishTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppUIManager.IsSameStatusEffectIconHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStatusEffectIconHandle&   InHandle1                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FStatusEffectIconHandle&   InHandle2                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsSameStatusEffectIconHandle(const struct FStatusEffectIconHandle& InHandle1, const struct FStatusEffectIconHandle& InHandle2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppUIManager", "IsSameStatusEffectIconHandle");

	Params::AppUIManager_IsSameStatusEffectIconHandle Parms{};

	Parms.InHandle1 = std::move(InHandle1);
	Parms.InHandle2 = std::move(InHandle2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.AddMovableHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EMovableHudType                   InHudType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPriorityOffset                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InInitialVisibility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovableHudHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovableHudHandle UAppUIManager::AddMovableHud(const EMovableHudType InHudType, const int32 InPriorityOffset, bool InInitialVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "AddMovableHud");

	Params::AppUIManager_AddMovableHud Parms{};

	Parms.InHudType = InHudType;
	Parms.InPriorityOffset = InPriorityOffset;
	Parms.InInitialVisibility = InInitialVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.CanOpenMapMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::CanOpenMapMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "CanOpenMapMenu");

	Params::AppUIManager_CanOpenMapMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.CloseAnyForceClosableUI
// (Final, Native, Public, BlueprintCallable)

void UAppUIManager::CloseAnyForceClosableUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "CloseAnyForceClosableUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppUIManager.CreateUIElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUIElementBase>       InElementClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InElementName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InGroupName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InDisplayPriority                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InInitialVisibility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIElementBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIElementBase* UAppUIManager::CreateUIElement(TSubclassOf<class UUIElementBase> InElementClass, const class FName InElementName, const class FName InGroupName, const int32 InDisplayPriority, bool InInitialVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "CreateUIElement");

	Params::AppUIManager_CreateUIElement Parms{};

	Parms.InElementClass = InElementClass;
	Parms.InElementName = InElementName;
	Parms.InGroupName = InGroupName;
	Parms.InDisplayPriority = InDisplayPriority;
	Parms.InInitialVisibility = InInitialVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetAccumulateGaugeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAccumulateGaugeInfo*            OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UAppUIManager::GetAccumulateGaugeInfo(const struct FGameplayTag& InTag, struct FAccumulateGaugeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetAccumulateGaugeInfo");

	Params::AppUIManager_GetAccumulateGaugeInfo Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.AppUIManager.GetMovableHud
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UUIElementBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIElementBase* UAppUIManager::GetMovableHud(const struct FMovableHudHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetMovableHud");

	Params::AppUIManager_GetMovableHud Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetStatusDownEffectIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EStatusDownEffectIconType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAppUIManager::GetStatusDownEffectIcon(const EStatusDownEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetStatusDownEffectIcon");

	Params::AppUIManager_GetStatusDownEffectIcon Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetStatusUpEffectIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EStatusUpEffectIconType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAppUIManager::GetStatusUpEffectIcon(const EStatusUpEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetStatusUpEffectIcon");

	Params::AppUIManager_GetStatusUpEffectIcon Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetStatusUpEffectIconEx
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EStatusUpEffectIconTypeEx         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAppUIManager::GetStatusUpEffectIconEx(const EStatusUpEffectIconTypeEx InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetStatusUpEffectIconEx");

	Params::AppUIManager_GetStatusUpEffectIconEx Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsAnyForceClosableUIVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsAnyForceClosableUIVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsAnyForceClosableUIVisible");

	Params::AppUIManager_IsAnyForceClosableUIVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsBuddyHUDForcedShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsBuddyHUDForcedShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsBuddyHUDForcedShow");

	Params::AppUIManager_IsBuddyHUDForcedShow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsGameMenuOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsGameMenuOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsGameMenuOpen");

	Params::AppUIManager_IsGameMenuOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsHUDAutoHideEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsHUDAutoHideEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsHUDAutoHideEnabled");

	Params::AppUIManager_IsHUDAutoHideEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsInBattle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsInBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsInBattle");

	Params::AppUIManager_IsInBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.IsVisibleEnemyBloodAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::IsVisibleEnemyBloodAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "IsVisibleEnemyBloodAmount");

	Params::AppUIManager_IsVisibleEnemyBloodAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.MakeStatusEffectIconHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UAppUIManager::MakeStatusEffectIconHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "MakeStatusEffectIconHandle");

	Params::AppUIManager_MakeStatusEffectIconHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.NotifyBleedingAttackSucceeded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::NotifyBleedingAttackSucceeded(const struct FMovableHudHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "NotifyBleedingAttackSucceeded");

	Params::AppUIManager_NotifyBleedingAttackSucceeded Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.OnGameViewportCreated
// (Final, Native, Protected)

void UAppUIManager::OnGameViewportCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "OnGameViewportCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppUIManager.OpenSystemDialog
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESystemDialogType                 InDialogType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDialogInfo&               InDialogInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(uint8 DecideOptionNumber)>InDecideDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InDefaultSelectOption                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::OpenSystemDialog(const ESystemDialogType InDialogType, const struct FDialogInfo& InDialogInfo, TDelegate<void(uint8 DecideOptionNumber)> InDecideDelegate, const uint8 InDefaultSelectOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "OpenSystemDialog");

	Params::AppUIManager_OpenSystemDialog Parms{};

	Parms.InDialogType = InDialogType;
	Parms.InDialogInfo = std::move(InDialogInfo);
	Parms.InDecideDelegate = InDecideDelegate;
	Parms.InDefaultSelectOption = InDefaultSelectOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.PlayUIAudioEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    InAudioEvent                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::PlayUIAudioEvent(class UObject* WorldContextObject, class UAkAudioEvent* InAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "PlayUIAudioEvent");

	Params::AppUIManager_PlayUIAudioEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InAudioEvent = InAudioEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.RemoveMovableHud
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::RemoveMovableHud(const struct FMovableHudHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "RemoveMovableHud");

	Params::AppUIManager_RemoveMovableHud Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.RemoveUIElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       InElementName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::RemoveUIElement(const class FName InElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "RemoveUIElement");

	Params::AppUIManager_RemoveUIElement Parms{};

	Parms.InElementName = InElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.RemoveUIElementGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       InGroupName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::RemoveUIElementGroup(const class FName InGroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "RemoveUIElementGroup");

	Params::AppUIManager_RemoveUIElementGroup Parms{};

	Parms.InGroupName = InGroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetGameMenuFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppUIManager::SetGameMenuFlag(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetGameMenuFlag");

	Params::AppUIManager_SetGameMenuFlag Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppUIManager.SetMovableHudAccumulateStateValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudAccumulateStateValue(const struct FMovableHudHandle& InHandle, const struct FGameplayTag& InEffectTag, const struct FAccumulateAttributeUIInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudAccumulateStateValue");

	Params::AppUIManager_SetMovableHudAccumulateStateValue Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudBloodAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InBloodAmount                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBloodAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InFactor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudBloodAmount(const struct FMovableHudHandle& InHandle, const float InBloodAmount, const float InMaxBloodAmount, const EResourceChangeFactor InFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudBloodAmount");

	Params::AppUIManager_SetMovableHudBloodAmount Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InBloodAmount = InBloodAmount;
	Parms.InMaxBloodAmount = InMaxBloodAmount;
	Parms.InFactor = InFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InHealth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InRecoverableHealth                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InFactor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudHealth(const struct FMovableHudHandle& InHandle, const float InHealth, const float InMaxHealth, const float InRecoverableHealth, const EResourceChangeFactor InFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudHealth");

	Params::AppUIManager_SetMovableHudHealth Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InHealth = InHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InRecoverableHealth = InRecoverableHealth;
	Parms.InFactor = InFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   InTargetPosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudPosition(const struct FMovableHudHandle& InHandle, const struct FVector& InTargetPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudPosition");

	Params::AppUIManager_SetMovableHudPosition Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InTargetPosition = std::move(InTargetPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudStatusDownEffectApplied
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHudHandle                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EStatusDownEffectIconType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UAppUIManager::SetMovableHudStatusDownEffectApplied(const struct FMovableHudHandle& InHudHandle, const EStatusDownEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudStatusDownEffectApplied");

	Params::AppUIManager_SetMovableHudStatusDownEffectApplied Parms{};

	Parms.InHudHandle = std::move(InHudHandle);
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudStatusEffectRemoved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHudHandle                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FStatusEffectIconHandle&   InIconHandle                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudStatusEffectRemoved(const struct FMovableHudHandle& InHudHandle, const struct FStatusEffectIconHandle& InIconHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudStatusEffectRemoved");

	Params::AppUIManager_SetMovableHudStatusEffectRemoved Parms{};

	Parms.InHudHandle = std::move(InHudHandle);
	Parms.InIconHandle = std::move(InIconHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudStatusEffectTimeElapsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHudHandle                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FStatusEffectIconHandle&   InIconHandle                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudStatusEffectTimeElapsed(const struct FMovableHudHandle& InHudHandle, const struct FStatusEffectIconHandle& InIconHandle, const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudStatusEffectTimeElapsed");

	Params::AppUIManager_SetMovableHudStatusEffectTimeElapsed Parms{};

	Parms.InHudHandle = std::move(InHudHandle);
	Parms.InIconHandle = std::move(InIconHandle);
	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudStatusUpEffectApplied
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHudHandle                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EStatusUpEffectIconType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UAppUIManager::SetMovableHudStatusUpEffectApplied(const struct FMovableHudHandle& InHudHandle, const EStatusUpEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudStatusUpEffectApplied");

	Params::AppUIManager_SetMovableHudStatusUpEffectApplied Parms{};

	Parms.InHudHandle = std::move(InHudHandle);
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTargetSocket                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudTarget(const struct FMovableHudHandle& InHandle, class AActor* InTargetActor, class FName InTargetSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudTarget");

	Params::AppUIManager_SetMovableHudTarget Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InTargetActor = InTargetActor;
	Parms.InTargetSocket = InTargetSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.SetMovableHudVisibility
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMovableHudHandle&         InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::SetMovableHudVisibility(const struct FMovableHudHandle& InHandle, bool InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "SetMovableHudVisibility");

	Params::AppUIManager_SetMovableHudVisibility Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.ShowVirtualKeyboardIfNeeded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InStringMax                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& EnteredString)>InDismissedDelegate                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppUIManager::ShowVirtualKeyboardIfNeeded(class UObject* WorldContextObject, const int32 InStringMax, TDelegate<void(const class FString& EnteredString)> InDismissedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "ShowVirtualKeyboardIfNeeded");

	Params::AppUIManager_ShowVirtualKeyboardIfNeeded Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InStringMax = InStringMax;
	Parms.InDismissedDelegate = InDismissedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetStatusEffectFrame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EStatusEffectFrameType            InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAppUIManager::GetStatusEffectFrame(const EStatusEffectFrameType InType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetStatusEffectFrame");

	Params::AppUIManager_GetStatusEffectFrame Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetUIElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       TargetElementName                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIElementBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIElementBase* UAppUIManager::GetUIElement(const class FName TargetElementName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetUIElement");

	Params::AppUIManager_GetUIElement Parms{};

	Parms.TargetElementName = TargetElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppUIManager.GetUIElementGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       TargetGroupName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UUIElementBase*>           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UUIElementBase*> UAppUIManager::GetUIElementGroup(const class FName TargetGroupName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppUIManager", "GetUIElementGroup");

	Params::AppUIManager_GetUIElementGroup Parms{};

	Parms.TargetGroupName = TargetGroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.GetLeaveButtonType
// (Native, Protected)
// Parameters:
// EUIFurnitureLeaveType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIFurnitureLeaveType AFurniture::GetLeaveButtonType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "GetLeaveButtonType");

	Params::Furniture_GetLeaveButtonType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.OnChangeLookTargetButtonPressed
// (Final, Native, Protected)

void AFurniture::OnChangeLookTargetButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "OnChangeLookTargetButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Furniture.OnLeaveButtonPressed
// (Final, Native, Protected)

void AFurniture::OnLeaveButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "OnLeaveButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Furniture.GetAngleOffsetToAnimationStart
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFurniture::GetAngleOffsetToAnimationStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "GetAngleOffsetToAnimationStart");

	Params::Furniture_GetAngleOffsetToAnimationStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.GetImmediateRotationAngleThreshold
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFurniture::GetImmediateRotationAngleThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "GetImmediateRotationAngleThreshold");

	Params::Furniture_GetImmediateRotationAngleThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.GetPositioningMarkerComponent
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArrowComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArrowComponent* AFurniture::GetPositioningMarkerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "GetPositioningMarkerComponent");

	Params::Furniture_GetPositioningMarkerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.IsOffsetByCharacterScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFurniture::IsOffsetByCharacterScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "IsOffsetByCharacterScale");

	Params::Furniture_IsOffsetByCharacterScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Furniture.IsTeleportToPosition
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFurniture::IsTeleportToPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Furniture", "IsTeleportToPosition");

	Params::Furniture_IsTeleportToPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicOnlineComponent.ClientFinalizeMuseumField
// (Net, NetReliable, Native, Event, Public, NetClient)

void UCinematicOnlineComponent::ClientFinalizeMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientFinalizeMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientInitializeMuseumField
// (Net, NetReliable, Native, Event, Public, NetClient)

void UCinematicOnlineComponent::ClientInitializeMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientInitializeMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientMessageSkip
// (Net, NetReliable, Native, Event, Public, NetClient)

void UCinematicOnlineComponent::ClientMessageSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientMessageSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientPlayCinematicPath
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FSoftObjectPath&           InLevelSequencePath                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCinematicInstanceExtensionSettings&InSettings                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InAkPlayEvent                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InAkSkipEvent                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FCinematicReplicatedData>&InReplicatedDataList                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicOnlineComponent::ClientPlayCinematicPath(const struct FSoftObjectPath& InLevelSequencePath, const struct FCinematicInstanceExtensionSettings& InSettings, const struct FSoftObjectPath& InAkPlayEvent, const struct FSoftObjectPath& InAkSkipEvent, const TArray<struct FCinematicReplicatedData>& InReplicatedDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientPlayCinematicPath");

	Params::CinematicOnlineComponent_ClientPlayCinematicPath Parms{};

	Parms.InLevelSequencePath = std::move(InLevelSequencePath);
	Parms.InSettings = std::move(InSettings);
	Parms.InAkPlayEvent = std::move(InAkPlayEvent);
	Parms.InAkSkipEvent = std::move(InAkSkipEvent);
	Parms.InReplicatedDataList = std::move(InReplicatedDataList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientSelectChoices
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const int32                             InSelectIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicOnlineComponent::ClientSelectChoices(const int32 InSelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientSelectChoices");

	Params::CinematicOnlineComponent_ClientSelectChoices Parms{};

	Parms.InSelectIndex = InSelectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientSkipCinematic
// (Net, NetReliable, Native, Event, Public, NetClient)

void UCinematicOnlineComponent::ClientSkipCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientSkipCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientSmallScenarioHideDialogue
// (Net, NetReliable, Native, Event, Public, NetClient)

void UCinematicOnlineComponent::ClientSmallScenarioHideDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientSmallScenarioHideDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.ClientSmallScenarioShowDialogue
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FSmallScenarioSendDialogData&InDialogData                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicOnlineComponent::ClientSmallScenarioShowDialogue(const struct FSmallScenarioSendDialogData& InDialogData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "ClientSmallScenarioShowDialogue");

	Params::CinematicOnlineComponent_ClientSmallScenarioShowDialogue Parms{};

	Parms.InDialogData = std::move(InDialogData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicOnlineComponent.OnSmallScenarioVoicePlayEnd
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FAppAudioVoicePlayerDelegateInfo&InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCinematicOnlineComponent::OnSmallScenarioVoicePlayEnd(const struct FAppAudioVoicePlayerDelegateInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicOnlineComponent", "OnSmallScenarioVoicePlayEnd");

	Params::CinematicOnlineComponent_OnSmallScenarioVoicePlayEnd Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioManager.FinishSmallScenario
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmallScenarioManager::FinishSmallScenario(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "FinishSmallScenario");

	Params::SmallScenarioManager_FinishSmallScenario Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.ForceQuitSmallScenario
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESmallScenarioAbortCause                AbortCause                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmallScenarioManager::ForceQuitSmallScenario(class UObject* WorldContextObject, ESmallScenarioAbortCause AbortCause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "ForceQuitSmallScenario");

	Params::SmallScenarioManager_ForceQuitSmallScenario Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AbortCause = AbortCause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.GetSmallScenarioNPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* USmallScenarioManager::GetSmallScenarioNPC(class UObject* WorldContextObject, const struct FGameplayTag& CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "GetSmallScenarioNPC");

	Params::SmallScenarioManager_GetSmallScenarioNPC Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterType = std::move(CharacterType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.IsInternalSmallScenarioPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmallScenarioManager::IsInternalSmallScenarioPlaying(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "IsInternalSmallScenarioPlaying");

	Params::SmallScenarioManager_IsInternalSmallScenarioPlaying Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.IsSmallScenarioPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmallScenarioManager::IsSmallScenarioPlaying(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "IsSmallScenarioPlaying");

	Params::SmallScenarioManager_IsSmallScenarioPlaying Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.RegisterSmallScenario
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ASmallScenarioBase>   InScenario                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InFinishDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmallScenarioManager::RegisterSmallScenario(class UObject* WorldContextObject, TSubclassOf<class ASmallScenarioBase> InScenario, TDelegate<void()> InFinishDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioManager", "RegisterSmallScenario");

	Params::SmallScenarioManager_RegisterSmallScenario Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InScenario = InScenario;
	Parms.InFinishDelegate = InFinishDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioManager.OnCutScene
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmallScenarioManager::OnCutScene(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioManager", "OnCutScene");

	Params::SmallScenarioManager_OnCutScene Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioManager.OnFastTravel
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmallScenarioManager::OnFastTravel(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioManager", "OnFastTravel");

	Params::SmallScenarioManager_OnFastTravel Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioManager.OnFastTravelByMapSystem
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmallScenarioManager::OnFastTravelByMapSystem(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioManager", "OnFastTravelByMapSystem");

	Params::SmallScenarioManager_OnFastTravelByMapSystem Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioManager.OnInMuseumField
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmallScenarioManager::OnInMuseumField(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioManager", "OnInMuseumField");

	Params::SmallScenarioManager_OnInMuseumField Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioManager.OnWorldBeginPlayEvent
// (Final, Native, Private)

void USmallScenarioManager::OnWorldBeginPlayEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioManager", "OnWorldBeginPlayEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.DestroyVehicle
// (Final, Native, Public, BlueprintCallable)

void AAppWheeledVehiclePawn::DestroyVehicle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "DestroyVehicle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.GetWingLCollision
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AAppWheeledVehiclePawn::GetWingLCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetWingLCollision");

	Params::AppWheeledVehiclePawn_GetWingLCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetWingRCollision
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AAppWheeledVehiclePawn::GetWingRCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetWingRCollision");

	Params::AppWheeledVehiclePawn_GetWingRCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsDriverRiding
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsDriverRiding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsDriverRiding");

	Params::AppWheeledVehiclePawn_IsDriverRiding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.OnChangeGlideInput
// (Final, Native, Private)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppWheeledVehiclePawn::OnChangeGlideInput(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "OnChangeGlideInput");

	Params::AppWheeledVehiclePawn_OnChangeGlideInput Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.OnCrashEvent
// (Native, Event, Public, BlueprintEvent)

void AAppWheeledVehiclePawn::OnCrashEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "OnCrashEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.OnDriverGettingOff
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            Driver                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppWheeledVehiclePawn::OnDriverGettingOff(class AActionHumanCharacter* Driver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "OnDriverGettingOff");

	Params::AppWheeledVehiclePawn_OnDriverGettingOff Parms{};

	Parms.Driver = Driver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.OnOverlapWing
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAppWheeledVehiclePawn::OnOverlapWing(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "OnOverlapWing");

	Params::AppWheeledVehiclePawn_OnOverlapWing Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AppWheeledVehiclePawn.GetAppVehicleMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAppWheelVehicleMovementComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppWheelVehicleMovementComponent* AAppWheeledVehiclePawn::GetAppVehicleMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetAppVehicleMovement");

	Params::AppWheeledVehiclePawn_GetAppVehicleMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetDriverCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* AAppWheeledVehiclePawn::GetDriverCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetDriverCharacter");

	Params::AppWheeledVehiclePawn_GetDriverCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetForwardSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAppWheeledVehiclePawn::GetForwardSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetForwardSpeed");

	Params::AppWheeledVehiclePawn_GetForwardSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetHipTranslationOffsetByMountScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AAppWheeledVehiclePawn::GetHipTranslationOffsetByMountScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetHipTranslationOffsetByMountScale");

	Params::AppWheeledVehiclePawn_GetHipTranslationOffsetByMountScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetRidingCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVehicleSeatType                        SeatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* AAppWheeledVehiclePawn::GetRidingCharacter(EVehicleSeatType SeatType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetRidingCharacter");

	Params::AppWheeledVehiclePawn_GetRidingCharacter Parms{};

	Parms.SeatType = SeatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetSpeed2D
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAppWheeledVehiclePawn::GetSpeed2D() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetSpeed2D");

	Params::AppWheeledVehiclePawn_GetSpeed2D Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetVehicleAnimationControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleAnimationControlComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVehicleAnimationControlComponent* AAppWheeledVehiclePawn::GetVehicleAnimationControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetVehicleAnimationControl");

	Params::AppWheeledVehiclePawn_GetVehicleAnimationControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetVehicleImpactEffectComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleImpactEffectComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVehicleImpactEffectComponent* AAppWheeledVehiclePawn::GetVehicleImpactEffectComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetVehicleImpactEffectComponent");

	Params::AppWheeledVehiclePawn_GetVehicleImpactEffectComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.GetVehicleWorldVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AAppWheeledVehiclePawn::GetVehicleWorldVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "GetVehicleWorldVelocity");

	Params::AppWheeledVehiclePawn_GetVehicleWorldVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsAxelTurn
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsAxelTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsAxelTurn");

	Params::AppWheeledVehiclePawn_IsAxelTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsBraking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsBraking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsBraking");

	Params::AppWheeledVehiclePawn_IsBraking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsDisappearing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsDisappearing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsDisappearing");

	Params::AppWheeledVehiclePawn_IsDisappearing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsDrifting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsDrifting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsDrifting");

	Params::AppWheeledVehiclePawn_IsDrifting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsGlide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsGlide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsGlide");

	Params::AppWheeledVehiclePawn_IsGlide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsPhotoMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsPhotoMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsPhotoMode");

	Params::AppWheeledVehiclePawn_IsPhotoMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsSlideBrake
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsSlideBrake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsSlideBrake");

	Params::AppWheeledVehiclePawn_IsSlideBrake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AppWheeledVehiclePawn.IsWheelie
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppWheeledVehiclePawn::IsWheelie() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppWheeledVehiclePawn", "IsWheelie");

	Params::AppWheeledVehiclePawn_IsWheelie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ArchiveManager.OnArchiveBeginScreenMasked
// (Final, Native, Protected)

void UArchiveManager::OnArchiveBeginScreenMasked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveManager", "OnArchiveBeginScreenMasked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArchiveManager.OnArchiveEndScreenMasked
// (Final, Native, Protected)

void UArchiveManager::OnArchiveEndScreenMasked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveManager", "OnArchiveEndScreenMasked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ArchiveManager.OnWaitArchiveEnd
// (Final, Native, Protected)

void UArchiveManager::OnWaitArchiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveManager", "OnWaitArchiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteUIObject.AddInputMap
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteUIObject::AddInputMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteUIObject", "AddInputMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteUIObject.IsRestrictUse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteUIObject::IsRestrictUse(const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteUIObject", "IsRestrictUse");

	Params::ItemPaletteUIObject_IsRestrictUse Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteUIObject.RemoveInputMap
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteUIObject::RemoveInputMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteUIObject", "RemoveInputMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CustomizeHairPostProcessAnimInstance.OnHairCrushChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsCrush                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizeHairPostProcessAnimInstance::OnHairCrushChanged(bool IsCrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizeHairPostProcessAnimInstance", "OnHairCrushChanged");

	Params::CustomizeHairPostProcessAnimInstance_OnHairCrushChanged Parms{};

	Parms.IsCrush = IsCrush;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ArticleInfoMenuBase.SelectNextPiece
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UArticleInfoMenuBase::SelectNextPiece(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArticleInfoMenuBase", "SelectNextPiece");

	Params::ArticleInfoMenuBase_SelectNextPiece Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AudioDebugFunctionLibrary.CheckEmitterToListenerRayTrace
// (Final, Native, Static, Private, HasDefaults)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EmitterPosition                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ListenerPosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioDebugFunctionLibrary::CheckEmitterToListenerRayTrace(const class UObject* WorldContext, const struct FVector& EmitterPosition, const struct FVector& ListenerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioDebugFunctionLibrary", "CheckEmitterToListenerRayTrace");

	Params::AudioDebugFunctionLibrary_CheckEmitterToListenerRayTrace Parms{};

	Parms.WorldContext = WorldContext;
	Parms.EmitterPosition = std::move(EmitterPosition);
	Parms.ListenerPosition = std::move(ListenerPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.AudioDebugFunctionLibrary.DrawActiveAkGameObjects
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<uint32, class FName>&        AkEventMap                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAudioDebugFunctionLibrary::DrawActiveAkGameObjects(const class UObject* WorldContext, const TMap<uint32, class FName>& AkEventMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioDebugFunctionLibrary", "DrawActiveAkGameObjects");

	Params::AudioDebugFunctionLibrary_DrawActiveAkGameObjects Parms{};

	Parms.WorldContext = WorldContext;
	Parms.AkEventMap = std::move(AkEventMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AudioDebugFunctionLibrary.DrawActiveGlobalSoundList
// (Final, Native, Static, Private, HasOutParams)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint64>&                   ZeroVectorEmitterArray                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TMap<uint32, class FName>&        AkEventMap                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAudioDebugFunctionLibrary::DrawActiveGlobalSoundList(const class UObject* WorldContext, const TArray<uint64>& ZeroVectorEmitterArray, const TMap<uint32, class FName>& AkEventMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioDebugFunctionLibrary", "DrawActiveGlobalSoundList");

	Params::AudioDebugFunctionLibrary_DrawActiveGlobalSoundList Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ZeroVectorEmitterArray = std::move(ZeroVectorEmitterArray);
	Parms.AkEventMap = std::move(AkEventMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AudioDebugFunctionLibrary.GetAllAkAudioEventName
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<uint32, class FName>*              Out                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioDebugFunctionLibrary::GetAllAkAudioEventName(TMap<uint32, class FName>* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioDebugFunctionLibrary", "GetAllAkAudioEventName");

	Params::AudioDebugFunctionLibrary_GetAllAkAudioEventName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.HideBowReticle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::HideBowReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "HideBowReticle");

	Params::BattleIndicatorUIObject_HideBowReticle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.InZoomReticle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::InZoomReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "InZoomReticle");

	Params::BattleIndicatorUIObject_InZoomReticle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.OnCharged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::OnCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "OnCharged");

	Params::BattleIndicatorUIObject_OnCharged Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.OnChargeOut
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::OnChargeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "OnChargeOut");

	Params::BattleIndicatorUIObject_OnChargeOut Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.OutZoomReticle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::OutZoomReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "OutZoomReticle");

	Params::BattleIndicatorUIObject_OutZoomReticle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleIndicatorUIObject.ShowBowReticle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleIndicatorUIObject::ShowBowReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleIndicatorUIObject", "ShowBowReticle");

	Params::BattleIndicatorUIObject_ShowBowReticle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BattleStateSettings.IsIdle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleStateSettings::IsIdle(const class AActionHumanCharacter* InCharacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateSettings", "IsIdle");

	Params::BattleStateSettings_IsIdle Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BattleStateSettings.PickMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInToBattle                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UBattleStateSettings::PickMontage(const class AActionHumanCharacter* InCharacter, const bool bInToBattle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStateSettings", "PickMontage");

	Params::BattleStateSettings_PickMontage Parms{};

	Parms.InCharacter = InCharacter;
	Parms.bInToBattle = bInToBattle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.AddAdditionalAmmo
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBayonetIndicatorUIObject::AddAdditionalAmmo(const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "AddAdditionalAmmo");

	Params::BayonetIndicatorUIObject_AddAdditionalAmmo Parms{};

	Parms.InNum = InNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.GetAmmoTypeIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBayonetAmmoType                InAmmoType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UBayonetIndicatorUIObject::GetAmmoTypeIcon(const EUIBayonetAmmoType InAmmoType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "GetAmmoTypeIcon");

	Params::BayonetIndicatorUIObject_GetAmmoTypeIcon Parms{};

	Parms.InAmmoType = InAmmoType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.InitializeIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EUIBayonetAmmoType                InAmmoType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InMagazineAmmoNumber                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPossessedAmmoNumber                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InAdditionalAmmoNumber                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBayonetIndicatorUIObject::InitializeIndicator(const EUIBayonetAmmoType InAmmoType, const int32 InMagazineAmmoNumber, const int32 InPossessedAmmoNumber, const int32 InAdditionalAmmoNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "InitializeIndicator");

	Params::BayonetIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InAmmoType = InAmmoType;
	Parms.InMagazineAmmoNumber = InMagazineAmmoNumber;
	Parms.InPossessedAmmoNumber = InPossessedAmmoNumber;
	Parms.InAdditionalAmmoNumber = InAdditionalAmmoNumber;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.NotifyBayonetReloaded
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             InMagazineAmmoNumber                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InPossessedAmmoNumber                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InAdditionalAmmoNumber                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBayonetIndicatorUIObject::NotifyBayonetReloaded(const int32 InMagazineAmmoNumber, const int32 InPossessedAmmoNumber, const int32 InAdditionalAmmoNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "NotifyBayonetReloaded");

	Params::BayonetIndicatorUIObject_NotifyBayonetReloaded Parms{};

	Parms.InMagazineAmmoNumber = InMagazineAmmoNumber;
	Parms.InPossessedAmmoNumber = InPossessedAmmoNumber;
	Parms.InAdditionalAmmoNumber = InAdditionalAmmoNumber;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.NotifyBayonetTriggered
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsAdditionalAmmoPrioritize                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBayonetIndicatorUIObject::NotifyBayonetTriggered(bool bIsAdditionalAmmoPrioritize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "NotifyBayonetTriggered");

	Params::BayonetIndicatorUIObject_NotifyBayonetTriggered Parms{};

	Parms.bIsAdditionalAmmoPrioritize = bIsAdditionalAmmoPrioritize;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BayonetIndicatorUIObject.SetAdditionalAmmo
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBayonetIndicatorUIObject::SetAdditionalAmmo(const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BayonetIndicatorUIObject", "SetAdditionalAmmo");

	Params::BayonetIndicatorUIObject_SetAdditionalAmmo Parms{};

	Parms.InNum = InNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BulletBase.AddDeactivateIgnoreComponents
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UActorComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletBase::AddDeactivateIgnoreComponents(class UActorComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "AddDeactivateIgnoreComponents");

	Params::BulletBase_AddDeactivateIgnoreComponents Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletBase.EnableImplement
// (Final, Native, Private)

void ABulletBase::EnableImplement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "EnableImplement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletBase.OnCharacterHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAttackCollisionResult&    InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ABulletBase::OnCharacterHit(const struct FAttackCollisionResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "OnCharacterHit");

	Params::BulletBase_OnCharacterHit Parms{};

	Parms.InHitResult = std::move(InHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BulletBase.OnFieldHit
// (Event, Protected, BlueprintEvent)

void ABulletBase::OnFieldHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "OnFieldHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.BulletBase.OnPhysicsHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABulletBase::OnPhysicsHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "OnPhysicsHit");

	Params::BulletBase_OnPhysicsHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletBase.RemoveDeactivateIgnoreComponents
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UActorComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletBase::RemoveDeactivateIgnoreComponents(class UActorComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "RemoveDeactivateIgnoreComponents");

	Params::BulletBase_RemoveDeactivateIgnoreComponents Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletBase.SpawnLauncherBullet
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FBulletSpawnInfo&          InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              UseHitInfoLocation                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAttackCollisionResult&    InHitInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ABulletBase::SpawnLauncherBullet(const struct FBulletSpawnInfo& InParameter, const int32 Index_0, const bool UseHitInfoLocation, const struct FAttackCollisionResult& InHitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletBase", "SpawnLauncherBullet");

	Params::BulletBase_SpawnLauncherBullet Parms{};

	Parms.InParameter = std::move(InParameter);
	Parms.Index_0 = Index_0;
	Parms.UseHitInfoLocation = UseHitInfoLocation;
	Parms.InHitInfo = std::move(InHitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.OnContextUpdated_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FPickupMaterialContext&    InContext                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void APickupMaterial::OnContextUpdated_BP(const struct FPickupMaterialContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "OnContextUpdated_BP");

	Params::PickupMaterial_OnContextUpdated_BP Parms{};

	Parms.InContext = std::move(InContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PickupMaterial.OnRep_Context
// (Final, Native, Protected)

void APickupMaterial::OnRep_Context()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "OnRep_Context");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.RegisterMeshesAs_AppearAfterPickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    InMeshComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APickupMaterial::RegisterMeshesAs_AppearAfterPickup(const TArray<class UMeshComponent*>& InMeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "RegisterMeshesAs_AppearAfterPickup");

	Params::PickupMaterial_RegisterMeshesAs_AppearAfterPickup Parms{};

	Parms.InMeshComponents = std::move(InMeshComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.RegisterMeshesAs_DisappearOnPickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    InMeshComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APickupMaterial::RegisterMeshesAs_DisappearOnPickup(const TArray<class UMeshComponent*>& InMeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "RegisterMeshesAs_DisappearOnPickup");

	Params::PickupMaterial_RegisterMeshesAs_DisappearOnPickup Parms{};

	Parms.InMeshComponents = std::move(InMeshComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.RegisterMeshesAs_RemainAfterPickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    InMeshComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APickupMaterial::RegisterMeshesAs_RemainAfterPickup(const TArray<class UMeshComponent*>& InMeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "RegisterMeshesAs_RemainAfterPickup");

	Params::PickupMaterial_RegisterMeshesAs_RemainAfterPickup Parms{};

	Parms.InMeshComponents = std::move(InMeshComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.RegisterNiagaraAs_AppearAfterPickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UNiagaraComponent*>& InNiagaraComponents                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APickupMaterial::RegisterNiagaraAs_AppearAfterPickup(const TArray<class UNiagaraComponent*>& InNiagaraComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "RegisterNiagaraAs_AppearAfterPickup");

	Params::PickupMaterial_RegisterNiagaraAs_AppearAfterPickup Parms{};

	Parms.InNiagaraComponents = std::move(InNiagaraComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupMaterial.RegisterNiagaraAs_DisappearOnPickup
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UNiagaraComponent*>& InNiagaraComponents                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APickupMaterial::RegisterNiagaraAs_DisappearOnPickup(const TArray<class UNiagaraComponent*>& InNiagaraComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupMaterial", "RegisterNiagaraAs_DisappearOnPickup");

	Params::PickupMaterial_RegisterNiagaraAs_DisappearOnPickup Parms{};

	Parms.InNiagaraComponents = std::move(InNiagaraComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodCodeDialogBase.OnSetBloodCodeInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FBloodCodeDialogInfo&      InBloodCodeDialogInfo                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodCodeDialogBase::OnSetBloodCodeInfo(const struct FBloodCodeDialogInfo& InBloodCodeDialogInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodCodeDialogBase", "OnSetBloodCodeInfo");

	Params::BloodCodeDialogBase_OnSetBloodCodeInfo Parms{};

	Parms.InBloodCodeDialogInfo = std::move(InBloodCodeDialogInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BloodCodeDialogBase.SetBloodCodeInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FBloodCodeDialogInfo&      InBloodCodeDialogInfo                                  (Parm, NativeAccessSpecifierPublic)

void UBloodCodeDialogBase::SetBloodCodeInfo(const struct FBloodCodeDialogInfo& InBloodCodeDialogInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodCodeDialogBase", "SetBloodCodeInfo");

	Params::BloodCodeDialogBase_SetBloodCodeInfo Parms{};

	Parms.InBloodCodeDialogInfo = std::move(InBloodCodeDialogInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BloodFeedEffectComponent.OnFinishInternal
// (Final, Native, Protected, BlueprintCallable)

void UBloodFeedEffectComponent::OnFinishInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodFeedEffectComponent", "OnFinishInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BossIndicatorUIObject.InitializeAccumulate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const uint8                             InBosNum                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBossIndicatorUIObject::InitializeAccumulate(const uint8 InBosNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "InitializeAccumulate");

	Params::BossIndicatorUIObject_InitializeAccumulate Parms{};

	Parms.InBosNum = InBosNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BossIndicatorUIObject.InitializeIndicator
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InBossName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             InHealth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InRecoverableHealth                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InBleedingAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBleedingAmount                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::InitializeIndicator(const class FText& InBossName, const float InHealth, const float InMaxHealth, const float InRecoverableHealth, const float InBleedingAmount, const float InMaxBleedingAmount, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "InitializeIndicator");

	Params::BossIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InBossName = std::move(InBossName);
	Parms.InHealth = InHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InRecoverableHealth = InRecoverableHealth;
	Parms.InBleedingAmount = InBleedingAmount;
	Parms.InMaxBleedingAmount = InMaxBleedingAmount;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyAccumulateStateValueChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBossIndicatorUIObject::NotifyAccumulateStateValueChange(const struct FGameplayTag& InEffectTag, const struct FAccumulateAttributeUIInfo& InInfo, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyAccumulateStateValueChange");

	Params::BossIndicatorUIObject_NotifyAccumulateStateValueChange Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InInfo = std::move(InInfo);
	Parms.InBossNum = InBossNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BossIndicatorUIObject.NotifyBleedingAmountChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InBleedingAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBleedingAmount                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::NotifyBleedingAmountChanged(const float InBleedingAmount, const float InMaxBleedingAmount, const EResourceChangeFactor InChangeFactor, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyBleedingAmountChanged");

	Params::BossIndicatorUIObject_NotifyBleedingAmountChanged Parms{};

	Parms.InBleedingAmount = InBleedingAmount;
	Parms.InMaxBleedingAmount = InMaxBleedingAmount;
	Parms.InChangeFactor = InChangeFactor;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyBleedingAttackSucceeded
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::NotifyBleedingAttackSucceeded(const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyBleedingAttackSucceeded");

	Params::BossIndicatorUIObject_NotifyBleedingAttackSucceeded Parms{};

	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyHealthChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InHealth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InRecoverableHealth                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InFactor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::NotifyHealthChanged(const float InHealth, const float InMaxHealth, const float InRecoverableHealth, const EResourceChangeFactor InFactor, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyHealthChanged");

	Params::BossIndicatorUIObject_NotifyHealthChanged Parms{};

	Parms.InHealth = InHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InRecoverableHealth = InRecoverableHealth;
	Parms.InFactor = InFactor;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyStatusDownEffectApplied
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusDownEffectIconType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UBossIndicatorUIObject::NotifyStatusDownEffectApplied(const EStatusDownEffectIconType InType, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyStatusDownEffectApplied");

	Params::BossIndicatorUIObject_NotifyStatusDownEffectApplied Parms{};

	Parms.InType = InType;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyStatusEffectRemoved
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::NotifyStatusEffectRemoved(const struct FStatusEffectIconHandle& InHandle, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyStatusEffectRemoved");

	Params::BossIndicatorUIObject_NotifyStatusEffectRemoved Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyStatusEffectTimeElapsed
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::NotifyStatusEffectTimeElapsed(const struct FStatusEffectIconHandle& InHandle, const float InRemainingTime, const float InTotalTime, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyStatusEffectTimeElapsed");

	Params::BossIndicatorUIObject_NotifyStatusEffectTimeElapsed Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.NotifyStatusUpEffectApplied
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusUpEffectIconType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UBossIndicatorUIObject::NotifyStatusUpEffectApplied(const EStatusUpEffectIconType InType, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "NotifyStatusUpEffectApplied");

	Params::BossIndicatorUIObject_NotifyStatusUpEffectApplied Parms{};

	Parms.InType = InType;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.SetBossName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InBossName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::SetBossName(const class FText& InBossName, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "SetBossName");

	Params::BossIndicatorUIObject_SetBossName Parms{};

	Parms.InBossName = std::move(InBossName);
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.SetGaugeVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InIsVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::SetGaugeVisibility(const bool InIsVisible, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "SetGaugeVisibility");

	Params::BossIndicatorUIObject_SetGaugeVisibility Parms{};

	Parms.InIsVisible = InIsVisible;
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.SetHealthScaleX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InScaleX                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::SetHealthScaleX(const float InScaleX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "SetHealthScaleX");

	Params::BossIndicatorUIObject_SetHealthScaleX Parms{};

	Parms.InScaleX = InScaleX;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.ShouldShowBleedingGauge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::ShouldShowBleedingGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "ShouldShowBleedingGauge");

	Params::BossIndicatorUIObject_ShouldShowBleedingGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.UpdateAccumulateStateValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FAccumulateGaugeInfo&      InGaugeInfo                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InAttributeInfo                                        (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const uint8                             InBossNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::UpdateAccumulateStateValue(const struct FAccumulateGaugeInfo& InGaugeInfo, const struct FAccumulateAttributeUIInfo& InAttributeInfo, const uint8 InBossNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "UpdateAccumulateStateValue");

	Params::BossIndicatorUIObject_UpdateAccumulateStateValue Parms{};

	Parms.InGaugeInfo = std::move(InGaugeInfo);
	Parms.InAttributeInfo = std::move(InAttributeInfo);
	Parms.InBossNum = InBossNum;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BossIndicatorUIObject.UpdateVisibleBloodAmount
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InbVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBossIndicatorUIObject::UpdateVisibleBloodAmount(bool InbVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossIndicatorUIObject", "UpdateVisibleBloodAmount");

	Params::BossIndicatorUIObject_UpdateVisibleBloodAmount Parms{};

	Parms.InbVisible = InbVisible;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.Bridge.OnCanUse
// (Final, Native, Protected)
// Parameters:
// const bool                              bInNoSideEffect                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABridge::OnCanUse(const bool bInNoSideEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bridge", "OnCanUse");

	Params::Bridge_OnCanUse Parms{};

	Parms.bInNoSideEffect = bInNoSideEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Bridge.OnRep_ReplicatedAppearance
// (Final, Native, Protected)

void ABridge::OnRep_ReplicatedAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bridge", "OnRep_ReplicatedAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Bridge.OnSwitchActivated
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABridge::OnSwitchActivated(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bridge", "OnSwitchActivated");

	Params::Bridge_OnSwitchActivated Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Bridge.UpdateState_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FBridgeState&              InContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ABridge::UpdateState_BP(const struct FBridgeState& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bridge", "UpdateState_BP");

	Params::Bridge_UpdateState_BP Parms{};

	Parms.InContext = std::move(InContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.Bridge_Residue.OnAnyActorEntersAdventureTalkEventTrigger_Found
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABridge_Residue::OnAnyActorEntersAdventureTalkEventTrigger_Found(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bridge_Residue", "OnAnyActorEntersAdventureTalkEventTrigger_Found");

	Params::Bridge_Residue_OnAnyActorEntersAdventureTalkEventTrigger_Found Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MemoryRemnantLookActor.OnEnter
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMemoryRemnantLookActor::OnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MemoryRemnantLookActor", "OnEnter");

	Params::MemoryRemnantLookActor_OnEnter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MemoryRemnantLookActor.OnExit
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMemoryRemnantLookActor::OnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MemoryRemnantLookActor", "OnExit");

	Params::MemoryRemnantLookActor_OnExit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MiniMapUIObject.BindOnBattleStateChangedDelegate
// (Final, Native, Protected, BlueprintCallable)

void UMiniMapUIObject::BindOnBattleStateChangedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapUIObject", "BindOnBattleStateChangedDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MiniMapUIObject.HideMiniMap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMiniMapUIObject::HideMiniMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapUIObject", "HideMiniMap");

	Params::MiniMapUIObject_HideMiniMap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MiniMapUIObject.ShowMiniMap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMiniMapUIObject::ShowMiniMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapUIObject", "ShowMiniMap");

	Params::MiniMapUIObject_ShowMiniMap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MiniMapUIObject.UnbindOnBattleStateChangedDelegate
// (Final, Native, Protected, BlueprintCallable)

void UMiniMapUIObject::UnbindOnBattleStateChangedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapUIObject", "UnbindOnBattleStateChangedDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerGiftHealComponent.ConsumeReservedGiftHeal
// (Final, Native, Public, BlueprintCallable)

void UPlayerGiftHealComponent::ConsumeReservedGiftHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGiftHealComponent", "ConsumeReservedGiftHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerGiftHealComponent.GetReadyToConsumeGiftHeal
// (Final, Native, Public, BlueprintCallable)

void UPlayerGiftHealComponent::GetReadyToConsumeGiftHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGiftHealComponent", "GetReadyToConsumeGiftHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.AttachToMount
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EVehicleSeatType                        InSeatType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAppWheeledVehiclePawn*           Vehicle                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Offset                                                 (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountControlComponent::AttachToMount(EVehicleSeatType InSeatType, class AAppWheeledVehiclePawn* Vehicle, const struct FTransform& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "AttachToMount");

	Params::MountControlComponent_AttachToMount Parms{};

	Parms.InSeatType = InSeatType;
	Parms.Vehicle = Vehicle;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.BeginRideMount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVehicleSeatType                        InSeatType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAppWheeledVehiclePawn*           Vehicle                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountControlComponent::BeginRideMount(EVehicleSeatType InSeatType, class AAppWheeledVehiclePawn* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "BeginRideMount");

	Params::MountControlComponent_BeginRideMount Parms{};

	Parms.InSeatType = InSeatType;
	Parms.Vehicle = Vehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.CancelGettingOff
// (Final, Native, Public, BlueprintCallable)

void UMountControlComponent::CancelGettingOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "CancelGettingOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.CancelRiding
// (Final, Native, Public, BlueprintCallable)

void UMountControlComponent::CancelRiding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "CancelRiding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.DetachFromMount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountControlComponent::DetachFromMount(bool bResetRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "DetachFromMount");

	Params::MountControlComponent_DetachFromMount Parms{};

	Parms.bResetRotation = bResetRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.GettingOffMount
// (Final, Native, Public, BlueprintCallable)

void UMountControlComponent::GettingOffMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "GettingOffMount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.SetDirectThrottleInput
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountControlComponent::SetDirectThrottleInput(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "SetDirectThrottleInput");

	Params::MountControlComponent_SetDirectThrottleInput Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.SuccessRideMount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVehicleSeatType                        InSeatType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAppWheeledVehiclePawn*           Vehicle                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountControlComponent::SuccessRideMount(EVehicleSeatType InSeatType, class AAppWheeledVehiclePawn* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "SuccessRideMount");

	Params::MountControlComponent_SuccessRideMount Parms{};

	Parms.InSeatType = InSeatType;
	Parms.Vehicle = Vehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountControlComponent.GetMountSettings_BP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMountSettings*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMountSettings* UMountControlComponent::GetMountSettings_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "GetMountSettings_BP");

	Params::MountControlComponent_GetMountSettings_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountControlComponent.GetRidingMount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAppWheeledVehiclePawn*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAppWheeledVehiclePawn* UMountControlComponent::GetRidingMount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "GetRidingMount");

	Params::MountControlComponent_GetRidingMount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountControlComponent.GetSummonedMount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAppWheeledVehiclePawn*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAppWheeledVehiclePawn* UMountControlComponent::GetSummonedMount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "GetSummonedMount");

	Params::MountControlComponent_GetSummonedMount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountControlComponent.HasMount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountControlComponent::HasMount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountControlComponent", "HasMount");

	Params::MountControlComponent_HasMount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.GetCamouflageRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInfoService::GetCamouflageRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "GetCamouflageRate");

	Params::PlayerInfoService_GetCamouflageRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.GetDebugBodyShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInfoService::GetDebugBodyShapeScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "GetDebugBodyShapeScale");

	Params::PlayerInfoService_GetDebugBodyShapeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.GetLocationEnemyLoockAt
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPlayerInfoService::GetLocationEnemyLoockAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "GetLocationEnemyLoockAt");

	Params::PlayerInfoService_GetLocationEnemyLoockAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerState UPlayerInfoService::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "GetPlayerState");

	Params::PlayerInfoService_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UPlayerInfoService::GetTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "GetTransform");

	Params::PlayerInfoService_GetTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerInfoService.IsFemale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoService::IsFemale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoService", "IsFemale");

	Params::PlayerInfoService_IsFemale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeVisualControlComponent.OnDestroyVisualControl
// (Event, Protected, BlueprintEvent)

void UPhotoModeVisualControlComponent::OnDestroyVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeVisualControlComponent", "OnDestroyVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PhotoModeVisualControlComponent.OnInitializeVisualControl
// (Event, Protected, BlueprintEvent)

void UPhotoModeVisualControlComponent::OnInitializeVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeVisualControlComponent", "OnInitializeVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PhotoModeVisualControlComponent.OnPhotoModeCameraParameterChange
// (Final, Native, Public)

void UPhotoModeVisualControlComponent::OnPhotoModeCameraParameterChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeVisualControlComponent", "OnPhotoModeCameraParameterChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoModeVisualControlComponent.OnPhotoModeCameraParameterChangeEvent
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPhotoModeAdjustableParameter&PhotoModeParameter                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPhotoModeVisualControlComponent::OnPhotoModeCameraParameterChangeEvent(const struct FPhotoModeAdjustableParameter& PhotoModeParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeVisualControlComponent", "OnPhotoModeCameraParameterChangeEvent");

	Params::PhotoModeVisualControlComponent_OnPhotoModeCameraParameterChangeEvent Parms{};

	Parms.PhotoModeParameter = std::move(PhotoModeParameter);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerStatusComponent.OnGetCurrentSpecialBuffList
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetCurrentSpecialBuffList(struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetCurrentSpecialBuffList");

	Params::PlayerStatusComponent_OnGetCurrentSpecialBuffList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetHealInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIResilienceUpType               InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIResilienceUpInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetHealInfo(const EUIResilienceUpType InType, struct FUIResilienceUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetHealInfo");

	Params::PlayerStatusComponent_OnGetHealInfo Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetNeedExpForNextLevel
// (Final, Native, Private)
// Parameters:
// const int32                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerStatusComponent::OnGetNeedExpForNextLevel(const int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetNeedExpForNextLevel");

	Params::PlayerStatusComponent_OnGetNeedExpForNextLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusComponent.OnGetPlayerExp
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerStatusComponent::OnGetPlayerExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetPlayerExp");

	Params::PlayerStatusComponent_OnGetPlayerExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusComponent.OnGetPlayerLevel
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerStatusComponent::OnGetPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetPlayerLevel");

	Params::PlayerStatusComponent_OnGetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusComponent.OnGetPlayerMaxLevel
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerStatusComponent::OnGetPlayerMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetPlayerMaxLevel");

	Params::PlayerStatusComponent_OnGetPlayerMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusComponent.OnGetPlayerStatusLevelUpInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusLevelUpInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetPlayerStatusLevelUpInfo(const int32 InLevel, struct FUIPlayerStatusLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetPlayerStatusLevelUpInfo");

	Params::PlayerStatusComponent_OnGetPlayerStatusLevelUpInfo Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithBloodCode
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithBloodCode(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithBloodCode");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithBloodCode Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithBooster(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InQuery, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithBooster");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithBooster Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithDefenciveGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithDefenciveGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithDefenciveGadget");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithDefenciveGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithEnchantDefenciveGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithEnchantDefenciveGadget(const int32 InIndex, const int32 InEnchantIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithEnchantDefenciveGadget");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithEnchantDefenciveGadget Parms{};

	Parms.InIndex = InIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithEnchantWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InQuery                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithEnchantWeapon(const EUIWeaponSlot InSlot, const struct FUIWeaponQueryInfo& InQuery, const int32 InEnchantIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithEnchantWeapon");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithEnchantWeapon Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithIndependentGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithIndependentGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithIndependentGadget");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithIndependentGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithJail
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithJail(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithJail");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithJail Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithShopEquipment
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InSlotIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithShopEquipment(const struct FUIShopQueryInfo& InInfo, const int32 InSlotIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithShopEquipment");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithShopEquipment Parms{};

	Parms.InInfo = std::move(InInfo);
	Parms.InSlotIndex = InSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithSyntheticBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithSyntheticBooster(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InQuery, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithSyntheticBooster");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithSyntheticBooster Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetSpecialBuffListWithWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetSpecialBuffListWithWeapon(const EUIWeaponSlot InSlot, const struct FUIWeaponQueryInfo& InQuery, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetSpecialBuffListWithWeapon");

	Params::PlayerStatusComponent_OnGetSpecialBuffListWithWeapon Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusFieldMenuInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUIPlayerStatusFieldMenuInfo*    OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusFieldMenuInfo(struct FUIPlayerStatusFieldMenuInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusFieldMenuInfo");

	Params::PlayerStatusComponent_OnGetStatusFieldMenuInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUIPlayerStatusInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusInfo(struct FUIPlayerStatusInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusInfo");

	Params::PlayerStatusComponent_OnGetStatusInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfo");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithBloodCode
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithBloodCode(const int32 InInventoryIndex, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithBloodCode");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithBloodCode Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIBoosterSlot                    InBoosterSlot                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithBooster(const EUIBoosterSlot InBoosterSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithBooster");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithBooster Parms{};

	Parms.InBoosterSlot = InBoosterSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithDefenceGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithDefenceGadget(const int32 InInventoryIndex, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithDefenceGadget");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithDefenceGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithJail
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithJail(const int32 InInventoryIndex, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithJail");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithJail Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithShopEquipment
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InSlotIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithShopEquipment(const struct FUIShopQueryInfo& InShopQuery, const int32 InSlotIndex, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithShopEquipment");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithShopEquipment Parms{};

	Parms.InShopQuery = std::move(InShopQuery);
	Parms.InSlotIndex = InSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithStandAloneGadget
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithStandAloneGadget(const int32 InInventoryIndex, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithStandAloneGadget");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithStandAloneGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnGetStatusSummaryInfoWithWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnGetStatusSummaryInfoWithWeapon(const EUIWeaponSlot InWeaponSlot, const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnGetStatusSummaryInfoWithWeapon");

	Params::PlayerStatusComponent_OnGetStatusSummaryInfoWithWeapon Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.PlayerStatusComponent.OnRep_ReplicatedHostPlayerLevel
// (Native, Protected)

void UPlayerStatusComponent::OnRep_ReplicatedHostPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnRep_ReplicatedHostPlayerLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerStatusComponent.OnRequestHealEnhance
// (Final, Native, Private)
// Parameters:
// const EUIResilienceUpType               InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerStatusComponent::OnRequestHealEnhance(const EUIResilienceUpType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnRequestHealEnhance");

	Params::PlayerStatusComponent_OnRequestHealEnhance Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerStatusComponent.OnSetPlayerLevel
// (Final, Native, Private)
// Parameters:
// const int32                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatusComponent::OnSetPlayerLevel(const int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatusComponent", "OnSetPlayerLevel");

	Params::PlayerStatusComponent_OnSetPlayerLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.AddAllOtherMesh
// (Native, Public, BlueprintCallable)

void UCharacterVisualControlComponent::AddAllOtherMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "AddAllOtherMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.AddOtherMesh
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InMeshName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::AddOtherMesh(class FName InMeshName, class UMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "AddOtherMesh");

	Params::CharacterVisualControlComponent_AddOtherMesh Parms{};

	Parms.InMeshName = InMeshName;
	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.AppearBody
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::AppearBody(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "AppearBody");

	Params::CharacterVisualControlComponent_AppearBody Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.BeginSoulBodyEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::BeginSoulBodyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "BeginSoulBodyEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.ClearAllOtherMesh
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::ClearAllOtherMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ClearAllOtherMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.EndSoulBodyEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::EndSoulBodyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "EndSoulBodyEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.GetAllOtherMesh
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMeshComponent*> UCharacterVisualControlComponent::GetAllOtherMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "GetAllOtherMesh");

	Params::CharacterVisualControlComponent_GetAllOtherMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.GetCharacterActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCharacterVisualControlComponent::GetCharacterActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "GetCharacterActor");

	Params::CharacterVisualControlComponent_GetCharacterActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.GetCharacterMesh
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCharacterVisualControlComponent::GetCharacterMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "GetCharacterMesh");

	Params::CharacterVisualControlComponent_GetCharacterMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.GetWeaponMesh
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCharacterVisualControlComponent::GetWeaponMesh(int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "GetWeaponMesh");

	Params::CharacterVisualControlComponent_GetWeaponMesh Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.GetWeaponMeshCount
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterVisualControlComponent::GetWeaponMeshCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "GetWeaponMeshCount");

	Params::CharacterVisualControlComponent_GetWeaponMeshCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.IsGuestState
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsGuestState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsGuestState");

	Params::CharacterVisualControlComponent_IsGuestState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.IsInvaderWaveState
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsInvaderWaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsInvaderWaveState");

	Params::CharacterVisualControlComponent_IsInvaderWaveState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.IsMatchingState
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsMatchingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsMatchingState");

	Params::CharacterVisualControlComponent_IsMatchingState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnBeginBuff
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerBuffType                         InBuffType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnBeginBuff(EPlayerBuffType InBuffType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnBeginBuff");

	Params::CharacterVisualControlComponent_OnBeginBuff Parms{};

	Parms.InBuffType = InBuffType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnBurringStateEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InIsOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::OnBurringStateEvent(bool InIsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnBurringStateEvent");

	Params::CharacterVisualControlComponent_OnBurringStateEvent Parms{};

	Parms.InIsOn = InIsOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.OnDropWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnDropWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnDropWeapon");

	Params::CharacterVisualControlComponent_OnDropWeapon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnDying
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnDying");

	Params::CharacterVisualControlComponent_OnDying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnEdgeEmissiveBegin
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEdgeEmissive_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnEdgeEmissiveBegin(class UAnimSequenceBase* InAnimSequence, const struct FEdgeEmissive_Parameter& InParameter, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnEdgeEmissiveBegin");

	Params::CharacterVisualControlComponent_OnEdgeEmissiveBegin Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnEdgeEmissiveEnd
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEdgeEmissive_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnEdgeEmissiveEnd(class UAnimSequenceBase* InAnimSequence, const struct FEdgeEmissive_Parameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnEdgeEmissiveEnd");

	Params::CharacterVisualControlComponent_OnEdgeEmissiveEnd Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnEdgeEmissiveTick
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEdgeEmissive_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnEdgeEmissiveTick(class UAnimSequenceBase* InAnimSequence, const struct FEdgeEmissive_Parameter& InParameter, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnEdgeEmissiveTick");

	Params::CharacterVisualControlComponent_OnEdgeEmissiveTick Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnEndBuff
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerBuffType                         InBuffType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnEndBuff(EPlayerBuffType InBuffType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnEndBuff");

	Params::CharacterVisualControlComponent_OnEndBuff Parms{};

	Parms.InBuffType = InBuffType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnFinishAppearBodyEvent
// (Final, Native, Protected, BlueprintCallable)

void UCharacterVisualControlComponent::OnFinishAppearBodyEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnFinishAppearBodyEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.OnFinishVanishBodyEvent
// (Final, Native, Protected, BlueprintCallable)

void UCharacterVisualControlComponent::OnFinishVanishBodyEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnFinishVanishBodyEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.OnFinishVanishDeathEvent
// (Final, Native, Protected, BlueprintCallable)

void UCharacterVisualControlComponent::OnFinishVanishDeathEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnFinishVanishDeathEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.OnInitializeVisualControl
// (Event, Protected, BlueprintEvent)

void UCharacterVisualControlComponent::OnInitializeVisualControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnInitializeVisualControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.OnPlayerRespawnEvent
// (Event, Public, BlueprintEvent)

void UCharacterVisualControlComponent::OnPlayerRespawnEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnPlayerRespawnEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.OnResetCurveValueEnd
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ANS_MeshType                          InMeshType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// E_ANS_CurveWeightEndBehavior            EndBehavior                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResetValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnResetCurveValueEnd(E_ANS_MeshType InMeshType, class FName CurveName, E_ANS_CurveWeightEndBehavior EndBehavior, float ResetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnResetCurveValueEnd");

	Params::CharacterVisualControlComponent_OnResetCurveValueEnd Parms{};

	Parms.InMeshType = InMeshType;
	Parms.CurveName = CurveName;
	Parms.EndBehavior = EndBehavior;
	Parms.ResetValue = ResetValue;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnSimpleAnimNotify_Begin
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnSimpleAnimNotify_Begin(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnSimpleAnimNotify_Begin");

	Params::CharacterVisualControlComponent_OnSimpleAnimNotify_Begin Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnSimpleAnimNotify_End
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnSimpleAnimNotify_End(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnSimpleAnimNotify_End");

	Params::CharacterVisualControlComponent_OnSimpleAnimNotify_End Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnSimpleAnimNotify_Tick
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnSimpleAnimNotify_Tick(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnSimpleAnimNotify_Tick");

	Params::CharacterVisualControlComponent_OnSimpleAnimNotify_Tick Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishBegin
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanish_Parameter&         InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishBegin(class UAnimSequenceBase* InAnimSequence, const struct FVanish_Parameter& InParameter, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishBegin");

	Params::CharacterVisualControlComponent_OnVanishBegin Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishEnd
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanish_Parameter&         InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishEnd(class UAnimSequenceBase* InAnimSequence, const struct FVanish_Parameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishEnd");

	Params::CharacterVisualControlComponent_OnVanishEnd Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishMeshBegin
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanishMesh_Parameter&     InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishMeshBegin(class UAnimSequenceBase* InAnimSequence, const struct FVanishMesh_Parameter& InParameter, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishMeshBegin");

	Params::CharacterVisualControlComponent_OnVanishMeshBegin Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishMeshEnd
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanishMesh_Parameter&     InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishMeshEnd(class UAnimSequenceBase* InAnimSequence, const struct FVanishMesh_Parameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishMeshEnd");

	Params::CharacterVisualControlComponent_OnVanishMeshEnd Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishMeshTick
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanishMesh_Parameter&     InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishMeshTick(class UAnimSequenceBase* InAnimSequence, const struct FVanishMesh_Parameter& InParameter, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishMeshTick");

	Params::CharacterVisualControlComponent_OnVanishMeshTick Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.OnVanishTick
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVanish_Parameter&         InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::OnVanishTick(class UAnimSequenceBase* InAnimSequence, const struct FVanish_Parameter& InParameter, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "OnVanishTick");

	Params::CharacterVisualControlComponent_OnVanishTick Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InParameter = std::move(InParameter);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.ResetAppearBody
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::ResetAppearBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ResetAppearBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.ResetCharacter
// (Event, Public, BlueprintEvent)
// Parameters:
// const ECharacterResetType               InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::ResetCharacter(const ECharacterResetType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ResetCharacter");

	Params::CharacterVisualControlComponent_ResetCharacter Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.ResetVanishBody
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::ResetVanishBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ResetVanishBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.ResetVanishDeath
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::ResetVanishDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ResetVanishDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.ResetVanishWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::ResetVanishWeapon(bool bReverse, int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "ResetVanishWeapon");

	Params::CharacterVisualControlComponent_ResetVanishWeapon Parms{};

	Parms.bReverse = bReverse;
	Parms.InWeaponIndex = InWeaponIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SetEnableAppearBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetEnableAppearBody(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetEnableAppearBody");

	Params::CharacterVisualControlComponent_SetEnableAppearBody Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.SetEnablePlayerRespawnEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetEnablePlayerRespawnEvent(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetEnablePlayerRespawnEvent");

	Params::CharacterVisualControlComponent_SetEnablePlayerRespawnEvent Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.SetEnableVanishBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetEnableVanishBody(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetEnableVanishBody");

	Params::CharacterVisualControlComponent_SetEnableVanishBody Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.SetEnableVanishDeath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetEnableVanishDeath(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetEnableVanishDeath");

	Params::CharacterVisualControlComponent_SetEnableVanishDeath Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.SetGuestState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetGuestState(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetGuestState");

	Params::CharacterVisualControlComponent_SetGuestState Parms{};

	Parms.bInEnable = bInEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SetInvaderWaveState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetInvaderWaveState(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetInvaderWaveState");

	Params::CharacterVisualControlComponent_SetInvaderWaveState Parms{};

	Parms.bInEnable = bInEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SetMatchingState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SetMatchingState(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SetMatchingState");

	Params::CharacterVisualControlComponent_SetMatchingState Parms{};

	Parms.bInEnable = bInEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SlowEffect_Begin
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InEffectSize                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SlowEffect_Begin(float InEffectSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SlowEffect_Begin");

	Params::CharacterVisualControlComponent_SlowEffect_Begin Parms{};

	Parms.InEffectSize = InEffectSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SlowEffect_End
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::SlowEffect_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SlowEffect_End");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.SlowEffect_EndNotice
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::SlowEffect_EndNotice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SlowEffect_EndNotice");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.SlowEffect_Process
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SlowEffect_Process(float InDeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SlowEffect_Process");

	Params::CharacterVisualControlComponent_SlowEffect_Process Parms{};

	Parms.InDeltaSeconds = InDeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlComponent.SlowEffect_Tick
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::SlowEffect_Tick(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SlowEffect_Tick");

	Params::CharacterVisualControlComponent_SlowEffect_Tick Parms{};

	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.SummonBody
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::SummonBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "SummonBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.UnsummonBody
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCharacterVisualControlComponent::UnsummonBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "UnsummonBody");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterVisualControlComponent.VanishBody
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::VanishBody(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "VanishBody");

	Params::CharacterVisualControlComponent_VanishBody Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.VanishDeath
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::VanishDeath(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "VanishDeath");

	Params::CharacterVisualControlComponent_VanishDeath Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.VanishWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterVisualControlComponent::VanishWeapon(bool bReverse, float InDuration, int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "VanishWeapon");

	Params::CharacterVisualControlComponent_VanishWeapon Parms{};

	Parms.bReverse = bReverse;
	Parms.InDuration = InDuration;
	Parms.InWeaponIndex = InWeaponIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CharacterVisualControlComponent.IsEnableAppearBody
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsEnableAppearBody() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsEnableAppearBody");

	Params::CharacterVisualControlComponent_IsEnableAppearBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.IsEnableVanishBody
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsEnableVanishBody() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsEnableVanishBody");

	Params::CharacterVisualControlComponent_IsEnableVanishBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterVisualControlComponent.IsEnableVanishDeath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterVisualControlComponent::IsEnableVanishDeath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterVisualControlComponent", "IsEnableVanishDeath");

	Params::CharacterVisualControlComponent_IsEnableVanishDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.BeginBuddyPossessProcess
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::BeginBuddyPossessProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "BeginBuddyPossessProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.DrawBloodMovementEnemyToPlayer
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EffectCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::DrawBloodMovementEnemyToPlayer(class ACharacter* InEnemy, int32 EffectCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "DrawBloodMovementEnemyToPlayer");

	Params::PlayerVisualControlComponent_DrawBloodMovementEnemyToPlayer Parms{};

	Parms.InEnemy = InEnemy;
	Parms.EffectCount = EffectCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.DrawBloodMovementPlayerToEnemy
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EffectCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::DrawBloodMovementPlayerToEnemy(class ACharacter* InEnemy, int32 EffectCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "DrawBloodMovementPlayerToEnemy");

	Params::PlayerVisualControlComponent_DrawBloodMovementPlayerToEnemy Parms{};

	Parms.InEnemy = InEnemy;
	Parms.EffectCount = EffectCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.DrawBloodSuckHitScreenEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::DrawBloodSuckHitScreenEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "DrawBloodSuckHitScreenEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.DrawDamageScreenEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::DrawDamageScreenEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "DrawDamageScreenEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.EndBuddyPossessProcess
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::EndBuddyPossessProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "EndBuddyPossessProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.GetCustomizeShadowMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USkeletalMeshComponent*>*  OutShadowMeshes                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::GetCustomizeShadowMeshes(TArray<class USkeletalMeshComponent*>* OutShadowMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "GetCustomizeShadowMeshes");

	Params::PlayerVisualControlComponent_GetCustomizeShadowMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShadowMeshes != nullptr)
		*OutShadowMeshes = std::move(Parms.OutShadowMeshes);
}


// Function Extensions.PlayerVisualControlComponent.GetInCinematic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::GetInCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "GetInCinematic");

	Params::PlayerVisualControlComponent_GetInCinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.GetInPhotoMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::GetInPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "GetInPhotoMode");

	Params::PlayerVisualControlComponent_GetInPhotoMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.GetInSpecialBloodSuck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::GetInSpecialBloodSuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "GetInSpecialBloodSuck");

	Params::PlayerVisualControlComponent_GetInSpecialBloodSuck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.MoveHistory3D_Deactivate
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::MoveHistory3D_Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "MoveHistory3D_Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.MoveHistory3D_IsActive
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::MoveHistory3D_IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "MoveHistory3D_IsActive");

	Params::PlayerVisualControlComponent_MoveHistory3D_IsActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.MoveHistory3D_Spawn
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPlayerVisualControlComponent::MoveHistory3D_Spawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "MoveHistory3D_Spawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.OnChangeBloodVeilType
// (Event, Public, BlueprintEvent)
// Parameters:
// ESuckingBloodType                       InNextType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::OnChangeBloodVeilType(ESuckingBloodType InNextType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnChangeBloodVeilType");

	Params::PlayerVisualControlComponent_OnChangeBloodVeilType Parms{};

	Parms.InNextType = InNextType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.OnChangeDefensiveGadgetType
// (Event, Public, BlueprintEvent)
// Parameters:
// EDefensiveGadgetType                    InNextType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::OnChangeDefensiveGadgetType(EDefensiveGadgetType InNextType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnChangeDefensiveGadgetType");

	Params::PlayerVisualControlComponent_OnChangeDefensiveGadgetType Parms{};

	Parms.InNextType = InNextType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.OnChangeWeaponType
// (Event, Public, BlueprintEvent)
// Parameters:
// EPlayerWeaponType                       InNextType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::OnChangeWeaponType(EPlayerWeaponType InNextType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnChangeWeaponType");

	Params::PlayerVisualControlComponent_OnChangeWeaponType Parms{};

	Parms.InNextType = InNextType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.OnCharacterCustomizeFinished
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnCharacterCustomizeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnCharacterCustomizeFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnCharacterCustomizeFinishedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnCharacterCustomizeFinishedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnCharacterCustomizeFinishedEvent");

	Params::PlayerVisualControlComponent_OnCharacterCustomizeFinishedEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnFinishCinematic
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnFinishCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnFinishCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnFinishCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnFinishCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnFinishCinematicEvent");

	Params::PlayerVisualControlComponent_OnFinishCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnFinishPhotoMode
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnFinishPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnFinishPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnFinishPhotoModeEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnFinishPhotoModeEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnFinishPhotoModeEvent");

	Params::PlayerVisualControlComponent_OnFinishPhotoModeEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnFinishSpecialBloodSuckEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnFinishSpecialBloodSuckEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnFinishSpecialBloodSuckEvent");

	Params::PlayerVisualControlComponent_OnFinishSpecialBloodSuckEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnGiftHealApplied
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnGiftHealApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnGiftHealApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnGiftHealAppliedEvent
// (Event, Public, BlueprintEvent)

void UPlayerVisualControlComponent::OnGiftHealAppliedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnGiftHealAppliedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.OnReadyToConsumeGiftHeal
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnReadyToConsumeGiftHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnReadyToConsumeGiftHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnReadyToConsumeGiftHealEvent
// (Event, Public, BlueprintEvent)

void UPlayerVisualControlComponent::OnReadyToConsumeGiftHealEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnReadyToConsumeGiftHealEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PlayerVisualControlComponent.OnRidingMountEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMountControlComponent*           InMountControl                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::OnRidingMountEnd(class UMountControlComponent* InMountControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnRidingMountEnd");

	Params::PlayerVisualControlComponent_OnRidingMountEnd Parms{};

	Parms.InMountControl = InMountControl;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.OnRidingMountStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMountControlComponent*           InMountControl                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::OnRidingMountStart(class UMountControlComponent* InMountControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnRidingMountStart");

	Params::PlayerVisualControlComponent_OnRidingMountStart Parms{};

	Parms.InMountControl = InMountControl;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.OnStartCinematic
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnStartCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnStartCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnStartCinematicEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnStartCinematicEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnStartCinematicEvent");

	Params::PlayerVisualControlComponent_OnStartCinematicEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnStartPhotoMode
// (Final, Native, Public)

void UPlayerVisualControlComponent::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.OnStartPhotoModeEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnStartPhotoModeEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnStartPhotoModeEvent");

	Params::PlayerVisualControlComponent_OnStartPhotoModeEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.OnStartSpecialBloodSuckEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::OnStartSpecialBloodSuckEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "OnStartSpecialBloodSuckEvent");

	Params::PlayerVisualControlComponent_OnStartSpecialBloodSuckEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.PlayerVisualControlComponent.SetEnableBathing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::SetEnableBathing(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "SetEnableBathing");

	Params::PlayerVisualControlComponent_SetEnableBathing Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerVisualControlComponent.TimeTravelFastTravelEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVisualControlComponent::TimeTravelFastTravelEvent(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "TimeTravelFastTravelEvent");

	Params::PlayerVisualControlComponent_TimeTravelFastTravelEvent Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlayerVisualControlComponent.IsDebugShowBloodVessel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerVisualControlComponent::IsDebugShowBloodVessel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVisualControlComponent", "IsDebugShowBloodVessel");

	Params::PlayerVisualControlComponent_IsDebugShowBloodVessel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BTTask_NPCApproachLadder.OnMoveCompleted
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_NPCApproachLadder::OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult MovementResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_NPCApproachLadder", "OnMoveCompleted");

	Params::BTTask_NPCApproachLadder_OnMoveCompleted Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.MovementResult = MovementResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PostProcessVolumeEx.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessVolumeEx::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessVolumeEx", "AddOrUpdateBlendable");

	Params::PostProcessVolumeEx_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PostProcessVolumeEx.OnDataLayerInstanceRuntimeStateChanged
// (Final, Native, Private)
// Parameters:
// const class UDataLayerInstance*         InDataLayer                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerRuntimeState                  InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessVolumeEx::OnDataLayerInstanceRuntimeStateChanged(const class UDataLayerInstance* InDataLayer, EDataLayerRuntimeState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessVolumeEx", "OnDataLayerInstanceRuntimeStateChanged");

	Params::PostProcessVolumeEx_OnDataLayerInstanceRuntimeStateChanged Parms{};

	Parms.InDataLayer = InDataLayer;
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapReleaseComponent.IsTargetMapAreaReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapReleaseComponent::IsTargetMapAreaReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapReleaseComponent", "IsTargetMapAreaReleased");

	Params::MapReleaseComponent_IsTargetMapAreaReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapReleaseComponent.ReleaseMapArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapReleaseComponent::ReleaseMapArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapReleaseComponent", "ReleaseMapArea");

	Params::MapReleaseComponent_ReleaseMapArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyCharacter.UpdateState
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FBuddyActionDelegateInfo&  Info                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ABuddyCharacter::UpdateState(const struct FBuddyActionDelegateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyCharacter", "UpdateState");

	Params::BuddyCharacter_UpdateState Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.CheckBuddyActionEffect
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FBuddyActionDelegateInfo&  Info                                                   (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBuddyControlComponent::CheckBuddyActionEffect(const struct FBuddyActionDelegateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "CheckBuddyActionEffect");

	Params::BuddyControlComponent_CheckBuddyActionEffect Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnActivateYadorigiScenario
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyControlComponent::OnActivateYadorigiScenario(const struct FGameplayTag& InBuddyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnActivateYadorigiScenario");

	Params::BuddyControlComponent_OnActivateYadorigiScenario Parms{};

	Parms.InBuddyType = std::move(InBuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnChangeStoryFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     Param                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBuddyControlComponent::OnChangeStoryFlag(const struct FStoryFlagChangeParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnChangeStoryFlag");

	Params::BuddyControlComponent_OnChangeStoryFlag Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnEndPossessSequencer
// (Final, Native, Private)

void UBuddyControlComponent::OnEndPossessSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnEndPossessSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnEndSummonSequencer
// (Final, Native, Private)

void UBuddyControlComponent::OnEndSummonSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnEndSummonSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnEndUnpossessSequencer
// (Final, Native, Private)

void UBuddyControlComponent::OnEndUnpossessSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnEndUnpossessSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyControlComponent.OnEndUnsummonSequencer
// (Final, Native, Private)

void UBuddyControlComponent::OnEndUnsummonSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyControlComponent", "OnEndUnsummonSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyDialogBase.OnSetBuddyTag
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyDialogBase::OnSetBuddyTag(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyDialogBase", "OnSetBuddyTag");

	Params::BuddyDialogBase_OnSetBuddyTag Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BuddyDialogBase.SetBuddyTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyDialogBase::SetBuddyTag(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyDialogBase", "SetBuddyTag");

	Params::BuddyDialogBase_SetBuddyTag Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyDialogBase.GetBuddyTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UBuddyDialogBase::GetBuddyTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyDialogBase", "GetBuddyTag");

	Params::BuddyDialogBase_GetBuddyTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.GetIsNoMountAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::GetIsNoMountAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "GetIsNoMountAction");

	Params::BuddyIndicatorUIObject_GetIsNoMountAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.GetResourceGaugeLengthType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EResourceGaugeLengthType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EResourceGaugeLengthType UBuddyIndicatorUIObject::GetResourceGaugeLengthType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "GetResourceGaugeLengthType");

	Params::BuddyIndicatorUIObject_GetResourceGaugeLengthType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.InitializeIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentSummonResource                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxSummonResource                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::InitializeIndicator(const float InCurrentSummonResource, const float InMaxSummonResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "InitializeIndicator");

	Params::BuddyIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InCurrentSummonResource = InCurrentSummonResource;
	Parms.InMaxSummonResource = InMaxSummonResource;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyBarrierBrokenDown
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyBarrierBrokenDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyBarrierBrokenDown");

	Params::BuddyIndicatorUIObject_NotifyBarrierBrokenDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyBuddyLossTimeGaugeChanged
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<float>&                    InLossTimeRateArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyBuddyLossTimeGaugeChanged(const TArray<float>& InLossTimeRateArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyBuddyLossTimeGaugeChanged");

	Params::BuddyIndicatorUIObject_NotifyBuddyLossTimeGaugeChanged Parms{};

	Parms.InLossTimeRateArray = std::move(InLossTimeRateArray);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyBuddyStatementFinished
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsLouStatement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyBuddyStatementFinished(bool IsLouStatement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyBuddyStatementFinished");

	Params::BuddyIndicatorUIObject_NotifyBuddyStatementFinished Parms{};

	Parms.IsLouStatement = IsLouStatement;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyBuddyStatementStarted
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsLouStatement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyBuddyStatementStarted(bool IsLouStatement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyBuddyStatementStarted");

	Params::BuddyIndicatorUIObject_NotifyBuddyStatementStarted Parms{};

	Parms.IsLouStatement = IsLouStatement;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyEmpowerCooldownUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyEmpowerCooldownUpdated(const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyEmpowerCooldownUpdated");

	Params::BuddyIndicatorUIObject_NotifyEmpowerCooldownUpdated Parms{};

	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifyMaterializeCooldownUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifyMaterializeCooldownUpdated(const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifyMaterializeCooldownUpdated");

	Params::BuddyIndicatorUIObject_NotifyMaterializeCooldownUpdated Parms{};

	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifySummonResourceChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentSummonResource                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxSummonResource                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifySummonResourceChanged(const float InCurrentSummonResource, const float InMaxSummonResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifySummonResourceChanged");

	Params::BuddyIndicatorUIObject_NotifySummonResourceChanged Parms{};

	Parms.InCurrentSummonResource = InCurrentSummonResource;
	Parms.InMaxSummonResource = InMaxSummonResource;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.NotifySummonResourceExchanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::NotifySummonResourceExchanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "NotifySummonResourceExchanged");

	Params::BuddyIndicatorUIObject_NotifySummonResourceExchanged Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.OnChangeStoryFlag
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBuddyIndicatorUIObject::OnChangeStoryFlag(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "OnChangeStoryFlag");

	Params::BuddyIndicatorUIObject_OnChangeStoryFlag Parms{};

	Parms.InParam = std::move(InParam);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BuddyIndicatorUIObject.OnNoMountAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyIndicatorUIObject::OnNoMountAction(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "OnNoMountAction");

	Params::BuddyIndicatorUIObject_OnNoMountAction Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.BuddyIndicatorUIObject.SetBarrierGaugeVisible
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetBarrierGaugeVisible(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetBarrierGaugeVisible");

	Params::BuddyIndicatorUIObject_SetBarrierGaugeVisible Parms{};

	Parms.InVisible = InVisible;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.SetBuddyIcon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                InBuddyIcon                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InBuddyType                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetBuddyIcon(class UMaterialInstance* InBuddyIcon, const struct FGameplayTag& InBuddyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetBuddyIcon");

	Params::BuddyIndicatorUIObject_SetBuddyIcon Parms{};

	Parms.InBuddyIcon = InBuddyIcon;
	Parms.InBuddyType = std::move(InBuddyType);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.SetSummonEmpowerEnabled
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetSummonEmpowerEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetSummonEmpowerEnabled");

	Params::BuddyIndicatorUIObject_SetSummonEmpowerEnabled Parms{};

	Parms.InEnabled = InEnabled;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.SetSummonGaugeEnabled
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetSummonGaugeEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetSummonGaugeEnabled");

	Params::BuddyIndicatorUIObject_SetSummonGaugeEnabled Parms{};

	Parms.InEnabled = InEnabled;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.SetSummonMaterializeEnabled
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetSummonMaterializeEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetSummonMaterializeEnabled");

	Params::BuddyIndicatorUIObject_SetSummonMaterializeEnabled Parms{};

	Parms.InEnabled = InEnabled;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyIndicatorUIObject.SetSummonMode
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const ESummonGaugeMode                  InMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyIndicatorUIObject::SetSummonMode(const ESummonGaugeMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyIndicatorUIObject", "SetSummonMode");

	Params::BuddyIndicatorUIObject_SetSummonMode Parms{};

	Parms.InMode = InMode;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetBuddyMetaInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              BuddyType                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBuddyMetaInfo*                  OutMetaInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UBuddyManager::GetBuddyMetaInfo(const struct FGameplayTag& BuddyType, struct FBuddyMetaInfo* OutMetaInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetBuddyMetaInfo");

	Params::BuddyManager_GetBuddyMetaInfo Parms{};

	Parms.BuddyType = std::move(BuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMetaInfo != nullptr)
		*OutMetaInfo = std::move(Parms.OutMetaInfo);
}


// Function Extensions.BuddyManager.GetBuddyResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              BuddyType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBuddyResources*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBuddyResources* UBuddyManager::GetBuddyResources(const struct FGameplayTag& BuddyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetBuddyResources");

	Params::BuddyManager_GetBuddyResources Parms{};

	Parms.BuddyType = std::move(BuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetCurrentBuddyMetaInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBuddyMetaInfo*                  OutMetaInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UBuddyManager::GetCurrentBuddyMetaInfo(struct FBuddyMetaInfo* OutMetaInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetCurrentBuddyMetaInfo");

	Params::BuddyManager_GetCurrentBuddyMetaInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMetaInfo != nullptr)
		*OutMetaInfo = std::move(Parms.OutMetaInfo);
}


// Function Extensions.BuddyManager.ResetPresentScenarioID
// (Final, Native, Public, BlueprintCallable)

void UBuddyManager::ResetPresentScenarioID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "ResetPresentScenarioID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyManager.SetBlockPossess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlockPossess                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyManager::SetBlockPossess(bool bBlockPossess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "SetBlockPossess");

	Params::BuddyManager_SetBlockPossess Parms{};

	Parms.bBlockPossess = bBlockPossess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyManager.SetBlockSummon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlockSummon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyManager::SetBlockSummon(bool bBlockSummon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "SetBlockSummon");

	Params::BuddyManager_SetBlockSummon Parms{};

	Parms.bBlockSummon = bBlockSummon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyManager.GetAddedBuddyTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UBuddyManager::GetAddedBuddyTypes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetAddedBuddyTypes");

	Params::BuddyManager_GetAddedBuddyTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetBuddy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UBuddyManager::GetBuddy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetBuddy");

	Params::BuddyManager_GetBuddy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetBuddySelectInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBuddySelectInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBuddySelectInfo UBuddyManager::GetBuddySelectInfo(const struct FGameplayTag& InBuddyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetBuddySelectInfo");

	Params::BuddyManager_GetBuddySelectInfo Parms{};

	Parms.InBuddyType = std::move(InBuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetBuddySettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              BuddyType                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBuddySettings*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBuddySettings* UBuddyManager::GetBuddySettings(const struct FGameplayTag& BuddyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetBuddySettings");

	Params::BuddyManager_GetBuddySettings Parms{};

	Parms.BuddyType = std::move(BuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetCurrentBuddyActionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBuddyActionState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuddyActionState UBuddyManager::GetCurrentBuddyActionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetCurrentBuddyActionState");

	Params::BuddyManager_GetCurrentBuddyActionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetHostBuddy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UBuddyManager::GetHostBuddy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetHostBuddy");

	Params::BuddyManager_GetHostBuddy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetPresentScenarioID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBuddyManager::GetPresentScenarioID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetPresentScenarioID");

	Params::BuddyManager_GetPresentScenarioID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.GetSelectableBuddyTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UBuddyManager::GetSelectableBuddyTypes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "GetSelectableBuddyTypes");

	Params::BuddyManager_GetSelectableBuddyTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsActiveBuddyAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsActiveBuddyAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsActiveBuddyAction");

	Params::BuddyManager_IsActiveBuddyAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsBlockPossess
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsBlockPossess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsBlockPossess");

	Params::BuddyManager_IsBlockPossess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsBlockSummon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsBlockSummon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsBlockSummon");

	Params::BuddyManager_IsBlockSummon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsExistBuddy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsExistBuddy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsExistBuddy");

	Params::BuddyManager_IsExistBuddy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsPossess
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsOnlyCombat                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsPossess(bool IsOnlyCombat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsPossess");

	Params::BuddyManager_IsPossess Parms{};

	Parms.IsOnlyCombat = IsOnlyCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsSetForceBuddyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsSetForceBuddyType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsSetForceBuddyType");

	Params::BuddyManager_IsSetForceBuddyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyManager.IsSummon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsOnlyCombat                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuddyManager::IsSummon(bool IsOnlyCombat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyManager", "IsSummon");

	Params::BuddyManager_IsSummon Parms{};

	Parms.IsOnlyCombat = IsOnlyCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyMountEmotionComponent.OnStartPhotoMode
// (Final, Native, Protected)

void UBuddyMountEmotionComponent::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyMountEmotionComponent", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyOnPlayerDeathAbility.GetPlayerDeathMontage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UBuddyOnPlayerDeathAbility::GetPlayerDeathMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyOnPlayerDeathAbility", "GetPlayerDeathMontage");

	Params::BuddyOnPlayerDeathAbility_GetPlayerDeathMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BuddyScenarioManager.CheckFinishYadorigiScenario
// (Final, Native, Private)

void UBuddyScenarioManager::CheckFinishYadorigiScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyScenarioManager", "CheckFinishYadorigiScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyScenarioManager.OnGameStateSetEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   GameStateBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyScenarioManager::OnGameStateSetEvent(class AGameStateBase* GameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyScenarioManager", "OnGameStateSetEvent");

	Params::BuddyScenarioManager_OnGameStateSetEvent Parms{};

	Parms.GameStateBase = GameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BuddyScenarioManager.OnSummonBuddyForYadorigiScenario
// (Final, Native, Private)
// Parameters:
// bool                                    IsSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuddyScenarioManager::OnSummonBuddyForYadorigiScenario(bool IsSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuddyScenarioManager", "OnSummonBuddyForYadorigiScenario");

	Params::BuddyScenarioManager_OnSummonBuddyForYadorigiScenario Parms{};

	Parms.IsSuccess = IsSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerGuardSettings.GetPlayerGuardSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActionHumanCharacter*      InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPlayerGuardSettings*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerGuardSettings* UPlayerGuardSettings::GetPlayerGuardSettings(const class AActionHumanCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerGuardSettings", "GetPlayerGuardSettings");

	Params::PlayerGuardSettings_GetPlayerGuardSettings Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerGuardSettings.GetGuardParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EPlayerGuardParameterType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerGuardParameter      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FPlayerGuardParameter UPlayerGuardSettings::GetGuardParameter(const EPlayerGuardParameterType InType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGuardSettings", "GetGuardParameter");

	Params::PlayerGuardSettings_GetGuardParameter Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerGuardSettings.GetJustGuardReceptionTime
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerGuardParameter&     InParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerGuardSettings::GetJustGuardReceptionTime(const struct FPlayerGuardParameter& InParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGuardSettings", "GetJustGuardReceptionTime");

	Params::PlayerGuardSettings_GetJustGuardReceptionTime Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpBuff_SpawnEffect.OnNiagaraSystemFinished
// (Final, Native, Private)
// Parameters:
// class UNiagaraComponent*                FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuff_SpawnEffect::OnNiagaraSystemFinished(class UNiagaraComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuff_SpawnEffect", "OnNiagaraSystemFinished");

	Params::SpBuff_SpawnEffect_OnNiagaraSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.NotifyLogoShowSkip
// (Final, Native, Public, BlueprintCallable)

void ULogoUIObject::NotifyLogoShowSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "NotifyLogoShowSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.NotifyScreenFadeInCompleted
// (Final, Native, Public, BlueprintCallable)

void ULogoUIObject::NotifyScreenFadeInCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "NotifyScreenFadeInCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.NotifyScreenFadeOutCompleted
// (Final, Native, Public, BlueprintCallable)

void ULogoUIObject::NotifyScreenFadeOutCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "NotifyScreenFadeOutCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.OnLogoFinished
// (Final, Native, Protected)

void ULogoUIObject::OnLogoFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "OnLogoFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.OnLogoSkipableTime
// (Final, Native, Protected)

void ULogoUIObject::OnLogoSkipableTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "OnLogoSkipableTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.OnShowBlankFinished
// (Final, Native, Protected)

void ULogoUIObject::OnShowBlankFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "OnShowBlankFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.OnShowLogoFinished
// (Final, Native, Protected)

void ULogoUIObject::OnShowLogoFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "OnShowLogoFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.ScreenFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogoUIObject::ScreenFadeIn(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "ScreenFadeIn");

	Params::LogoUIObject_ScreenFadeIn Parms{};

	Parms.InFadeTime = InFadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.ScreenFadeInBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::ScreenFadeInBP(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "ScreenFadeInBP");

	Params::LogoUIObject_ScreenFadeInBP Parms{};

	Parms.InFadeTime = InFadeTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.LogoUIObject.ScreenFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InInitFadeOut                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogoUIObject::ScreenFadeOut(const float InFadeTime, const bool InInitFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "ScreenFadeOut");

	Params::LogoUIObject_ScreenFadeOut Parms{};

	Parms.InFadeTime = InFadeTime;
	Parms.InInitFadeOut = InInitFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.ScreenFadeOutBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::ScreenFadeOutBP(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "ScreenFadeOutBP");

	Params::LogoUIObject_ScreenFadeOutBP Parms{};

	Parms.InFadeTime = InFadeTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.LogoUIObject.ShowLogo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InLogoIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::ShowLogo(const int32 InLogoIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "ShowLogo");

	Params::LogoUIObject_ShowLogo Parms{};

	Parms.InLogoIndex = InLogoIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LogoUIObject.SkipLogoShow
// (Final, Native, Public, BlueprintCallable)

void ULogoUIObject::SkipLogoShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "SkipLogoShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoUIObject.SkipLogoShowBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::SkipLogoShowBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "SkipLogoShowBP");

	Params::LogoUIObject_SkipLogoShowBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.LogoUIObject.HasRequiredDisplayLogo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::HasRequiredDisplayLogo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "HasRequiredDisplayLogo");

	Params::LogoUIObject_HasRequiredDisplayLogo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LogoUIObject.IsLogoSkipable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoUIObject::IsLogoSkipable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoUIObject", "IsLogoSkipable");

	Params::LogoUIObject_IsLogoSkipable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BulletDominionComponent.OnSphereBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBulletDominionComponent::OnSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDominionComponent", "OnSphereBeginOverlap");

	Params::BulletDominionComponent_OnSphereBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletDominionComponent.OnSphereEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletDominionComponent::OnSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDominionComponent", "OnSphereEndOverlap");

	Params::BulletDominionComponent_OnSphereEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.ClearAllBulletPool
// (Final, Native, Public)

void UBulletManager::ClearAllBulletPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "ClearAllBulletPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.ClearBulletPool
// (Final, Native, Public)
// Parameters:
// class FName                             InBulletID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletManager::ClearBulletPool(class FName InBulletID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "ClearBulletPool");

	Params::BulletManager_ClearBulletPool Parms{};

	Parms.InBulletID = InBulletID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.DebugSpawnBullet
// (Final, Native, Public, BlueprintCallable)

void UBulletManager::DebugSpawnBullet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "DebugSpawnBullet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.DestroyAllBullet
// (Final, Native, Public)

void UBulletManager::DestroyAllBullet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "DestroyAllBullet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.DestroyBullet
// (Final, Native, Public)
// Parameters:
// class ABulletBase*                      InBullet                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletManager::DestroyBullet(class ABulletBase* InBullet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "DestroyBullet");

	Params::BulletManager_DestroyBullet Parms{};

	Parms.InBullet = InBullet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.GetBulletIDList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UBulletManager::GetBulletIDList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "GetBulletIDList");

	Params::BulletManager_GetBulletIDList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.BulletManager.OnGameStateSetEvent
// (Final, Native, Public)
// Parameters:
// class AGameStateBase*                   GameStateBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletManager::OnGameStateSetEvent(class AGameStateBase* GameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "OnGameStateSetEvent");

	Params::BulletManager_OnGameStateSetEvent Parms{};

	Parms.GameStateBase = GameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.RequestDestroyBullet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABulletBase*                      InBullet                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletManager::RequestDestroyBullet(class ABulletBase* InBullet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "RequestDestroyBullet");

	Params::BulletManager_RequestDestroyBullet Parms{};

	Parms.InBullet = InBullet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.RequestStopBullet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABulletBase*                      InBullet                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBulletManager::RequestStopBullet(class ABulletBase* InBullet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "RequestStopBullet");

	Params::BulletManager_RequestStopBullet Parms{};

	Parms.InBullet = InBullet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.BulletManager.SpawnBullet
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBulletCreateInfo*               InInfo                                                 (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ABulletBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABulletBase* UBulletManager::SpawnBullet(struct FBulletCreateInfo* InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "SpawnBullet");

	Params::BulletManager_SpawnBullet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InInfo != nullptr)
		*InInfo = std::move(Parms.InInfo);

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryIndicatorUIObject.BindOnScreenMask
// (Final, Native, Protected, BlueprintCallable)

void ULouDiaryIndicatorUIObject::BindOnScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryIndicatorUIObject", "BindOnScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LouDiaryIndicatorUIObject.NotifyLouDiaryFinished
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULouDiaryIndicatorUIObject::NotifyLouDiaryFinished(const class FName& InLouDiaryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryIndicatorUIObject", "NotifyLouDiaryFinished");

	Params::LouDiaryIndicatorUIObject_NotifyLouDiaryFinished Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LouDiaryIndicatorUIObject.NotifyLouDiaryMemorized
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULouDiaryIndicatorUIObject::NotifyLouDiaryMemorized(const class FName& InLouDiaryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryIndicatorUIObject", "NotifyLouDiaryMemorized");

	Params::LouDiaryIndicatorUIObject_NotifyLouDiaryMemorized Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LouDiaryIndicatorUIObject.OnScreenMask_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InIsScreenMask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULouDiaryIndicatorUIObject::OnScreenMask_BP(bool InIsScreenMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryIndicatorUIObject", "OnScreenMask_BP");

	Params::LouDiaryIndicatorUIObject_OnScreenMask_BP Parms{};

	Parms.InIsScreenMask = InIsScreenMask;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.LouDiaryIndicatorUIObject.UnbindOnScreenMask
// (Final, Native, Protected, BlueprintCallable)

void ULouDiaryIndicatorUIObject::UnbindOnScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryIndicatorUIObject", "UnbindOnScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.CheckWeaponGadgetCapacity
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::CheckWeaponGadgetCapacity(const int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "CheckWeaponGadgetCapacity");

	Params::CampMenuTestActor_CheckWeaponGadgetCapacity Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.CheckWeaponGadgetEquipable
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InGandgeIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::CheckWeaponGadgetEquipable(const int32 InWeaponIndex, const int32 InGandgeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "CheckWeaponGadgetEquipable");

	Params::CampMenuTestActor_CheckWeaponGadgetEquipable Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGandgeIndex = InGandgeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.CheckWeaponGadgetEquiped
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InGadgetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::CheckWeaponGadgetEquiped(const int32 InGadgetIndex, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "CheckWeaponGadgetEquiped");

	Params::CampMenuTestActor_CheckWeaponGadgetEquiped Parms{};

	Parms.InGadgetIndex = InGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.EquipDefaultRequestWeaponGadget
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampMenuTestActor::EquipDefaultRequestWeaponGadget(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "EquipDefaultRequestWeaponGadget");

	Params::CampMenuTestActor_EquipDefaultRequestWeaponGadget Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.EquipRequestWeaponGadget
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InGadgetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampMenuTestActor::EquipRequestWeaponGadget(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot, const int32 InGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "EquipRequestWeaponGadget");

	Params::CampMenuTestActor_EquipRequestWeaponGadget Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;
	Parms.InGadgetIndex = InGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.GetDefaultWeaponGadgetInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetDefaultWeaponGadgetInfo(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetDefaultWeaponGadgetInfo");

	Params::CampMenuTestActor_GetDefaultWeaponGadgetInfo Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);
}


// Function Extensions.CampMenuTestActor.GetEquipedWeaponGadgetIndex
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetEquipedWeaponGadgetIndex(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetEquipedWeaponGadgetIndex");

	Params::CampMenuTestActor_GetEquipedWeaponGadgetIndex Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetEquipedWeaponGadgetInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::GetEquipedWeaponGadgetInfo(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetEquipedWeaponGadgetInfo");

	Params::CampMenuTestActor_GetEquipedWeaponGadgetInfo Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetInventoryArticleUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetInventoryArticleUIInfo(const int32 InIndex, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetInventoryArticleUIInfo");

	Params::CampMenuTestActor_GetInventoryArticleUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuTestActor.GetInventoryNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetInventoryNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetInventoryNumber");

	Params::CampMenuTestActor_GetInventoryNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetIsUsingTestData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::GetIsUsingTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetIsUsingTestData");

	Params::CampMenuTestActor_GetIsUsingTestData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetPlayerStatusSummary
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetPlayerStatusSummary(struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetPlayerStatusSummary");

	Params::CampMenuTestActor_GetPlayerStatusSummary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuTestActor.GetResilienceUpInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// EUIResilienceUpType                     InResilienceUpType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIResilienceUpInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetResilienceUpInfo(EUIResilienceUpType InResilienceUpType, struct FUIResilienceUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetResilienceUpInfo");

	Params::CampMenuTestActor_GetResilienceUpInfo Parms{};

	Parms.InResilienceUpType = InResilienceUpType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuTestActor.GetStorageArticleUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetStorageArticleUIInfo(const int32 InIndex, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetStorageArticleUIInfo");

	Params::CampMenuTestActor_GetStorageArticleUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuTestActor.GetStorageNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetStorageNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetStorageNumber");

	Params::CampMenuTestActor_GetStorageNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetWeaponGadgetDuplicationRecipeInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InGadgetRecipeIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetDuplicationRecipeInfo*OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetWeaponGadgetDuplicationRecipeInfo(const int32 InGadgetRecipeIndex, struct FUIWeaponGadgetDuplicationRecipeInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponGadgetDuplicationRecipeInfo");

	Params::CampMenuTestActor_GetWeaponGadgetDuplicationRecipeInfo Parms{};

	Parms.InGadgetRecipeIndex = InGadgetRecipeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.CampMenuTestActor.GetWeaponGadgetDuplicationRecipeNumber
// (Final, Native, Public)
// Parameters:
// EArticleSyntheticType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetWeaponGadgetDuplicationRecipeNumber(EArticleSyntheticType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponGadgetDuplicationRecipeNumber");

	Params::CampMenuTestActor_GetWeaponGadgetDuplicationRecipeNumber Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetWeaponGadgetInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InGadgetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetWeaponGadgetInfo(const int32 InGadgetIndex, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponGadgetInfo");

	Params::CampMenuTestActor_GetWeaponGadgetInfo Parms{};

	Parms.InGadgetIndex = InGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);
}


// Function Extensions.CampMenuTestActor.GetWeaponGadgetNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetWeaponGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponGadgetNumber");

	Params::CampMenuTestActor_GetWeaponGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.GetWeaponInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ACampMenuTestActor::GetWeaponInfo(const int32 InWeaponIndex, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponInfo");

	Params::CampMenuTestActor_GetWeaponInfo Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuTestActor.GetWeaponNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ACampMenuTestActor::GetWeaponNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "GetWeaponNumber");

	Params::CampMenuTestActor_GetWeaponNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.HasDefaultWeaponGadget
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::HasDefaultWeaponGadget(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "HasDefaultWeaponGadget");

	Params::CampMenuTestActor_HasDefaultWeaponGadget Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RemoveRequestWeaponGadget
// (Final, Native, Public)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampMenuTestActor::RemoveRequestWeaponGadget(const int32 InWeaponIndex, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RemoveRequestWeaponGadget");

	Params::CampMenuTestActor_RemoveRequestWeaponGadget Parms{};

	Parms.InWeaponIndex = InWeaponIndex;
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.RequestInventoryAutoRefillSetting
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestInventoryAutoRefillSetting(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestInventoryAutoRefillSetting");

	Params::CampMenuTestActor_RequestInventoryAutoRefillSetting Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RequestMoveArticle2Inventory
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestMoveArticle2Inventory(const int32 InIndex, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestMoveArticle2Inventory");

	Params::CampMenuTestActor_RequestMoveArticle2Inventory Parms{};

	Parms.InIndex = InIndex;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RequestMoveArticle2Storage
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestMoveArticle2Storage(const int32 InIndex, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestMoveArticle2Storage");

	Params::CampMenuTestActor_RequestMoveArticle2Storage Parms{};

	Parms.InIndex = InIndex;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RequestResilienceUp
// (Final, Native, Public)
// Parameters:
// EUIResilienceUpType                     InResilienceUpType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestResilienceUp(EUIResilienceUpType InResilienceUpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestResilienceUp");

	Params::CampMenuTestActor_RequestResilienceUp Parms{};

	Parms.InResilienceUpType = InResilienceUpType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RequestStorageAutoRefillSetting
// (Final, Native, Public)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestStorageAutoRefillSetting(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestStorageAutoRefillSetting");

	Params::CampMenuTestActor_RequestStorageAutoRefillSetting Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.RequestUseTestData
// (Final, Native, Public, BlueprintCallable)

void ACampMenuTestActor::RequestUseTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestUseTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.RequestWeaponGadgetDuplication
// (Final, Native, Public)
// Parameters:
// const int32                             InGadgetRecipeIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACampMenuTestActor::RequestWeaponGadgetDuplication(const int32 InGadgetRecipeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "RequestWeaponGadgetDuplication");

	Params::CampMenuTestActor_RequestWeaponGadgetDuplication Parms{};

	Parms.InGadgetRecipeIndex = InGadgetRecipeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuTestActor.ResilienceUpMenuClose
// (Final, Native, Public)

void ACampMenuTestActor::ResilienceUpMenuClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "ResilienceUpMenuClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuTestActor.ResilienceUpMenuOpen
// (Final, Native, Public)

void ACampMenuTestActor::ResilienceUpMenuOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuTestActor", "ResilienceUpMenuOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.BelowCapacityWeaponGadget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::BelowCapacityWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "BelowCapacityWeaponGadget");

	Params::CampMenuUIObject_BelowCapacityWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.CanTalkToLouDirectly
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::CanTalkToLouDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "CanTalkToLouDirectly");

	Params::CampMenuUIObject_CanTalkToLouDirectly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.EquipableGadgetType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::EquipableGadgetType(const struct FUIWeaponQueryInfo& InWeaponQuery, const struct FUIWeaponGadgetQueryInfo& InGadgetQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "EquipableGadgetType");

	Params::CampMenuUIObject_EquipableGadgetType Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.EquipDefaultRequestWeaponGadget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCampMenuUIObject::EquipDefaultRequestWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "EquipDefaultRequestWeaponGadget");

	Params::CampMenuUIObject_EquipDefaultRequestWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.EquipedGadgetOtherWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::EquipedGadgetOtherWeapon(const struct FUIWeaponGadgetQueryInfo& InGadgetQuery, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "EquipedGadgetOtherWeapon");

	Params::CampMenuUIObject_EquipedGadgetOtherWeapon Parms{};

	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.EquipRequestWeaponGadget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCampMenuUIObject::EquipRequestWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, const struct FUIWeaponGadgetQueryInfo& InGadgetQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "EquipRequestWeaponGadget");

	Params::CampMenuUIObject_EquipRequestWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;
	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.GetAvailableTalkToLouInfoBP
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTalkToLouTableRow*              OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::GetAvailableTalkToLouInfoBP(struct FTalkToLouTableRow* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetAvailableTalkToLouInfoBP");

	Params::CampMenuUIObject_GetAvailableTalkToLouInfoBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetBuddyInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBuddyInfo*                    OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetBuddyInfo(const int32 InListIndex, struct FUIBuddyInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetBuddyInfo");

	Params::CampMenuUIObject_GetBuddyInfo Parms{};

	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetBuddyNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetBuddyNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetBuddyNumber");

	Params::CampMenuUIObject_GetBuddyNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetCurrentBuddyIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetCurrentBuddyIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetCurrentBuddyIndex");

	Params::CampMenuUIObject_GetCurrentBuddyIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetDefaultWeaponGadgetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetDefaultWeaponGadgetInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetDefaultWeaponGadgetInfo");

	Params::CampMenuUIObject_GetDefaultWeaponGadgetInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);
}


// Function Extensions.CampMenuUIObject.GetEquipedArticleIndexInInventory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutIndexes                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetEquipedArticleIndexInInventory(const EUIMainCategory InCategory, TArray<int32>* OutIndexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetEquipedArticleIndexInInventory");

	Params::CampMenuUIObject_GetEquipedArticleIndexInInventory Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndexes != nullptr)
		*OutIndexes = std::move(Parms.OutIndexes);
}


// Function Extensions.CampMenuUIObject.GetEquipedWeaponGadgetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetCategory           InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetEquipedWeaponGadgetIndex(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, const EUIWeaponGadgetCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetEquipedWeaponGadgetIndex");

	Params::CampMenuUIObject_GetEquipedWeaponGadgetIndex Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetEquipedWeaponGadgetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::GetEquipedWeaponGadgetInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetEquipedWeaponGadgetInfo");

	Params::CampMenuUIObject_GetEquipedWeaponGadgetInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetEquipedWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetEquipedWeaponIndex(const EUIWeaponSlot InSlot, const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetEquipedWeaponIndex");

	Params::CampMenuUIObject_GetEquipedWeaponIndex Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetExp");

	Params::CampMenuUIObject_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetExpToLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetExpToLevel(const int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetExpToLevel");

	Params::CampMenuUIObject_GetExpToLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetInventoryArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetInventoryArticleUIInfo(const struct FUIArticleQueryInfo& InArticleQuery, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetInventoryArticleUIInfo");

	Params::CampMenuUIObject_GetInventoryArticleUIInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetInventoryNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIMainCategory                         InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetInventoryNumber(EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetInventoryNumber");

	Params::CampMenuUIObject_GetInventoryNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetPlayerLevel");

	Params::CampMenuUIObject_GetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetPlayerMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetPlayerMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetPlayerMaxLevel");

	Params::CampMenuUIObject_GetPlayerMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetPlayerStatusAtLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusLevelUpInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetPlayerStatusAtLevel(const int32 InLevel, struct FUIPlayerStatusLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetPlayerStatusAtLevel");

	Params::CampMenuUIObject_GetPlayerStatusAtLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetPlayerStatusSummary
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetPlayerStatusSummary(struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetPlayerStatusSummary");

	Params::CampMenuUIObject_GetPlayerStatusSummary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetResilienceUpInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EUIResilienceUpType                     InResilienceUpType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIResilienceUpInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetResilienceUpInfo(EUIResilienceUpType InResilienceUpType, struct FUIResilienceUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetResilienceUpInfo");

	Params::CampMenuUIObject_GetResilienceUpInfo Parms{};

	Parms.InResilienceUpType = InResilienceUpType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetResultWeaponGadgetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetResultWeaponGadgetInfo(const struct FUIWeaponGadgetQueryInfo& InQueryInfo, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetResultWeaponGadgetInfo");

	Params::CampMenuUIObject_GetResultWeaponGadgetInfo Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetStorageArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FStorageUIInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetStorageArticleUIInfo(const struct FUIArticleQueryInfo& InArticleQuery, struct FStorageUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetStorageArticleUIInfo");

	Params::CampMenuUIObject_GetStorageArticleUIInfo Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetStorageNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIMainCategory                         InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetStorageNumber(EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetStorageNumber");

	Params::CampMenuUIObject_GetStorageNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetWeaponGadgetDuplicationRecipeNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIWeaponGadgetCategory                 InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetWeaponGadgetDuplicationRecipeNumber(EUIWeaponGadgetCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponGadgetDuplicationRecipeNumber");

	Params::CampMenuUIObject_GetWeaponGadgetDuplicationRecipeNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetWeaponGadgetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutGadgetInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetWeaponGadgetInfo(const struct FUIWeaponGadgetQueryInfo& InGadgetQuery, struct FUIWeaponGadgetInfo* OutGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponGadgetInfo");

	Params::CampMenuUIObject_GetWeaponGadgetInfo Parms{};

	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGadgetInfo != nullptr)
		*OutGadgetInfo = std::move(Parms.OutGadgetInfo);
}


// Function Extensions.CampMenuUIObject.GetWeaponGadgetNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetCategory           InGadgetCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetWeaponGadgetNumber(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetCategory InGadgetCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponGadgetNumber");

	Params::CampMenuUIObject_GetWeaponGadgetNumber Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetCategory = InGadgetCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetWeaponGadgetRecipeUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetWeaponGadgetRecipeUIInfo(const struct FUIWeaponGadgetQueryInfo& InQueryInfo, struct FItemSyntheticRecipeUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponGadgetRecipeUIInfo");

	Params::CampMenuUIObject_GetWeaponGadgetRecipeUIInfo Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetWeaponInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::GetWeaponInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponInfo");

	Params::CampMenuUIObject_GetWeaponInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.CampMenuUIObject.GetWeaponNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCampMenuUIObject::GetWeaponNumber(const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetWeaponNumber");

	Params::CampMenuUIObject_GetWeaponNumber Parms{};

	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.GetYadorigiName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCampMenuUIObject::GetYadorigiName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "GetYadorigiName");

	Params::CampMenuUIObject_GetYadorigiName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.HasDefaultWeaponGadget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::HasDefaultWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "HasDefaultWeaponGadget");

	Params::CampMenuUIObject_HasDefaultWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsCampRestAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::IsCampRestAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsCampRestAvailable");

	Params::CampMenuUIObject_IsCampRestAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsCampRestGrayOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::IsCampRestGrayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsCampRestGrayOut");

	Params::CampMenuUIObject_IsCampRestGrayOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsChangeableWeaponGadget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UCampMenuUIObject::IsChangeableWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsChangeableWeaponGadget");

	Params::CampMenuUIObject_IsChangeableWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsGrayOutLevelUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UCampMenuUIObject::IsGrayOutLevelUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsGrayOutLevelUp");

	Params::CampMenuUIObject_IsGrayOutLevelUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsSetForceBuddyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::IsSetForceBuddyType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsSetForceBuddyType");

	Params::CampMenuUIObject_IsSetForceBuddyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.NotifyBuddyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCampMenuUIObject::NotifyBuddyChanged(const int32 InListIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "NotifyBuddyChanged");

	Params::CampMenuUIObject_NotifyBuddyChanged Parms{};

	Parms.InListIndex = InListIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CampMenuUIObject.NotifyCampMenuFinish
// (Final, Native, Public, BlueprintCallable)

void UCampMenuUIObject::NotifyCampMenuFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "NotifyCampMenuFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.NotifyCampRestEnded
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCampMenuUIObject::NotifyCampRestEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "NotifyCampRestEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CampMenuUIObject.OnFinishTalkToLouCinematic
// (Final, Native, Public)

void UCampMenuUIObject::OnFinishTalkToLouCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "OnFinishTalkToLouCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.OnFinishTalkToLouCinematicBP
// (Event, Protected, BlueprintEvent)

void UCampMenuUIObject::OnFinishTalkToLouCinematicBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "OnFinishTalkToLouCinematicBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CampMenuUIObject.OnStartTalkToLouCinematic
// (Final, Native, Public)

void UCampMenuUIObject::OnStartTalkToLouCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "OnStartTalkToLouCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.OnStartTalkToLouCinematicBP
// (Event, Protected, BlueprintEvent)

void UCampMenuUIObject::OnStartTalkToLouCinematicBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "OnStartTalkToLouCinematicBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CampMenuUIObject.RemoveRequestWeaponGadget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCampMenuUIObject::RemoveRequestWeaponGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RemoveRequestWeaponGadget");

	Params::CampMenuUIObject_RemoveRequestWeaponGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.RequestCampRest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUICampRestOption                       InOption                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCampMenuUIObject::RequestCampRest(EUICampRestOption InOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestCampRest");

	Params::CampMenuUIObject_RequestCampRest Parms{};

	Parms.InOption = InOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.RequestChangeBuddy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestChangeBuddy(const int32 InListIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestChangeBuddy");

	Params::CampMenuUIObject_RequestChangeBuddy Parms{};

	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.RequestInventoryAutoRefillSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestInventoryAutoRefillSetting(const struct FUIArticleQueryInfo& InArticleQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestInventoryAutoRefillSetting");

	Params::CampMenuUIObject_RequestInventoryAutoRefillSetting Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.RequestMoveArticle2Inventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestMoveArticle2Inventory(const struct FUIArticleQueryInfo& InArticleQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestMoveArticle2Inventory");

	Params::CampMenuUIObject_RequestMoveArticle2Inventory Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.RequestMoveArticle2Storage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestMoveArticle2Storage(const struct FUIArticleQueryInfo& InArticleQuery, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestMoveArticle2Storage");

	Params::CampMenuUIObject_RequestMoveArticle2Storage Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.RequestResilienceUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIResilienceUpType                     InResilienceUpType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestResilienceUp(EUIResilienceUpType InResilienceUpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestResilienceUp");

	Params::CampMenuUIObject_RequestResilienceUp Parms{};

	Parms.InResilienceUpType = InResilienceUpType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.RequestStorageAutoRefillSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::RequestStorageAutoRefillSetting(const struct FUIArticleQueryInfo& InArticleQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "RequestStorageAutoRefillSetting");

	Params::CampMenuUIObject_RequestStorageAutoRefillSetting Parms{};

	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.SetPlayerLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCampMenuUIObject::SetPlayerLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "SetPlayerLevel");

	Params::CampMenuUIObject_SetPlayerLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.TalkToLou
// (Final, Native, Public, BlueprintCallable)

void UCampMenuUIObject::TalkToLou()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "TalkToLou");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CampMenuUIObject.TalkToLouBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FTalkToLouTableRow&        InTalkInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCampMenuUIObject::TalkToLouBP(const struct FTalkToLouTableRow& InTalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "TalkToLouBP");

	Params::CampMenuUIObject_TalkToLouBP Parms{};

	Parms.InTalkInfo = std::move(InTalkInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CampMenuUIObject.TalkToLouDirectly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::TalkToLouDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "TalkToLouDirectly");

	Params::CampMenuUIObject_TalkToLouDirectly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.WeaponGadgetDuplicateRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::WeaponGadgetDuplicateRequest(const struct FUIWeaponGadgetQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "WeaponGadgetDuplicateRequest");

	Params::CampMenuUIObject_WeaponGadgetDuplicateRequest Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.CanTalkToLou
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::CanTalkToLou() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "CanTalkToLou");

	Params::CampMenuUIObject_CanTalkToLou Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsAnyNewDreamWorldTalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::IsAnyNewDreamWorldTalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsAnyNewDreamWorldTalk");

	Params::CampMenuUIObject_IsAnyNewDreamWorldTalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CampMenuUIObject.IsGrayOutTalkToLou
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCampMenuUIObject::IsGrayOutTalkToLou() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampMenuUIObject", "IsGrayOutTalkToLou");

	Params::CampMenuUIObject_IsGrayOutTalkToLou Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIBoosterCategoryFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIBoosterCategory                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIBoosterCategory UCategoryPalletMenu::GetUIBoosterCategoryFromIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIBoosterCategoryFromIndex");

	Params::CategoryPalletMenu_GetUIBoosterCategoryFromIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIExpendableItemCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIExpendableItemCategory               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIExpendableItemCategory UCategoryPalletMenu::GetUIExpendableItemCategory(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIExpendableItemCategory");

	Params::CategoryPalletMenu_GetUIExpendableItemCategory Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIItemCategoryFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIItemCategory                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIItemCategory UCategoryPalletMenu::GetUIItemCategoryFromIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIItemCategoryFromIndex");

	Params::CategoryPalletMenu_GetUIItemCategoryFromIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIMainCategoryFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbleAll                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbleRecently                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIMainCategory                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIMainCategory UCategoryPalletMenu::GetUIMainCategoryFromIndex(int32 InIndex, bool bAbleAll, bool bAbleRecently)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIMainCategoryFromIndex");

	Params::CategoryPalletMenu_GetUIMainCategoryFromIndex Parms{};

	Parms.InIndex = InIndex;
	Parms.bAbleAll = bAbleAll;
	Parms.bAbleRecently = bAbleRecently;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIWeaponCategoryFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIWeaponCategory                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIWeaponCategory UCategoryPalletMenu::GetUIWeaponCategoryFromIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIWeaponCategoryFromIndex");

	Params::CategoryPalletMenu_GetUIWeaponCategoryFromIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetUIWeaponGadgetCategoryFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIWeaponGadgetCategory                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIWeaponGadgetCategory UCategoryPalletMenu::GetUIWeaponGadgetCategoryFromIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CategoryPalletMenu", "GetUIWeaponGadgetCategoryFromIndex");

	Params::CategoryPalletMenu_GetUIWeaponGadgetCategoryFromIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot1
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot1");

	Params::CategoryPalletMenu_GetPalettSlot1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot2");

	Params::CategoryPalletMenu_GetPalettSlot2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot3
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot3");

	Params::CategoryPalletMenu_GetPalettSlot3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot4
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot4");

	Params::CategoryPalletMenu_GetPalettSlot4 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot5
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot5");

	Params::CategoryPalletMenu_GetPalettSlot5 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot6
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot6()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot6");

	Params::CategoryPalletMenu_GetPalettSlot6 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot7
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot7()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot7");

	Params::CategoryPalletMenu_GetPalettSlot7 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetPalettSlot8
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UCategoryPalletMenu::GetPalettSlot8()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetPalettSlot8");

	Params::CategoryPalletMenu_GetPalettSlot8 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetSelectingIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCategoryPalletMenu::GetSelectingIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetSelectingIndex");

	Params::CategoryPalletMenu_GetSelectingIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.GetSlotIndexByWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMenuPieceBase*                   InSlotWidget                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCategoryPalletMenu::GetSlotIndexByWidget(class UMenuPieceBase* InSlotWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "GetSlotIndexByWidget");

	Params::CategoryPalletMenu_GetSlotIndexByWidget Parms{};

	Parms.InSlotWidget = InSlotWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CategoryPalletMenu.MoveLeftSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanWarp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCategoryPalletMenu::MoveLeftSlot(bool bInCanWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "MoveLeftSlot");

	Params::CategoryPalletMenu_MoveLeftSlot Parms{};

	Parms.bInCanWarp = bInCanWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CategoryPalletMenu.MoveRightSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanWarp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCategoryPalletMenu::MoveRightSlot(bool bInCanWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "MoveRightSlot");

	Params::CategoryPalletMenu_MoveRightSlot Parms{};

	Parms.bInCanWarp = bInCanWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CategoryPalletMenu.RefreshTextLayout
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCategoryPalletMenu::RefreshTextLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "RefreshTextLayout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CategoryPalletMenu.SetSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAbsoluteUpdate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCategoryPalletMenu::SetSlotIndex(const int32 InIndex, bool bInAbsoluteUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "SetSlotIndex");

	Params::CategoryPalletMenu_SetSlotIndex Parms{};

	Parms.InIndex = InIndex;
	Parms.bInAbsoluteUpdate = bInAbsoluteUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CategoryPalletMenu.SetSlotIndexToInit
// (Final, Native, Public, BlueprintCallable)

void UCategoryPalletMenu::SetSlotIndexToInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "SetSlotIndexToInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CategoryPalletMenu.SetUpCategoryPalletSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUICategoryPalletInfo&     InInfo                                                 (Parm, NativeAccessSpecifierPublic)

void UCategoryPalletMenu::SetUpCategoryPalletSlot(const struct FUICategoryPalletInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "SetUpCategoryPalletSlot");

	Params::CategoryPalletMenu_SetUpCategoryPalletSlot Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CategoryPalletMenu.SlotIndexChanged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCategoryPalletMenu::SlotIndexChanged(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryPalletMenu", "SlotIndexChanged");

	Params::CategoryPalletMenu_SlotIndexChanged Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.CloseStageDirections
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::CloseStageDirections(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "CloseStageDirections");

	Params::NarrativeFunctionLibrary_CloseStageDirections Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.CloseSubtitle
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::CloseSubtitle(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "CloseSubtitle");

	Params::NarrativeFunctionLibrary_CloseSubtitle Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.FormatTextWithPlayerInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNarrativeFunctionLibrary::FormatTextWithPlayerInfo(const class UObject* InWorldContext, const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "FormatTextWithPlayerInfo");

	Params::NarrativeFunctionLibrary_FormatTextWithPlayerInfo Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.NarrativeFunctionLibrary.OpenStageDirections
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      StageDirectionsText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::OpenStageDirections(const class UObject* InWorldContext, const class FText& StageDirectionsText, float DisplayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "OpenStageDirections");

	Params::NarrativeFunctionLibrary_OpenStageDirections Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.StageDirectionsText = std::move(StageDirectionsText);
	Parms.DisplayTime = DisplayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.OpenSubtitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Speaker                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Talk                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDisplayOnScreenMask                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDisplayInteractGuide                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::OpenSubtitle(const class UObject* InWorldContext, const class FText& Speaker, const class FText& Talk, float DisplayTime, bool bIsDisplayOnScreenMask, bool bIsDisplayInteractGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "OpenSubtitle");

	Params::NarrativeFunctionLibrary_OpenSubtitle Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Speaker = std::move(Speaker);
	Parms.Talk = std::move(Talk);
	Parms.DisplayTime = DisplayTime;
	Parms.bIsDisplayOnScreenMask = bIsDisplayOnScreenMask;
	Parms.bIsDisplayInteractGuide = bIsDisplayInteractGuide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetCutSceneSkipIndicatorPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetCutSceneSkipIndicatorPercent(const class UObject* InWorldContext, float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetCutSceneSkipIndicatorPercent");

	Params::NarrativeFunctionLibrary_SetCutSceneSkipIndicatorPercent Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.NewPercent = NewPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetInteractGuideVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetInteractGuideVisibility(const class UObject* InWorldContext, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetInteractGuideVisibility");

	Params::NarrativeFunctionLibrary_SetInteractGuideVisibility Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetInteractSkipProhibited
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetInteractSkipProhibited(const class UObject* InWorldContext, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetInteractSkipProhibited");

	Params::NarrativeFunctionLibrary_SetInteractSkipProhibited Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetLeaveMultiplayIndicatorPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetLeaveMultiplayIndicatorPercent(const class UObject* InWorldContext, float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetLeaveMultiplayIndicatorPercent");

	Params::NarrativeFunctionLibrary_SetLeaveMultiplayIndicatorPercent Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.NewPercent = NewPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetShowCutSceneSkipIndicator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetShowCutSceneSkipIndicator(const class UObject* InWorldContext, bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetShowCutSceneSkipIndicator");

	Params::NarrativeFunctionLibrary_SetShowCutSceneSkipIndicator Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetShowLeaveMultiplayIndicator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetShowLeaveMultiplayIndicator(const class UObject* InWorldContext, bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetShowLeaveMultiplayIndicator");

	Params::NarrativeFunctionLibrary_SetShowLeaveMultiplayIndicator Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NarrativeFunctionLibrary.SetSkipProhibited
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNarrativeFunctionLibrary::SetSkipProhibited(const class UObject* InWorldContext, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NarrativeFunctionLibrary", "SetSkipProhibited");

	Params::NarrativeFunctionLibrary_SetSkipProhibited Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterActionVisualizer.GetVisualizeTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* ACharacterActionVisualizer::GetVisualizeTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "GetVisualizeTarget");

	Params::CharacterActionVisualizer_GetVisualizeTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterActionVisualizer.SetMoveDestinationShowFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterActionVisualizer::SetMoveDestinationShowFlag(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "SetMoveDestinationShowFlag");

	Params::CharacterActionVisualizer_SetMoveDestinationShowFlag Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterActionVisualizer.SetMovePathShowFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterActionVisualizer::SetMovePathShowFlag(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "SetMovePathShowFlag");

	Params::CharacterActionVisualizer_SetMovePathShowFlag Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterActionVisualizer.SetVisualizeTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterActionVisualizer::SetVisualizeTarget(class ACharacter* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "SetVisualizeTarget");

	Params::CharacterActionVisualizer_SetVisualizeTarget Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterActionVisualizer.IsShowMoveDestination
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterActionVisualizer::IsShowMoveDestination() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "IsShowMoveDestination");

	Params::CharacterActionVisualizer_IsShowMoveDestination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterActionVisualizer.IsShowMovePath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterActionVisualizer::IsShowMovePath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterActionVisualizer", "IsShowMovePath");

	Params::CharacterActionVisualizer_IsShowMovePath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScale");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScaleID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScaleID(int32 ID, const class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScaleID");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScaleID Parms{};

	Parms.ID = ID;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScaleSlender
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScaleSlender(const class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScaleSlender");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScaleSlender Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScaleStandard
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScaleStandard(const class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScaleStandard");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScaleStandard Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScaleThick
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScaleThick(const class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScaleThick");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScaleThick Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetHeadShapeScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetHeadShapeScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetHeadShapeScale");

	Params::CharacterCustomizeAnimInstance_GetHeadShapeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.SetBodyShapeAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeAnimInstance::SetBodyShapeAdjust(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "SetBodyShapeAdjust");

	Params::CharacterCustomizeAnimInstance_SetBodyShapeAdjust Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeAnimInstance.SetBodyShapeScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeAnimInstance::SetBodyShapeScale(int32 ID, const class FName BoneName, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "SetBodyShapeScale");

	Params::CharacterCustomizeAnimInstance_SetBodyShapeScale Parms{};

	Parms.ID = ID;
	Parms.BoneName = BoneName;
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeAnimInstance.SetBustShapeAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeAnimInstance::SetBustShapeAdjust(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "SetBustShapeAdjust");

	Params::CharacterCustomizeAnimInstance_SetBustShapeAdjust Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeAdjust
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeAnimInstance::GetBodyShapeAdjust() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeAdjust");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeAdjust Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBodyShapeScaleVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterCustomizeAnimInstance::GetBodyShapeScaleVector(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBodyShapeScaleVector");

	Params::CharacterCustomizeAnimInstance_GetBodyShapeScaleVector Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetBustShapeAdjust
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeAnimInstance::GetBustShapeAdjust() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetBustShapeAdjust");

	Params::CharacterCustomizeAnimInstance_GetBustShapeAdjust Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetCharacterCustomizeParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterCustomizeParameterReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeParameter UCharacterCustomizeAnimInstance::GetCharacterCustomizeParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetCharacterCustomizeParameter");

	Params::CharacterCustomizeAnimInstance_GetCharacterCustomizeParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeAnimInstance.GetFaceParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterCustomizeParameterFaceReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeParameterFace UCharacterCustomizeAnimInstance::GetFaceParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeAnimInstance", "GetFaceParameter");

	Params::CharacterCustomizeAnimInstance_GetFaceParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.ChangeAppearanceByConstructionScript
// (Final, Native, Protected, BlueprintCallable)

void UCharacterCustomizeComponent::ChangeAppearanceByConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "ChangeAppearanceByConstructionScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.GetCalvaryScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetCalvaryScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetCalvaryScale");

	Params::CharacterCustomizeComponent_GetCalvaryScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEarAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEarAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEarAngle");

	Params::CharacterCustomizeComponent_GetEarAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEarSharpness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEarSharpness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEarSharpness");

	Params::CharacterCustomizeComponent_GetEarSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEyeAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeAngle");

	Params::CharacterCustomizeComponent_GetEyeAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeClosingPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ECharacterCustomizeEye                  InEye                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEyeClosingPattern*                     OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetEyeClosingPattern(ECharacterCustomizeEye InEye, EEyeClosingPattern* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeClosingPattern");

	Params::CharacterCustomizeComponent_GetEyeClosingPattern Parms{};

	Parms.InEye = InEye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEyeDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeDistance");

	Params::CharacterCustomizeComponent_GetEyeDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeHighLightColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetEyeHighLightColor(const ECharacterCustomizeEye Eye, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeHighLightColor");

	Params::CharacterCustomizeComponent_GetEyeHighLightColor Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeHorizontalSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEyeHorizontalSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeHorizontalSize");

	Params::CharacterCustomizeComponent_GetEyeHorizontalSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeMouthBalance
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetEyeMouthBalance(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeMouthBalance");

	Params::CharacterCustomizeComponent_GetEyeMouthBalance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeComponent.GetEyeVerticalSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeComponent::GetEyeVerticalSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetEyeVerticalSize");

	Params::CharacterCustomizeComponent_GetEyeVerticalSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetFaceType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetFaceType(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetFaceType");

	Params::CharacterCustomizeComponent_GetFaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeComponent.GetHairAppendColorEnabled
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool*                                   OutEnabled                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairAppendColorEnabled(bool* OutEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairAppendColorEnabled");

	Params::CharacterCustomizeComponent_GetHairAppendColorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEnabled != nullptr)
		*OutEnabled = Parms.OutEnabled;
}


// Function Extensions.CharacterCustomizeComponent.GetHairColorAppendPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutPattern                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairColorAppendPattern(class FName* OutPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairColorAppendPattern");

	Params::CharacterCustomizeComponent_GetHairColorAppendPattern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPattern != nullptr)
		*OutPattern = Parms.OutPattern;
}


// Function Extensions.CharacterCustomizeComponent.GetHairColorAppendPatternOffsetU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairColorAppendPatternOffsetU(float* OutOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairColorAppendPatternOffsetU");

	Params::CharacterCustomizeComponent_GetHairColorAppendPatternOffsetU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOffset != nullptr)
		*OutOffset = Parms.OutOffset;
}


// Function Extensions.CharacterCustomizeComponent.GetHairColorAppendPatternOffsetV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairColorAppendPatternOffsetV(float* OutOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairColorAppendPatternOffsetV");

	Params::CharacterCustomizeComponent_GetHairColorAppendPatternOffsetV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOffset != nullptr)
		*OutOffset = Parms.OutOffset;
}


// Function Extensions.CharacterCustomizeComponent.GetHairColorAppendPatternScaleU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutScale                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairColorAppendPatternScaleU(float* OutScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairColorAppendPatternScaleU");

	Params::CharacterCustomizeComponent_GetHairColorAppendPatternScaleU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScale != nullptr)
		*OutScale = Parms.OutScale;
}


// Function Extensions.CharacterCustomizeComponent.GetHairColorAppendPatternScaleV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutScale                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairColorAppendPatternScaleV(float* OutScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairColorAppendPatternScaleV");

	Params::CharacterCustomizeComponent_GetHairColorAppendPatternScaleV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScale != nullptr)
		*OutScale = Parms.OutScale;
}


// Function Extensions.CharacterCustomizeComponent.GetHairHighlightIntensity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetHairHighlightIntensity(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairHighlightIntensity");

	Params::CharacterCustomizeComponent_GetHairHighlightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeComponent.GetMouthType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetMouthType(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetMouthType");

	Params::CharacterCustomizeComponent_GetMouthType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeComponent.GetShadowMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USkeletalMeshComponent*>*  OutShadowMeshes                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::GetShadowMeshes(TArray<class USkeletalMeshComponent*>* OutShadowMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetShadowMeshes");

	Params::CharacterCustomizeComponent_GetShadowMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShadowMeshes != nullptr)
		*OutShadowMeshes = std::move(Parms.OutShadowMeshes);
}


// Function Extensions.CharacterCustomizeComponent.IsAutoBlink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeComponent::IsAutoBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "IsAutoBlink");

	Params::CharacterCustomizeComponent_IsAutoBlink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.IsEnableVanishProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeComponent::IsEnableVanishProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "IsEnableVanishProcess");

	Params::CharacterCustomizeComponent_IsEnableVanishProcess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.MulticastParameterSync
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FCharacterCustomizeParameter&InParam                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::MulticastParameterSync(const struct FCharacterCustomizeParameter& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "MulticastParameterSync");

	Params::CharacterCustomizeComponent_MulticastParameterSync Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.OnRep_CustomizeParameter
// (Final, Native, Protected)

void UCharacterCustomizeComponent::OnRep_CustomizeParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "OnRep_CustomizeParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.ServerParameterSync
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FCharacterCustomizeParameter&InParam                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::ServerParameterSync(const struct FCharacterCustomizeParameter& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "ServerParameterSync");

	Params::CharacterCustomizeComponent_ServerParameterSync Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetAutoBlink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsAuto                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetAutoBlink(bool InIsAuto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetAutoBlink");

	Params::CharacterCustomizeComponent_SetAutoBlink Parms{};

	Parms.InIsAuto = InIsAuto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetCalvaryScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetCalvaryScale(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetCalvaryScale");

	Params::CharacterCustomizeComponent_SetCalvaryScale Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetCharacterCustomizeParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterCustomizeParameter&InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetCharacterCustomizeParameter(const struct FCharacterCustomizeParameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetCharacterCustomizeParameter");

	Params::CharacterCustomizeComponent_SetCharacterCustomizeParameter Parms{};

	Parms.InParameter = std::move(InParameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEarAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEarAngle(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEarAngle");

	Params::CharacterCustomizeComponent_SetEarAngle Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEarSharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEarSharpness(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEarSharpness");

	Params::CharacterCustomizeComponent_SetEarSharpness Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEnableVanishProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEnableVanishProcess(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEnableVanishProcess");

	Params::CharacterCustomizeComponent_SetEnableVanishProcess Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeAngle(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeAngle");

	Params::CharacterCustomizeComponent_SetEyeAngle Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeClosingPattern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeEye                  InEye                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEyeClosingPattern                      InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeClosingPattern(ECharacterCustomizeEye InEye, EEyeClosingPattern InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeClosingPattern");

	Params::CharacterCustomizeComponent_SetEyeClosingPattern Parms{};

	Parms.InEye = InEye;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeDistance(float InDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeDistance");

	Params::CharacterCustomizeComponent_SetEyeDistance Parms{};

	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeHorizontalSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeHorizontalSize(float InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeHorizontalSize");

	Params::CharacterCustomizeComponent_SetEyeHorizontalSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeMouthBalance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeMouthBalance(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeMouthBalance");

	Params::CharacterCustomizeComponent_SetEyeMouthBalance Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetEyeVerticalSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetEyeVerticalSize(float InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetEyeVerticalSize");

	Params::CharacterCustomizeComponent_SetEyeVerticalSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetFaceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetFaceType(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetFaceType");

	Params::CharacterCustomizeComponent_SetFaceType Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairAppendColorEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairAppendColorEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairAppendColorEnabled");

	Params::CharacterCustomizeComponent_SetHairAppendColorEnabled Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairColorAppendPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InPattern                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairColorAppendPattern(const class FName& InPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairColorAppendPattern");

	Params::CharacterCustomizeComponent_SetHairColorAppendPattern Parms{};

	Parms.InPattern = InPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairColorAppendPatternOffsetU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InOffset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairColorAppendPatternOffsetU(const float InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairColorAppendPatternOffsetU");

	Params::CharacterCustomizeComponent_SetHairColorAppendPatternOffsetU Parms{};

	Parms.InOffset = InOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairColorAppendPatternOffsetV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InOffset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairColorAppendPatternOffsetV(const float InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairColorAppendPatternOffsetV");

	Params::CharacterCustomizeComponent_SetHairColorAppendPatternOffsetV Parms{};

	Parms.InOffset = InOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairColorAppendPatternScaleU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairColorAppendPatternScaleU(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairColorAppendPatternScaleU");

	Params::CharacterCustomizeComponent_SetHairColorAppendPatternScaleU Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairColorAppendPatternScaleV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairColorAppendPatternScaleV(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairColorAppendPatternScaleV");

	Params::CharacterCustomizeComponent_SetHairColorAppendPatternScaleV Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetHairHighlightIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetHairHighlightIntensity(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetHairHighlightIntensity");

	Params::CharacterCustomizeComponent_SetHairHighlightIntensity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.SetMouthType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeComponent::SetMouthType(class FName InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "SetMouthType");

	Params::CharacterCustomizeComponent_SetMouthType Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.UpdateCharacter
// (Final, Native, Public, BlueprintCallable)

void UCharacterCustomizeComponent::UpdateCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "UpdateCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeComponent.VanishProcess_Begin
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeComponent::VanishProcess_Begin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "VanishProcess_Begin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeComponent.VanishProcess_End
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeComponent::VanishProcess_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "VanishProcess_End");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeComponent.GetAllMeshes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeRoot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class USkeletalMeshComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class USkeletalMeshComponent*> UCharacterCustomizeComponent::GetAllMeshes(bool bIncludeRoot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetAllMeshes");

	Params::CharacterCustomizeComponent_GetAllMeshes Parms{};

	Parms.bIncludeRoot = bIncludeRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetCharacterCustomizeParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterCustomizeParameterReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeParameter UCharacterCustomizeComponent::GetCharacterCustomizeParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetCharacterCustomizeParameter");

	Params::CharacterCustomizeComponent_GetCharacterCustomizeParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetHairPartMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECharacterCustomizeHairPart       InPart                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCharacterCustomizeComponent::GetHairPartMesh(const ECharacterCustomizeHairPart InPart) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairPartMesh");

	Params::CharacterCustomizeComponent_GetHairPartMesh Parms{};

	Parms.InPart = InPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeComponent.GetHairSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCharacterCustomizeComponent::GetHairSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeComponent", "GetHairSkeletalMeshComponent");

	Params::CharacterCustomizeComponent_GetHairSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CompressCharacterCustomizeParameterFunctionLibrary.CompressCharacterCustomizeParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterCustomizeParameter&InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompressedCharacterCustomizeParameterReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCompressedCharacterCustomizeParameter UCompressCharacterCustomizeParameterFunctionLibrary::CompressCharacterCustomizeParameter(const struct FCharacterCustomizeParameter& InParameter, const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompressCharacterCustomizeParameterFunctionLibrary", "CompressCharacterCustomizeParameter");

	Params::CompressCharacterCustomizeParameterFunctionLibrary_CompressCharacterCustomizeParameter Parms{};

	Parms.InParameter = std::move(InParameter);
	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CompressCharacterCustomizeParameterFunctionLibrary.DecompressCharacterCustomizeParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCompressedCharacterCustomizeParameter&InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeParameter     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCharacterCustomizeParameter UCompressCharacterCustomizeParameterFunctionLibrary::DecompressCharacterCustomizeParameter(const struct FCompressedCharacterCustomizeParameter& InParameter, const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompressCharacterCustomizeParameterFunctionLibrary", "DecompressCharacterCustomizeParameter");

	Params::CompressCharacterCustomizeParameterFunctionLibrary_DecompressCharacterCustomizeParameter Parms{};

	Parms.InParameter = std::move(InParameter);
	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.CameraResetForBody
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::CameraResetForBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "CameraResetForBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.CameraResetForFace
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::CameraResetForFace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "CameraResetForFace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.CameraResetPressed
// (Final, Native, Protected)

void ACharacterCustomizePawn::CameraResetPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "CameraResetPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.ChangeAttachBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::ChangeAttachBone(bool Direction, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "ChangeAttachBone");

	Params::CharacterCustomizePawn_ChangeAttachBone Parms{};

	Parms.Direction = Direction;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.GetAccessoryTransforms
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEulerAngleTransform*            LocalRoot                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            LocalOrient                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            LocalMesh                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::GetAccessoryTransforms(struct FEulerAngleTransform* LocalRoot, struct FEulerAngleTransform* LocalOrient, struct FEulerAngleTransform* LocalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetAccessoryTransforms");

	Params::CharacterCustomizePawn_GetAccessoryTransforms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LocalRoot != nullptr)
		*LocalRoot = std::move(Parms.LocalRoot);

	if (LocalOrient != nullptr)
		*LocalOrient = std::move(Parms.LocalOrient);

	if (LocalMesh != nullptr)
		*LocalMesh = std::move(Parms.LocalMesh);
}


// Function Extensions.CharacterCustomizePawn.GetAttachInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Name_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            LocalRoot                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            LocalOrient                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            LocalMesh                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::GetAttachInfo(class FName* Name_0, struct FEulerAngleTransform* LocalRoot, struct FEulerAngleTransform* LocalOrient, struct FEulerAngleTransform* LocalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetAttachInfo");

	Params::CharacterCustomizePawn_GetAttachInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = Parms.Name_0;

	if (LocalRoot != nullptr)
		*LocalRoot = std::move(Parms.LocalRoot);

	if (LocalOrient != nullptr)
		*LocalOrient = std::move(Parms.LocalOrient);

	if (LocalMesh != nullptr)
		*LocalMesh = std::move(Parms.LocalMesh);
}


// Function Extensions.CharacterCustomizePawn.GetAttachmentPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform ACharacterCustomizePawn::GetAttachmentPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetAttachmentPosition");

	Params::CharacterCustomizePawn_GetAttachmentPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetAttachmentRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator ACharacterCustomizePawn::GetAttachmentRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetAttachmentRotation");

	Params::CharacterCustomizePawn_GetAttachmentRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetAttachmentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector ACharacterCustomizePawn::GetAttachmentScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetAttachmentScale");

	Params::CharacterCustomizePawn_GetAttachmentScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetCameraMoveSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIsMouse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizePawn::GetCameraMoveSpeed(bool bIsMouse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetCameraMoveSpeed");

	Params::CharacterCustomizePawn_GetCameraMoveSpeed Parms{};

	Parms.bIsMouse = bIsMouse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetCameraResetLocationForBody
// (Final, Native, Protected, HasDefaults)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector ACharacterCustomizePawn::GetCameraResetLocationForBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetCameraResetLocationForBody");

	Params::CharacterCustomizePawn_GetCameraResetLocationForBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetCameraRotateSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIsMouse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizePawn::GetCameraRotateSpeed(bool bIsMouse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetCameraRotateSpeed");

	Params::CharacterCustomizePawn_GetCameraRotateSpeed Parms{};

	Parms.bIsMouse = bIsMouse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetMoveSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizePawn::GetMoveSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetMoveSpeed");

	Params::CharacterCustomizePawn_GetMoveSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetRotateSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizePawn::GetRotateSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetRotateSpeed");

	Params::CharacterCustomizePawn_GetRotateSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.GetScaleSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizePawn::GetScaleSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "GetScaleSpeed");

	Params::CharacterCustomizePawn_GetScaleSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizePawn.Initialize
// (Final, Native, Public)

void ACharacterCustomizePawn::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.LookUp
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::LookUp(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "LookUp");

	Params::CharacterCustomizePawn_LookUp Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.MoveAccessory
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::MoveAccessory(const struct FVector& Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "MoveAccessory");

	Params::CharacterCustomizePawn_MoveAccessory Parms{};

	Parms.Delta = std::move(Delta);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.MoveForward
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::MoveForward(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "MoveForward");

	Params::CharacterCustomizePawn_MoveForward Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.MoveRight
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::MoveRight(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "MoveRight");

	Params::CharacterCustomizePawn_MoveRight Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.MoveUp
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::MoveUp(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "MoveUp");

	Params::CharacterCustomizePawn_MoveUp Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveAway
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMouseWheel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveAway(bool bMouseWheel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveAway");

	Params::CharacterCustomizePawn_OnInputMoveAway Parms{};

	Parms.bMouseWheel = bMouseWheel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveCloser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMouseWheel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveCloser(bool bMouseWheel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveCloser");

	Params::CharacterCustomizePawn_OnInputMoveCloser Parms{};

	Parms.bMouseWheel = bMouseWheel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveDown(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveDown");

	Params::CharacterCustomizePawn_OnInputMoveDown Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveLeft(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveLeft");

	Params::CharacterCustomizePawn_OnInputMoveLeft Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveRight");

	Params::CharacterCustomizePawn_OnInputMoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputMoveUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputMoveUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputMoveUp");

	Params::CharacterCustomizePawn_OnInputMoveUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputRotateDown
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::OnInputRotateDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputRotateDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputRotateLeft
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::OnInputRotateLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputRotateLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputRotateRight
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::OnInputRotateRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputRotateRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputRotateUp
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizePawn::OnInputRotateUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputRotateUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputScaleDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMouseWheel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputScaleDown(bool bMouseWheel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputScaleDown");

	Params::CharacterCustomizePawn_OnInputScaleDown Parms{};

	Parms.bMouseWheel = bMouseWheel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.OnInputScaleUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMouseWheel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::OnInputScaleUp(bool bMouseWheel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "OnInputScaleUp");

	Params::CharacterCustomizePawn_OnInputScaleUp Parms{};

	Parms.bMouseWheel = bMouseWheel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.PitchRollRotateAccessory
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Addition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::PitchRollRotateAccessory(const struct FRotator& Addition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "PitchRollRotateAccessory");

	Params::CharacterCustomizePawn_PitchRollRotateAccessory Parms{};

	Parms.Addition = std::move(Addition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.PolarMoveAccessory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::PolarMoveAccessory(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "PolarMoveAccessory");

	Params::CharacterCustomizePawn_PolarMoveAccessory Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.ResetLocation
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FVector&                   PawnLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CharacterLocation                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::ResetLocation(const struct FVector& PawnLocation, const struct FVector& CharacterLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "ResetLocation");

	Params::CharacterCustomizePawn_ResetLocation Parms{};

	Parms.PawnLocation = std::move(PawnLocation);
	Parms.CharacterLocation = std::move(CharacterLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.RotateAccessory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::RotateAccessory(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "RotateAccessory");

	Params::CharacterCustomizePawn_RotateAccessory Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetAccessoryTransforms
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FEulerAngleTransform&      LocalRoot                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FEulerAngleTransform&      LocalOrient                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  OrientRotate                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetAccessoryTransforms(const struct FEulerAngleTransform& LocalRoot, const struct FEulerAngleTransform& LocalOrient, const struct FRotator& OrientRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetAccessoryTransforms");

	Params::CharacterCustomizePawn_SetAccessoryTransforms Parms{};

	Parms.LocalRoot = std::move(LocalRoot);
	Parms.LocalOrient = std::move(LocalOrient);
	Parms.OrientRotate = std::move(OrientRotate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetAttachmentPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InTransform                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetAttachmentPosition(const struct FVector& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetAttachmentPosition");

	Params::CharacterCustomizePawn_SetAttachmentPosition Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetAttachmentScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetAttachmentScale(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetAttachmentScale");

	Params::CharacterCustomizePawn_SetAttachmentScale Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetCameraOperationProhibited
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InProhibited                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetCameraOperationProhibited(bool InProhibited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetCameraOperationProhibited");

	Params::CharacterCustomizePawn_SetCameraOperationProhibited Parms{};

	Parms.InProhibited = InProhibited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetCameraOperationProhibitedByOnMouseMenuPiece
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuPieceBase*                   MenuPiece                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InProhibited                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetCameraOperationProhibitedByOnMouseMenuPiece(class UMenuPieceBase* MenuPiece, bool InProhibited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetCameraOperationProhibitedByOnMouseMenuPiece");

	Params::CharacterCustomizePawn_SetCameraOperationProhibitedByOnMouseMenuPiece Parms{};

	Parms.MenuPiece = MenuPiece;
	Parms.InProhibited = InProhibited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetMaxAccessoryScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             MaxScale                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetMaxAccessoryScale(const float MaxScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetMaxAccessoryScale");

	Params::CharacterCustomizePawn_SetMaxAccessoryScale Parms{};

	Parms.MaxScale = MaxScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.SetMinAccessoryScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             MinScale                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::SetMinAccessoryScale(const float MinScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "SetMinAccessoryScale");

	Params::CharacterCustomizePawn_SetMinAccessoryScale Parms{};

	Parms.MinScale = MinScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizePawn.Turn
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizePawn::Turn(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizePawn", "Turn");

	Params::CharacterCustomizePawn_Turn Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ApplyAppAvatarPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAppAvatarPresetSlotInSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ApplyAppAvatarPreset(const ECharacterCustomizeAppAvatarPresetSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ApplyAppAvatarPreset");

	Params::CharacterCustomizeSystem_ApplyAppAvatarPreset Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ApplyUserAvatarParameterFromSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeUserAvatarSlot InCharacterSlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ApplyUserAvatarParameterFromSlot(const ECharacterCustomizeUserAvatarSlot InCharacterSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ApplyUserAvatarParameterFromSlot");

	Params::CharacterCustomizeSystem_ApplyUserAvatarParameterFromSlot Parms{};

	Parms.InCharacterSlot = InCharacterSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.BackupCustomizeParameter
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::BackupCustomizeParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "BackupCustomizeParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.BeginCharacterCustomize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::BeginCharacterCustomize(const ECharacterCustomizeType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "BeginCharacterCustomize");

	Params::CharacterCustomizeSystem_BeginCharacterCustomize Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.BindSystemLoadCompleteEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::BindSystemLoadCompleteEvent(TDelegate<void()> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "BindSystemLoadCompleteEvent");

	Params::CharacterCustomizeSystem_BindSystemLoadCompleteEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.EndCharacterCustomize
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::EndCharacterCustomize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "EndCharacterCustomize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>*       OutAnimClass                                           (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryAnimClass(const class FName& CategoryName, const class FName& AccessoryRowName, TSubclassOf<class UAnimInstance>* OutAnimClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryAnimClass");

	Params::CharacterCustomizeSystem_GetAccessoryAnimClass Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimClass != nullptr)
		*OutAnimClass = Parms.OutAnimClass;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryAttachTo
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            RowName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryAttachTo(const ECharacterCustomizeAccessorySlot Slot, class FName* RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryAttachTo");

	Params::CharacterCustomizeSystem_GetAccessoryAttachTo Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RowName != nullptr)
		*RowName = Parms.RowName;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryAttachToDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText*                            OutDisplayName                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryAttachToDisplayName(const class FName& RowName, class FText* OutDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryAttachToDisplayName");

	Params::CharacterCustomizeSystem_GetAccessoryAttachToDisplayName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDisplayName != nullptr)
		*OutDisplayName = std::move(Parms.OutDisplayName);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryAttachToList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryAttachToList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryAttachToList");

	Params::CharacterCustomizeSystem_GetAccessoryAttachToList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryAttachToSocketInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachTargetMesh*                      OutAttachTarget                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryAttachToSocketInfo(const class FName& RowName, class FName* OutName, EAttachTargetMesh* OutAttachTarget, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryAttachToSocketInfo");

	Params::CharacterCustomizeSystem_GetAccessoryAttachToSocketInfo Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = Parms.OutName;

	if (OutAttachTarget != nullptr)
		*OutAttachTarget = Parms.OutAttachTarget;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryCategoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryCategoryList(TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryCategoryList");

	Params::CharacterCustomizeSystem_GetAccessoryCategoryList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryCategoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryCategoryThumbnail(const class FName& CategoryName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryCategoryThumbnail");

	Params::CharacterCustomizeSystem_GetAccessoryCategoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryColor
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeAccessoryColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryColor(const ECharacterCustomizeAccessorySlot Slot, const ECharacterCustomizeAccessoryColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryColor");

	Params::CharacterCustomizeSystem_GetAccessoryColor Parms{};

	Parms.Slot = Slot;
	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryColorSlotNum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutSlotNum                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryColorSlotNum(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryColorSlotNum");

	Params::CharacterCustomizeSystem_GetAccessoryColorSlotNum Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlotNum != nullptr)
		*OutSlotNum = Parms.OutSlotNum;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryCost
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCost                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryCost(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryCost");

	Params::CharacterCustomizeSystem_GetAccessoryCost Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCost != nullptr)
		*OutCost = Parms.OutCost;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCategoryIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutAccessoryIndex                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryIndex(const class FName& CategoryName, const class FName& AccessoryRowName, int32* OutCategoryIndex, int32* OutAccessoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryIndex");

	Params::CharacterCustomizeSystem_GetAccessoryIndex Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCategoryIndex != nullptr)
		*OutCategoryIndex = Parms.OutCategoryIndex;

	if (OutAccessoryIndex != nullptr)
		*OutAccessoryIndex = Parms.OutAccessoryIndex;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryList(const class FName& CategoryName, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryList");

	Params::CharacterCustomizeSystem_GetAccessoryList Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryMaxCapacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACharacterCustomizeSystem::GetAccessoryMaxCapacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryMaxCapacity");

	Params::CharacterCustomizeSystem_GetAccessoryMaxCapacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryMaxColor
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  MaxColor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryMaxColor(const ECharacterCustomizeAccessorySlot Slot, int32* MaxColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryMaxColor");

	Params::CharacterCustomizeSystem_GetAccessoryMaxColor Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MaxColor != nullptr)
		*MaxColor = Parms.MaxColor;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            RowName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryMesh(const ECharacterCustomizeAccessorySlot Slot, class FName* Category, class FName* RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryMesh");

	Params::CharacterCustomizeSystem_GetAccessoryMesh Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (RowName != nullptr)
		*RowName = Parms.RowName;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryOrientTransform
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            Value                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryOrientTransform(const ECharacterCustomizeAccessorySlot Slot, struct FEulerAngleTransform* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryOrientTransform");

	Params::CharacterCustomizeSystem_GetAccessoryOrientTransform Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      PresetRowName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableAccessoryPreset*OutAccessoryPreset                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryPreset(const class FName& CategoryName, const class FName& PresetRowName, struct FCharacterCustomizeDataTableAccessoryPreset* OutAccessoryPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryPreset");

	Params::CharacterCustomizeSystem_GetAccessoryPreset Parms{};

	Parms.CategoryName = CategoryName;
	Parms.PresetRowName = PresetRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAccessoryPreset != nullptr)
		*OutAccessoryPreset = std::move(Parms.OutAccessoryPreset);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryRootTransform
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            Value                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryRootTransform(const ECharacterCustomizeAccessorySlot Slot, struct FEulerAngleTransform* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryRootTransform");

	Params::CharacterCustomizeSystem_GetAccessoryRootTransform Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryThumbnail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       OutThumbnail                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryThumbnail(const class FName& CategoryName, const class FName& AccessoryRowName, TSoftObjectPtr<class UTexture2D>* OutThumbnail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryThumbnail");

	Params::CharacterCustomizeSystem_GetAccessoryThumbnail Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutThumbnail != nullptr)
		*OutThumbnail = Parms.OutThumbnail;
}


// Function Extensions.CharacterCustomizeSystem.GetAccessoryTransforms
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEulerAngleTransform*            RootTransform                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            OrientTransform                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEulerAngleTransform*            MeshTransform                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAccessoryTransforms(struct FEulerAngleTransform* RootTransform, struct FEulerAngleTransform* OrientTransform, struct FEulerAngleTransform* MeshTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAccessoryTransforms");

	Params::CharacterCustomizeSystem_GetAccessoryTransforms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RootTransform != nullptr)
		*RootTransform = std::move(Parms.RootTransform);

	if (OrientTransform != nullptr)
		*OrientTransform = std::move(Parms.OrientTransform);

	if (MeshTransform != nullptr)
		*MeshTransform = std::move(Parms.MeshTransform);
}


// Function Extensions.CharacterCustomizeSystem.GetAppAvatarPresetCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutPresetCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetAppAvatarPresetCount(const ECharacterCustomizeGender InGender, int32* OutPresetCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAppAvatarPresetCount");

	Params::CharacterCustomizeSystem_GetAppAvatarPresetCount Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPresetCount != nullptr)
		*OutPresetCount = Parms.OutPresetCount;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairBackDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairBackDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairBackDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairBackDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairFrontDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairFrontDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairFrontDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairFrontDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairFrontSideDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairFrontSideDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairFrontSideDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairFrontSideDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairOtherDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairOtherDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairOtherDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairOtherDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairSideDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairSideDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairSideDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairSideDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvailableHairTopDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairBaseName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetAvailableHairTopDataTableRowNames(class FName HairBaseName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvailableHairTopDataTableRowNames");

	Params::CharacterCustomizeSystem_GetAvailableHairTopDataTableRowNames Parms{};

	Parms.HairBaseName = HairBaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetAvatarIconTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ACharacterCustomizeSystem::GetAvatarIconTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetAvatarIconTexture");

	Params::CharacterCustomizeSystem_GetAvatarIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBeard
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBeard(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBeard");

	Params::CharacterCustomizeSystem_GetBeard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBeardColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBeardColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBeardColor");

	Params::CharacterCustomizeSystem_GetBeardColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetBeardDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableBeardReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableBeard ACharacterCustomizeSystem::GetBeardDataByRowName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBeardDataByRowName");

	Params::CharacterCustomizeSystem_GetBeardDataByRowName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBeardRowNamesForFaceType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InFaceType                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetBeardRowNamesForFaceType(const class FName& InFaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBeardRowNamesForFaceType");

	Params::CharacterCustomizeSystem_GetBeardRowNamesForFaceType Parms{};

	Parms.InFaceType = InFaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBodyPartShape
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAdvancedBodyPartInPart                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBodyPartShape(const ECharacterCustomizeAdvancedBodyPart InPart, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBodyPartShape");

	Params::CharacterCustomizeSystem_GetBodyPartShape Parms{};

	Parms.InPart = InPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBodyShape
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBodyShape(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBodyShape");

	Params::CharacterCustomizeSystem_GetBodyShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBodyShapeType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ECharacterCustomizeBodyShape*           OutType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBodyShapeType(ECharacterCustomizeBodyShape* OutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBodyShapeType");

	Params::CharacterCustomizeSystem_GetBodyShapeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutType != nullptr)
		*OutType = Parms.OutType;
}


// Function Extensions.CharacterCustomizeSystem.GetBootsColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeBootsColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBootsColor(const ECharacterCustomizeBootsColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBootsColor");

	Params::CharacterCustomizeSystem_GetBootsColor Parms{};

	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetBootsMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBootsMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBootsMesh");

	Params::CharacterCustomizeSystem_GetBootsMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetBootsPartVisibility
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCustomizeClothPartVisibility* OutVisibility                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetBootsPartVisibility(const int32 InPartSlot, ECharacterCustomizeClothPartVisibility* OutVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetBootsPartVisibility");

	Params::CharacterCustomizeSystem_GetBootsPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVisibility != nullptr)
		*OutVisibility = Parms.OutVisibility;
}


// Function Extensions.CharacterCustomizeSystem.GetCalvaryScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetCalvaryScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCalvaryScale");

	Params::CharacterCustomizeSystem_GetCalvaryScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizeDataManagerClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class UCharacterCustomizeDataManager>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UCharacterCustomizeDataManager> ACharacterCustomizeSystem::GetCharacterCustomizeDataManagerClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizeDataManagerClass");

	Params::CharacterCustomizeSystem_GetCharacterCustomizeDataManagerClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizeInitialLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACharacterCustomizeSystem::GetCharacterCustomizeInitialLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizeInitialLocation");

	Params::CharacterCustomizeSystem_GetCharacterCustomizeInitialLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizeParamSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetCharacterCustomizeParamSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizeParamSize");

	Params::CharacterCustomizeSystem_GetCharacterCustomizeParamSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterScale
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetCharacterScale(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterScale");

	Params::CharacterCustomizeSystem_GetCharacterScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetColorDataFromColorPalette
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ColorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableColor*ColorData                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetColorDataFromColorPalette(const class FName& PaletteName, const class FName& ColorName, struct FCharacterCustomizeDataTableColor* ColorData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetColorDataFromColorPalette");

	Params::CharacterCustomizeSystem_GetColorDataFromColorPalette Parms{};

	Parms.PaletteName = PaletteName;
	Parms.ColorName = ColorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ColorData != nullptr)
		*ColorData = std::move(Parms.ColorData);
}


// Function Extensions.CharacterCustomizeSystem.GetColorPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableColorPaletteList*OutPalette                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetColorPalette(const class FName& PaletteRowName, struct FCharacterCustomizeDataTableColorPaletteList* OutPalette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetColorPalette");

	Params::CharacterCustomizeSystem_GetColorPalette Parms{};

	Parms.PaletteRowName = PaletteRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPalette != nullptr)
		*OutPalette = std::move(Parms.OutPalette);
}


// Function Extensions.CharacterCustomizeSystem.GetColorPaletteData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableColorPaletteListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableColorPaletteList ACharacterCustomizeSystem::GetColorPaletteData(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetColorPaletteData");

	Params::CharacterCustomizeSystem_GetColorPaletteData Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetColorPalettePack
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       PackRowName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterCustomizeDataTableColorPalettePackDetail>*OutPaletteList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetColorPalettePack(const class FName PackRowName, TArray<struct FCharacterCustomizeDataTableColorPalettePackDetail>* OutPaletteList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetColorPalettePack");

	Params::CharacterCustomizeSystem_GetColorPalettePack Parms{};

	Parms.PackRowName = PackRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPaletteList != nullptr)
		*OutPaletteList = std::move(Parms.OutPaletteList);
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableEyeMouthBalanceList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableEyeMouthBalanceList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableEyeMouthBalanceList");

	Params::CharacterCustomizeSystem_GetDataTableEyeMouthBalanceList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairBackList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairBackList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairBackList");

	Params::CharacterCustomizeSystem_GetDataTableHairBackList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairBaseList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairBaseList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairBaseList");

	Params::CharacterCustomizeSystem_GetDataTableHairBaseList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairColorAppendPatternList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairColorAppendPatternList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairColorAppendPatternList");

	Params::CharacterCustomizeSystem_GetDataTableHairColorAppendPatternList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairCurlPresetList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairCurlPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairCurlPresetList");

	Params::CharacterCustomizeSystem_GetDataTableHairCurlPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairFrontList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairFrontList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairFrontList");

	Params::CharacterCustomizeSystem_GetDataTableHairFrontList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairFrontSideList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairFrontSideList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairFrontSideList");

	Params::CharacterCustomizeSystem_GetDataTableHairFrontSideList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairOtherList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairOtherList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairOtherList");

	Params::CharacterCustomizeSystem_GetDataTableHairOtherList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairSetList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairSetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairSetList");

	Params::CharacterCustomizeSystem_GetDataTableHairSetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairSideList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairSideList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairSideList");

	Params::CharacterCustomizeSystem_GetDataTableHairSideList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairTaperPresetList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairTaperPresetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairTaperPresetList");

	Params::CharacterCustomizeSystem_GetDataTableHairTaperPresetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetDataTableHairTopList
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ACharacterCustomizeSystem::GetDataTableHairTopList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetDataTableHairTopList");

	Params::CharacterCustomizeSystem_GetDataTableHairTopList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEarAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEarAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEarAngle");

	Params::CharacterCustomizeSystem_GetEarAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEarSharpness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEarSharpness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEarSharpness");

	Params::CharacterCustomizeSystem_GetEarSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEyeAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeAngle");

	Params::CharacterCustomizeSystem_GetEyeAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeAppendColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeAppendColor(const ECharacterCustomizeEye Eye, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeAppendColor");

	Params::CharacterCustomizeSystem_GetEyeAppendColor Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeAppendColor2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeAppendColor2(const ECharacterCustomizeEye Eye, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeAppendColor2");

	Params::CharacterCustomizeSystem_GetEyeAppendColor2 Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeBaseColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeBaseColor(const ECharacterCustomizeEye Eye, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeBaseColor");

	Params::CharacterCustomizeSystem_GetEyeBaseColor Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeBaseDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableTextureListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableTextureList ACharacterCustomizeSystem::GetEyeBaseDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeBaseDataByRowName");

	Params::CharacterCustomizeSystem_GetEyeBaseDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeBaseDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyeBaseDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeBaseDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyeBaseDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeBaseMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeBaseMap(const ECharacterCustomizeEye Eye, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeBaseMap");

	Params::CharacterCustomizeSystem_GetEyeBaseMap Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowAngleByBone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowAngleByBone(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowAngleByBone");

	Params::CharacterCustomizeSystem_GetEyebrowAngleByBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowAngleByMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowAngleByMaterial(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowAngleByMaterial");

	Params::CharacterCustomizeSystem_GetEyebrowAngleByMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowColor");

	Params::CharacterCustomizeSystem_GetEyebrowColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowDistance
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowDistance(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowDistance");

	Params::CharacterCustomizeSystem_GetEyebrowDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowMap(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowMap");

	Params::CharacterCustomizeSystem_GetEyebrowMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowMapDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableEyebrowTextureReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableEyebrowTexture ACharacterCustomizeSystem::GetEyebrowMapDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowMapDataByRowName");

	Params::CharacterCustomizeSystem_GetEyebrowMapDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowMapDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyebrowMapDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowMapDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyebrowMapDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowPositionVByBone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowPositionVByBone(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowPositionVByBone");

	Params::CharacterCustomizeSystem_GetEyebrowPositionVByBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowPositionVByMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowPositionVByMaterial(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowPositionVByMaterial");

	Params::CharacterCustomizeSystem_GetEyebrowPositionVByMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowRaisingPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowRaisingPattern(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowRaisingPattern");

	Params::CharacterCustomizeSystem_GetEyebrowRaisingPattern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowRaisingPatternDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableEyebrowRaisingPatternReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableEyebrowRaisingPattern ACharacterCustomizeSystem::GetEyebrowRaisingPatternDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowRaisingPatternDataByRowName");

	Params::CharacterCustomizeSystem_GetEyebrowRaisingPatternDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowRaisingPatternDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyebrowRaisingPatternDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowRaisingPatternDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyebrowRaisingPatternDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowScaleH
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowScaleH(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowScaleH");

	Params::CharacterCustomizeSystem_GetEyebrowScaleH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyebrowScaleV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyebrowScaleV(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyebrowScaleV");

	Params::CharacterCustomizeSystem_GetEyebrowScaleV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeCats
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeCats(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeCats");

	Params::CharacterCustomizeSystem_GetEyeCats Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeClosingPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ECharacterCustomizeEye                  InEye                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEyeClosingPattern*                     OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeClosingPattern(ECharacterCustomizeEye InEye, EEyeClosingPattern* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeClosingPattern");

	Params::CharacterCustomizeSystem_GetEyeClosingPattern Parms{};

	Parms.InEye = InEye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeDetailDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableEyeTextureReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableEyeTexture ACharacterCustomizeSystem::GetEyeDetailDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeDetailDataByRowName");

	Params::CharacterCustomizeSystem_GetEyeDetailDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeDetailDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyeDetailDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeDetailDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyeDetailDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeDetailMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeDetailMap(const ECharacterCustomizeEye Eye, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeDetailMap");

	Params::CharacterCustomizeSystem_GetEyeDetailMap Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeDetailOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeDetailOpacity(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeDetailOpacity");

	Params::CharacterCustomizeSystem_GetEyeDetailOpacity Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEyeDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeDistance");

	Params::CharacterCustomizeSystem_GetEyeDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighLightColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeHighLightColor(const ECharacterCustomizeEye Eye, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighLightColor");

	Params::CharacterCustomizeSystem_GetEyeHighLightColor Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighlightDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableTextureListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableTextureList ACharacterCustomizeSystem::GetEyeHighlightDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighlightDataByRowName");

	Params::CharacterCustomizeSystem_GetEyeHighlightDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighlightDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyeHighlightDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighlightDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyeHighlightDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighLightMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeHighLightMap(const ECharacterCustomizeEye Eye, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighLightMap");

	Params::CharacterCustomizeSystem_GetEyeHighLightMap Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighLightOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeHighLightOpacity(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighLightOpacity");

	Params::CharacterCustomizeSystem_GetEyeHighLightOpacity Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHighLightVerticalPos
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeHighLightVerticalPos(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHighLightVerticalPos");

	Params::CharacterCustomizeSystem_GetEyeHighLightVerticalPos Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeHorizontalSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEyeHorizontalSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeHorizontalSize");

	Params::CharacterCustomizeSystem_GetEyeHorizontalSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeLashColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeLashColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeLashColor");

	Params::CharacterCustomizeSystem_GetEyeLashColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyelashColorOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyelashColorOpacity(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyelashColorOpacity");

	Params::CharacterCustomizeSystem_GetEyelashColorOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyelashDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableTextureListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableTextureList ACharacterCustomizeSystem::GetEyelashDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyelashDataByRowName");

	Params::CharacterCustomizeSystem_GetEyelashDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyelashDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyelashDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyelashDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyelashDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyelashMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyelashMap(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyelashMap");

	Params::CharacterCustomizeSystem_GetEyelashMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeLineColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeLineColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeLineColor");

	Params::CharacterCustomizeSystem_GetEyeLineColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeLineOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeLineOpacity(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeLineOpacity");

	Params::CharacterCustomizeSystem_GetEyeLineOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeMouthBalance
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeMouthBalance(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeMouthBalance");

	Params::CharacterCustomizeSystem_GetEyeMouthBalance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeMouthBalanceDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableEyeMouthBalanceReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableEyeMouthBalance ACharacterCustomizeSystem::GetEyeMouthBalanceDataByRowName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeMouthBalanceDataByRowName");

	Params::CharacterCustomizeSystem_GetEyeMouthBalanceDataByRowName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeMouthBalanceDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyeMouthBalanceDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeMouthBalanceDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyeMouthBalanceDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyePositionU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyePositionU(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyePositionU");

	Params::CharacterCustomizeSystem_GetEyePositionU Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyePositionV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyePositionV(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyePositionV");

	Params::CharacterCustomizeSystem_GetEyePositionV Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeScale
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeScale(const ECharacterCustomizeEye Eye, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeScale");

	Params::CharacterCustomizeSystem_GetEyeScale Parms{};

	Parms.Eye = Eye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeShape
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetEyeShape(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeShape");

	Params::CharacterCustomizeSystem_GetEyeShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeShapeDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableEyeShapeReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableEyeShape ACharacterCustomizeSystem::GetEyeShapeDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeShapeDataByRowName");

	Params::CharacterCustomizeSystem_GetEyeShapeDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeShapeDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetEyeShapeDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeShapeDataTableRowNames");

	Params::CharacterCustomizeSystem_GetEyeShapeDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetEyeVerticalSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterCustomizeSystem::GetEyeVerticalSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetEyeVerticalSize");

	Params::CharacterCustomizeSystem_GetEyeVerticalSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            ColorPalette                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintColor(const ECharacterCustomizeFacePaintLayer Layer, bool* IsSpecialColor, class FName* ColorPalette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintColor");

	Params::CharacterCustomizeSystem_GetFacePaintColor Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (ColorPalette != nullptr)
		*ColorPalette = Parms.ColorPalette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintMask
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintMask(const ECharacterCustomizeFacePaintLayer Layer, class FName* Category, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintMask");

	Params::CharacterCustomizeSystem_GetFacePaintMask Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintMaskPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintMaskPreset(const ECharacterCustomizeFacePaintLayer Layer, class FName* Category, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintMaskPreset");

	Params::CharacterCustomizeSystem_GetFacePaintMaskPreset Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintOffsetU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintOffsetU(const ECharacterCustomizeFacePaintLayer Layer, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintOffsetU");

	Params::CharacterCustomizeSystem_GetFacePaintOffsetU Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintOffsetV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintOffsetV(const ECharacterCustomizeFacePaintLayer Layer, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintOffsetV");

	Params::CharacterCustomizeSystem_GetFacePaintOffsetV Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintOpacity(const ECharacterCustomizeFacePaintLayer Layer, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintOpacity");

	Params::CharacterCustomizeSystem_GetFacePaintOpacity Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintRotate
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintRotate(const ECharacterCustomizeFacePaintLayer Layer, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintRotate");

	Params::CharacterCustomizeSystem_GetFacePaintRotate Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintScale
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintScale(const ECharacterCustomizeFacePaintLayer Layer, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintScale");

	Params::CharacterCustomizeSystem_GetFacePaintScale Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFacePaintSymmetry
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFacePaintSymmetry(const ECharacterCustomizeFacePaintLayer Layer, bool* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFacePaintSymmetry");

	Params::CharacterCustomizeSystem_GetFacePaintSymmetry Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarMap(class FName* Category, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarMap");

	Params::CharacterCustomizeSystem_GetFaceScarMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarOffsetU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarOffsetU(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarOffsetU");

	Params::CharacterCustomizeSystem_GetFaceScarOffsetU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarOffsetV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarOffsetV(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarOffsetV");

	Params::CharacterCustomizeSystem_GetFaceScarOffsetV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarRotate
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarRotate(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarRotate");

	Params::CharacterCustomizeSystem_GetFaceScarRotate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarScaleU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarScaleU(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarScaleU");

	Params::CharacterCustomizeSystem_GetFaceScarScaleU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceScarScaleV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceScarScaleV(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceScarScaleV");

	Params::CharacterCustomizeSystem_GetFaceScarScaleV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetFaceType(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceType");

	Params::CharacterCustomizeSystem_GetFaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceTypeDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableFaceTypeReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableFaceType ACharacterCustomizeSystem::GetFaceTypeDataByRowName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceTypeDataByRowName");

	Params::CharacterCustomizeSystem_GetFaceTypeDataByRowName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetFaceTypeDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetFaceTypeDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetFaceTypeDataTableRowNames");

	Params::CharacterCustomizeSystem_GetFaceTypeDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGender         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ECharacterCustomizeGender ACharacterCustomizeSystem::GetGender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetGender");

	Params::CharacterCustomizeSystem_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetGlovesColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeGlovesColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetGlovesColor(const ECharacterCustomizeGlovesColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetGlovesColor");

	Params::CharacterCustomizeSystem_GetGlovesColor Parms{};

	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetGlovesMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetGlovesMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetGlovesMesh");

	Params::CharacterCustomizeSystem_GetGlovesMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairAppendColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairAppendColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairAppendColor");

	Params::CharacterCustomizeSystem_GetHairAppendColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetHairAppendColorEnabled
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool*                                   OutEnabled                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairAppendColorEnabled(bool* OutEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairAppendColorEnabled");

	Params::CharacterCustomizeSystem_GetHairAppendColorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEnabled != nullptr)
		*OutEnabled = Parms.OutEnabled;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBackDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairBackDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBackDataByRowName");

	Params::CharacterCustomizeSystem_GetHairBackDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBackLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairBackLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBackLength");

	Params::CharacterCustomizeSystem_GetHairBackLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBackMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairBackMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBackMesh");

	Params::CharacterCustomizeSystem_GetHairBackMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBaseColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairBaseColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBaseColor");

	Params::CharacterCustomizeSystem_GetHairBaseColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBaseDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairBaseReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairBase ACharacterCustomizeSystem::GetHairBaseDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBaseDataByRowName");

	Params::CharacterCustomizeSystem_GetHairBaseDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBaseLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairBaseLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBaseLength");

	Params::CharacterCustomizeSystem_GetHairBaseLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairBaseMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairBaseMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairBaseMesh");

	Params::CharacterCustomizeSystem_GetHairBaseMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutPattern                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairColorAppendPattern(class FName* OutPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPattern");

	Params::CharacterCustomizeSystem_GetHairColorAppendPattern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPattern != nullptr)
		*OutPattern = Parms.OutPattern;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             AppendPatternName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairColorAppendPatternReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairColorAppendPattern ACharacterCustomizeSystem::GetHairColorAppendPatternDataByRowName(class FName AppendPatternName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternDataByRowName");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternDataByRowName Parms{};

	Parms.AppendPatternName = AppendPatternName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetHairColorAppendPatternDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternDataTableRowNames");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternOffsetU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairColorAppendPatternOffsetU(float* OutOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternOffsetU");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternOffsetU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOffset != nullptr)
		*OutOffset = Parms.OutOffset;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternOffsetV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairColorAppendPatternOffsetV(float* OutOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternOffsetV");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternOffsetV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOffset != nullptr)
		*OutOffset = Parms.OutOffset;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternScaleU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutScale                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairColorAppendPatternScaleU(float* OutScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternScaleU");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternScaleU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScale != nullptr)
		*OutScale = Parms.OutScale;
}


// Function Extensions.CharacterCustomizeSystem.GetHairColorAppendPatternScaleV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutScale                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairColorAppendPatternScaleV(float* OutScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairColorAppendPatternScaleV");

	Params::CharacterCustomizeSystem_GetHairColorAppendPatternScaleV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScale != nullptr)
		*OutScale = Parms.OutScale;
}


// Function Extensions.CharacterCustomizeSystem.GetHairCurlParamStartPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairCurlParamStartPoint(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairCurlParamStartPoint");

	Params::CharacterCustomizeSystem_GetHairCurlParamStartPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairCurlPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairCurlPreset(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairCurlPreset");

	Params::CharacterCustomizeSystem_GetHairCurlPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairCurlPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairCurlPresetName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairCurlPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairCurlPreset ACharacterCustomizeSystem::GetHairCurlPresetDataByRowName(class FName HairCurlPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairCurlPresetDataByRowName");

	Params::CharacterCustomizeSystem_GetHairCurlPresetDataByRowName Parms{};

	Parms.HairCurlPresetName = HairCurlPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairCurlPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetHairCurlPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairCurlPresetDataTableRowNames");

	Params::CharacterCustomizeSystem_GetHairCurlPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairFrontDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontDataByRowName");

	Params::CharacterCustomizeSystem_GetHairFrontDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairFrontLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontLength");

	Params::CharacterCustomizeSystem_GetHairFrontLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairFrontMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontMesh");

	Params::CharacterCustomizeSystem_GetHairFrontMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontSideDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairFrontSideDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontSideDataByRowName");

	Params::CharacterCustomizeSystem_GetHairFrontSideDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontSideLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairFrontSideLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontSideLength");

	Params::CharacterCustomizeSystem_GetHairFrontSideLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairFrontSideMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairFrontSideMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairFrontSideMesh");

	Params::CharacterCustomizeSystem_GetHairFrontSideMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairHighlightIntensity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairHighlightIntensity(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairHighlightIntensity");

	Params::CharacterCustomizeSystem_GetHairHighlightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairOtherDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairOtherDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairOtherDataByRowName");

	Params::CharacterCustomizeSystem_GetHairOtherDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairOtherLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairOtherLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairOtherLength");

	Params::CharacterCustomizeSystem_GetHairOtherLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairOtherMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairOtherMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairOtherMesh");

	Params::CharacterCustomizeSystem_GetHairOtherMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSet
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairSet(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSet");

	Params::CharacterCustomizeSystem_GetHairSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairSetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairSetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairSet ACharacterCustomizeSystem::GetHairSetDataByRowName(class FName HairSetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSetDataByRowName");

	Params::CharacterCustomizeSystem_GetHairSetDataByRowName Parms{};

	Parms.HairSetName = HairSetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetHairSetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSetDataTableRowNames");

	Params::CharacterCustomizeSystem_GetHairSetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSideDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairSideDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSideDataByRowName");

	Params::CharacterCustomizeSystem_GetHairSideDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSideLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairSideLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSideLength");

	Params::CharacterCustomizeSystem_GetHairSideLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairSideMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairSideMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairSideMesh");

	Params::CharacterCustomizeSystem_GetHairSideMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTaperPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairTaperPreset(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTaperPreset");

	Params::CharacterCustomizeSystem_GetHairTaperPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTaperPresetDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairTaperPresetName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairTaperPresetReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairTaperPreset ACharacterCustomizeSystem::GetHairTaperPresetDataByRowName(class FName HairTaperPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTaperPresetDataByRowName");

	Params::CharacterCustomizeSystem_GetHairTaperPresetDataByRowName Parms{};

	Parms.HairTaperPresetName = HairTaperPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTaperPresetDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetHairTaperPresetDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTaperPresetDataTableRowNames");

	Params::CharacterCustomizeSystem_GetHairTaperPresetDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTopDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HairName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableHairPartReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableHairPart ACharacterCustomizeSystem::GetHairTopDataByRowName(class FName HairName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTopDataByRowName");

	Params::CharacterCustomizeSystem_GetHairTopDataByRowName Parms{};

	Parms.HairName = HairName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTopLength
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairTopLength(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTopLength");

	Params::CharacterCustomizeSystem_GetHairTopLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHairTopMesh
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHairTopMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHairTopMesh");

	Params::CharacterCustomizeSystem_GetHairTopMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetHeadShape
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetHeadShape(float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetHeadShape");

	Params::CharacterCustomizeSystem_GetHeadShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetInnerColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeInnerColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetInnerColor(const ECharacterCustomizeInnerColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetInnerColor");

	Params::CharacterCustomizeSystem_GetInnerColor Parms{};

	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetInnerMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetInnerMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetInnerMesh");

	Params::CharacterCustomizeSystem_GetInnerMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetInnerPartVisibility
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCustomizeClothPartVisibility* OutVisibility                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetInnerPartVisibility(const int32 InPartSlot, ECharacterCustomizeClothPartVisibility* OutVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetInnerPartVisibility");

	Params::CharacterCustomizeSystem_GetInnerPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVisibility != nullptr)
		*OutVisibility = Parms.OutVisibility;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiMap(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiMap");

	Params::CharacterCustomizeSystem_GetKintsugiMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiOffsetU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiOffsetU(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiOffsetU");

	Params::CharacterCustomizeSystem_GetKintsugiOffsetU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiOffsetV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiOffsetV(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiOffsetV");

	Params::CharacterCustomizeSystem_GetKintsugiOffsetV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiRotate
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiRotate(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiRotate");

	Params::CharacterCustomizeSystem_GetKintsugiRotate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiScaleU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiScaleU(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiScaleU");

	Params::CharacterCustomizeSystem_GetKintsugiScaleU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetKintsugiScaleV
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetKintsugiScaleV(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetKintsugiScaleV");

	Params::CharacterCustomizeSystem_GetKintsugiScaleV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetLipColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetLipColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetLipColor");

	Params::CharacterCustomizeSystem_GetLipColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetLipGlossness
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetLipGlossness(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetLipGlossness");

	Params::CharacterCustomizeSystem_GetLipGlossness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetLipOpacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetLipOpacity(float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetLipOpacity");

	Params::CharacterCustomizeSystem_GetLipOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureColor1
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetManicureColor1(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureColor1");

	Params::CharacterCustomizeSystem_GetManicureColor1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureColor2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetManicureColor2(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureColor2");

	Params::CharacterCustomizeSystem_GetManicureColor2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureColor3
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetManicureColor3(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureColor3");

	Params::CharacterCustomizeSystem_GetManicureColor3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableManicurePatternListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableManicurePatternList ACharacterCustomizeSystem::GetManicureDataByRowName(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureDataByRowName");

	Params::CharacterCustomizeSystem_GetManicureDataByRowName Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetManicureDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureDataTableRowNames");

	Params::CharacterCustomizeSystem_GetManicureDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetManicureMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetManicureMap(class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetManicureMap");

	Params::CharacterCustomizeSystem_GetManicureMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetMaskColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeMaskColorSlot  ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetMaskColor(const ECharacterCustomizeMaskColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMaskColor");

	Params::CharacterCustomizeSystem_GetMaskColor Parms{};

	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetMaskMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetMaskMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMaskMesh");

	Params::CharacterCustomizeSystem_GetMaskMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetMaskPartVisibility
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCustomizeClothPartVisibility* OutVisibility                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetMaskPartVisibility(const int32 InPartSlot, ECharacterCustomizeClothPartVisibility* OutVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMaskPartVisibility");

	Params::CharacterCustomizeSystem_GetMaskPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVisibility != nullptr)
		*OutVisibility = Parms.OutVisibility;
}


// Function Extensions.CharacterCustomizeSystem.GetMouthType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetMouthType(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMouthType");

	Params::CharacterCustomizeSystem_GetMouthType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetMouthTypeDataByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableMouthTypeReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableMouthType ACharacterCustomizeSystem::GetMouthTypeDataByRowName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMouthTypeDataByRowName");

	Params::CharacterCustomizeSystem_GetMouthTypeDataByRowName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetMouthTypeDataTableRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> ACharacterCustomizeSystem::GetMouthTypeDataTableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetMouthTypeDataTableRowNames");

	Params::CharacterCustomizeSystem_GetMouthTypeDataTableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetOuterColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeOuterColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsSpecialColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetOuterColor(const ECharacterCustomizeOuterColorSlot ColorSlot, bool* IsSpecialColor, class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetOuterColor");

	Params::CharacterCustomizeSystem_GetOuterColor Parms{};

	Parms.ColorSlot = ColorSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSpecialColor != nullptr)
		*IsSpecialColor = Parms.IsSpecialColor;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetOuterMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetOuterMesh(class FName* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetOuterMesh");

	Params::CharacterCustomizeSystem_GetOuterMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Extensions.CharacterCustomizeSystem.GetSkinColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            Palette                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetSkinColor(class FName* Palette, class FName* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetSkinColor");

	Params::CharacterCustomizeSystem_GetSkinColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Palette != nullptr)
		*Palette = Parms.Palette;

	if (Color != nullptr)
		*Color = Parms.Color;
}


// Function Extensions.CharacterCustomizeSystem.GetSpecialColorDataFromSpecialColorPalette
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ColorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableSpecialColor*SpecialColorData                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetSpecialColorDataFromSpecialColorPalette(const class FName& PaletteName, const class FName& ColorName, struct FCharacterCustomizeDataTableSpecialColor* SpecialColorData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetSpecialColorDataFromSpecialColorPalette");

	Params::CharacterCustomizeSystem_GetSpecialColorDataFromSpecialColorPalette Parms{};

	Parms.PaletteName = PaletteName;
	Parms.ColorName = ColorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpecialColorData != nullptr)
		*SpecialColorData = std::move(Parms.SpecialColorData);
}


// Function Extensions.CharacterCustomizeSystem.GetSpecialColorPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterCustomizeDataTableSpecialColorPaletteList*OutPalette                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetSpecialColorPalette(const class FName& PaletteRowName, struct FCharacterCustomizeDataTableSpecialColorPaletteList* OutPalette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetSpecialColorPalette");

	Params::CharacterCustomizeSystem_GetSpecialColorPalette Parms{};

	Parms.PaletteRowName = PaletteRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPalette != nullptr)
		*OutPalette = std::move(Parms.OutPalette);
}


// Function Extensions.CharacterCustomizeSystem.GetSpecialColorPaletteData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCharacterCustomizeDataTableSpecialColorPaletteListReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FCharacterCustomizeDataTableSpecialColorPaletteList ACharacterCustomizeSystem::GetSpecialColorPaletteData(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetSpecialColorPaletteData");

	Params::CharacterCustomizeSystem_GetSpecialColorPaletteData Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetTotalAccessoryCost
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32*                                  Cost                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetTotalAccessoryCost(int32* Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetTotalAccessoryCost");

	Params::CharacterCustomizeSystem_GetTotalAccessoryCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Cost != nullptr)
		*Cost = Parms.Cost;
}


// Function Extensions.CharacterCustomizeSystem.GetUserAvatarTemporaryAccessoryMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            RowName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetUserAvatarTemporaryAccessoryMesh(const ECharacterCustomizeAccessorySlot Slot, class FName* Category, class FName* RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetUserAvatarTemporaryAccessoryMesh");

	Params::CharacterCustomizeSystem_GetUserAvatarTemporaryAccessoryMesh Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (RowName != nullptr)
		*RowName = Parms.RowName;
}


// Function Extensions.CharacterCustomizeSystem.GetUserAvatarTemporaryFacePaintMask
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Category                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetUserAvatarTemporaryFacePaintMask(const ECharacterCustomizeFacePaintLayer Layer, class FName* Category, class FName* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetUserAvatarTemporaryFacePaintMask");

	Params::CharacterCustomizeSystem_GetUserAvatarTemporaryFacePaintMask Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Category != nullptr)
		*Category = Parms.Category;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Extensions.CharacterCustomizeSystem.GetVoiceType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            OutType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::GetVoiceType(class FName* OutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetVoiceType");

	Params::CharacterCustomizeSystem_GetVoiceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutType != nullptr)
		*OutType = Parms.OutType;
}


// Function Extensions.CharacterCustomizeSystem.IsAccessoryColorSameAsHair
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsAccessoryColorSameAsHair(const ECharacterCustomizeAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsAccessoryColorSameAsHair");

	Params::CharacterCustomizeSystem_IsAccessoryColorSameAsHair Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsAccessoryEnable
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsAccessoryEnable(const ECharacterCustomizeAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsAccessoryEnable");

	Params::CharacterCustomizeSystem_IsAccessoryEnable Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsAccessoryTransformable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      CategoryName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AccessoryRowName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutTransformable                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::IsAccessoryTransformable(const class FName& CategoryName, const class FName& AccessoryRowName, bool* OutTransformable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsAccessoryTransformable");

	Params::CharacterCustomizeSystem_IsAccessoryTransformable Parms{};

	Parms.CategoryName = CategoryName;
	Parms.AccessoryRowName = AccessoryRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransformable != nullptr)
		*OutTransformable = Parms.OutTransformable;
}


// Function Extensions.CharacterCustomizeSystem.IsAutoBlink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsAutoBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsAutoBlink");

	Params::CharacterCustomizeSystem_IsAutoBlink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsBootsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsBootsAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsBootsAvailable");

	Params::CharacterCustomizeSystem_IsBootsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsEnableVanishProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsEnableVanishProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsEnableVanishProcess");

	Params::CharacterCustomizeSystem_IsEnableVanishProcess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsEyebrowSameColorAsHair
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsEyebrowSameColorAsHair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsEyebrowSameColorAsHair");

	Params::CharacterCustomizeSystem_IsEyebrowSameColorAsHair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsEyeOdd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsEyeOdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsEyeOdd");

	Params::CharacterCustomizeSystem_IsEyeOdd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsInnerPartValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsInnerPartValid(const int32 InPartSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsInnerPartValid");

	Params::CharacterCustomizeSystem_IsInnerPartValid Parms{};

	Parms.InPartSlot = InPartSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.MoveAccessory
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DeltaVector                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::MoveAccessory(const ECharacterCustomizeAccessorySlot Slot, const struct FVector& DeltaVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "MoveAccessory");

	Params::CharacterCustomizeSystem_MoveAccessory Parms{};

	Parms.Slot = Slot;
	Parms.DeltaVector = std::move(DeltaVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.NotifyBackgroundChangeCompleted
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::NotifyBackgroundChangeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "NotifyBackgroundChangeCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.OnSystemLoaded
// (Native, Event, Protected, BlueprintEvent)

void ACharacterCustomizeSystem::OnSystemLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "OnSystemLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.PlayPose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizePose           InPose                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::PlayPose(const ECharacterCustomizePose InPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "PlayPose");

	Params::CharacterCustomizeSystem_PlayPose Parms{};

	Parms.InPose = InPose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.RemoveUserAvatarBySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeUserAvatarSlot InCharacterSlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::RemoveUserAvatarBySlot(const ECharacterCustomizeUserAvatarSlot InCharacterSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "RemoveUserAvatarBySlot");

	Params::CharacterCustomizeSystem_RemoveUserAvatarBySlot Parms{};

	Parms.InCharacterSlot = InCharacterSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ResetAccessoryMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ResetAccessoryMesh(const ECharacterCustomizeAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ResetAccessoryMesh");

	Params::CharacterCustomizeSystem_ResetAccessoryMesh Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ResetAccessoryTransform
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot& InSlot                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ResetAccessoryTransform(const ECharacterCustomizeAccessorySlot& InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ResetAccessoryTransform");

	Params::CharacterCustomizeSystem_ResetAccessoryTransform Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ResetCharacterCustomizeCamera
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::ResetCharacterCustomizeCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ResetCharacterCustomizeCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ResetFacePaintTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ResetFacePaintTransform(const ECharacterCustomizeFacePaintLayer Layer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ResetFacePaintTransform");

	Params::CharacterCustomizeSystem_ResetFacePaintTransform Parms{};

	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.RestoreCustomizeParameter
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::RestoreCustomizeParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "RestoreCustomizeParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.RotateAccessoryByPitch
// (Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::RotateAccessoryByPitch(const ECharacterCustomizeAccessorySlot Slot, const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "RotateAccessoryByPitch");

	Params::CharacterCustomizeSystem_RotateAccessoryByPitch Parms{};

	Parms.Slot = Slot;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.RotateAccessoryByRoll
// (Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::RotateAccessoryByRoll(const ECharacterCustomizeAccessorySlot Slot, const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "RotateAccessoryByRoll");

	Params::CharacterCustomizeSystem_RotateAccessoryByRoll Parms{};

	Parms.Slot = Slot;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SaveCharacterCustomize
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::SaveCharacterCustomize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SaveCharacterCustomize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SaveCharacterNameDigestData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InCharacterName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InCodeName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SaveCharacterNameDigestData(const class FString& InCharacterName, const class FString& InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SaveCharacterNameDigestData");

	Params::CharacterCustomizeSystem_SaveCharacterNameDigestData Parms{};

	Parms.InCharacterName = std::move(InCharacterName);
	Parms.InCodeName = std::move(InCodeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SaveCharacterThumbnailDigestData
// (Final, Native, Public, BlueprintCallable)

void ACharacterCustomizeSystem::SaveCharacterThumbnailDigestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SaveCharacterThumbnailDigestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SaveUserAvatarToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeUserAvatarSlot InCharacterSlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SaveUserAvatarToSlot(const ECharacterCustomizeUserAvatarSlot InCharacterSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SaveUserAvatarToSlot");

	Params::CharacterCustomizeSystem_SaveUserAvatarToSlot Parms{};

	Parms.InCharacterSlot = InCharacterSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.ScaleAccessory
// (Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             DeltaValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::ScaleAccessory(const ECharacterCustomizeAccessorySlot Slot, const float DeltaValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "ScaleAccessory");

	Params::CharacterCustomizeSystem_ScaleAccessory Parms{};

	Parms.Slot = Slot;
	Parms.DeltaValue = DeltaValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessoryAttachTo
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessoryAttachTo(const ECharacterCustomizeAccessorySlot Slot, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessoryAttachTo");

	Params::CharacterCustomizeSystem_SetAccessoryAttachTo Parms{};

	Parms.Slot = Slot;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessoryColor
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeAccessoryColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessoryColor(const ECharacterCustomizeAccessorySlot Slot, const ECharacterCustomizeAccessoryColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessoryColor");

	Params::CharacterCustomizeSystem_SetAccessoryColor Parms{};

	Parms.Slot = Slot;
	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessoryMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Category                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessoryMesh(const ECharacterCustomizeAccessorySlot Slot, const class FName& Category, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessoryMesh");

	Params::CharacterCustomizeSystem_SetAccessoryMesh Parms{};

	Parms.Slot = Slot;
	Parms.Category = Category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessoryOrientTransform
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEulerAngleTransform&      Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessoryOrientTransform(const ECharacterCustomizeAccessorySlot Slot, const struct FEulerAngleTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessoryOrientTransform");

	Params::CharacterCustomizeSystem_SetAccessoryOrientTransform Parms{};

	Parms.Slot = Slot;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessoryRootTransform
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEulerAngleTransform&      Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessoryRootTransform(const ECharacterCustomizeAccessorySlot Slot, const struct FEulerAngleTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessoryRootTransform");

	Params::CharacterCustomizeSystem_SetAccessoryRootTransform Parms{};

	Parms.Slot = Slot;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAccessorySpecialColor
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeAccessoryColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ColorPalette                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAccessorySpecialColor(const ECharacterCustomizeAccessorySlot Slot, const ECharacterCustomizeAccessoryColorSlot ColorSlot, const class FName& ColorPalette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAccessorySpecialColor");

	Params::CharacterCustomizeSystem_SetAccessorySpecialColor Parms{};

	Parms.Slot = Slot;
	Parms.ColorSlot = ColorSlot;
	Parms.ColorPalette = ColorPalette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetAutoBlink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsAuto                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetAutoBlink(bool InIsAuto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetAutoBlink");

	Params::CharacterCustomizeSystem_SetAutoBlink Parms{};

	Parms.InIsAuto = InIsAuto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBeard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBeard(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBeard");

	Params::CharacterCustomizeSystem_SetBeard Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBeardColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBeardColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBeardColor");

	Params::CharacterCustomizeSystem_SetBeardColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBodyPartShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAdvancedBodyPartInPart                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBodyPartShape(const ECharacterCustomizeAdvancedBodyPart InPart, const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBodyPartShape");

	Params::CharacterCustomizeSystem_SetBodyPartShape Parms{};

	Parms.InPart = InPart;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBodyShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBodyShape(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBodyShape");

	Params::CharacterCustomizeSystem_SetBodyShape Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBodyShapeType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeBodyShape      InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBodyShapeType(const ECharacterCustomizeBodyShape InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBodyShapeType");

	Params::CharacterCustomizeSystem_SetBodyShapeType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBootsColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeBootsColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBootsColor(const ECharacterCustomizeBootsColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBootsColor");

	Params::CharacterCustomizeSystem_SetBootsColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBootsColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBootsColorPreset(const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBootsColorPreset");

	Params::CharacterCustomizeSystem_SetBootsColorPreset Parms{};

	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBootsMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBootsMesh(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBootsMesh");

	Params::CharacterCustomizeSystem_SetBootsMesh Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBootsPartVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeClothPartVisibilityInVisibility                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBootsPartVisibility(const int32 InPartSlot, const ECharacterCustomizeClothPartVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBootsPartVisibility");

	Params::CharacterCustomizeSystem_SetBootsPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetBootsSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeBootsColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetBootsSpecialColor(const ECharacterCustomizeBootsColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetBootsSpecialColor");

	Params::CharacterCustomizeSystem_SetBootsSpecialColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCalvaryScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCalvaryScale(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCalvaryScale");

	Params::CharacterCustomizeSystem_SetCalvaryScale Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCharacterCustomizeLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCharacterCustomizeLocation(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCharacterCustomizeLocation");

	Params::CharacterCustomizeSystem_SetCharacterCustomizeLocation Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCharacterScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCharacterScale(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCharacterScale");

	Params::CharacterCustomizeSystem_SetCharacterScale Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCustomizeBackground
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeBackground     InBackground                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCustomizeBackground(const ECharacterCustomizeBackground InBackground)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCustomizeBackground");

	Params::CharacterCustomizeSystem_SetCustomizeBackground Parms{};

	Parms.InBackground = InBackground;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCustomizeCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacterCustomizeCharacter*     InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCustomizeCharacter(class ACharacterCustomizeCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCustomizeCharacter");

	Params::CharacterCustomizeSystem_SetCustomizeCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCustomizeClock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InHour                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InMinute                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCustomizeClock(const int32 InHour, const int32 InMinute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCustomizeClock");

	Params::CharacterCustomizeSystem_SetCustomizeClock Parms{};

	Parms.InHour = InHour;
	Parms.InMinute = InMinute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCustomizeSaveMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InSaveCustomize                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCustomizeSaveMode(bool InSaveCustomize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCustomizeSaveMode");

	Params::CharacterCustomizeSystem_SetCustomizeSaveMode Parms{};

	Parms.InSaveCustomize = InSaveCustomize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetCustomizeWeather
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeWeatherType    InWeather                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetCustomizeWeather(const ECharacterCustomizeWeatherType InWeather)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetCustomizeWeather");

	Params::CharacterCustomizeSystem_SetCustomizeWeather Parms{};

	Parms.InWeather = InWeather;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetDummyOrientTransform
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FEulerAngleTransform&      InRoot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FEulerAngleTransform&      InOrient                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetDummyOrientTransform(const struct FEulerAngleTransform& InRoot, const struct FEulerAngleTransform& InOrient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetDummyOrientTransform");

	Params::CharacterCustomizeSystem_SetDummyOrientTransform Parms{};

	Parms.InRoot = std::move(InRoot);
	Parms.InOrient = std::move(InOrient);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEarAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEarAngle(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEarAngle");

	Params::CharacterCustomizeSystem_SetEarAngle Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEarSharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEarSharpness(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEarSharpness");

	Params::CharacterCustomizeSystem_SetEarSharpness Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEnableVanishProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEnableVanishProcess(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEnableVanishProcess");

	Params::CharacterCustomizeSystem_SetEnableVanishProcess Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetExpression
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeExpression     InExpression                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetExpression(const ECharacterCustomizeExpression InExpression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetExpression");

	Params::CharacterCustomizeSystem_SetExpression Parms{};

	Parms.InExpression = InExpression;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeAngle(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeAngle");

	Params::CharacterCustomizeSystem_SetEyeAngle Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeAppendColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeAppendColor(const ECharacterCustomizeEye Eye, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeAppendColor");

	Params::CharacterCustomizeSystem_SetEyeAppendColor Parms{};

	Parms.Eye = Eye;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeAppendColor2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeAppendColor2(const ECharacterCustomizeEye Eye, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeAppendColor2");

	Params::CharacterCustomizeSystem_SetEyeAppendColor2 Parms{};

	Parms.Eye = Eye;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeBaseColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeBaseColor(const ECharacterCustomizeEye Eye, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeBaseColor");

	Params::CharacterCustomizeSystem_SetEyeBaseColor Parms{};

	Parms.Eye = Eye;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeBaseMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeBaseMap(const ECharacterCustomizeEye Eye, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeBaseMap");

	Params::CharacterCustomizeSystem_SetEyeBaseMap Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowAngleByBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowAngleByBone(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowAngleByBone");

	Params::CharacterCustomizeSystem_SetEyebrowAngleByBone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowAngleByMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowAngleByMaterial(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowAngleByMaterial");

	Params::CharacterCustomizeSystem_SetEyebrowAngleByMaterial Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowColor");

	Params::CharacterCustomizeSystem_SetEyebrowColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowDistance(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowDistance");

	Params::CharacterCustomizeSystem_SetEyebrowDistance Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowMap(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowMap");

	Params::CharacterCustomizeSystem_SetEyebrowMap Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowPositionVByBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowPositionVByBone(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowPositionVByBone");

	Params::CharacterCustomizeSystem_SetEyebrowPositionVByBone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowPositionVByMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowPositionVByMaterial(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowPositionVByMaterial");

	Params::CharacterCustomizeSystem_SetEyebrowPositionVByMaterial Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowRaisingPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowRaisingPattern(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowRaisingPattern");

	Params::CharacterCustomizeSystem_SetEyebrowRaisingPattern Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowSameColorAsHair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowSameColorAsHair(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowSameColorAsHair");

	Params::CharacterCustomizeSystem_SetEyebrowSameColorAsHair Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowScaleH
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowScaleH(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowScaleH");

	Params::CharacterCustomizeSystem_SetEyebrowScaleH Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyebrowScaleV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyebrowScaleV(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyebrowScaleV");

	Params::CharacterCustomizeSystem_SetEyebrowScaleV Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeCats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeCats(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeCats");

	Params::CharacterCustomizeSystem_SetEyeCats Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeClosingPattern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeEye                  InEye                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEyeClosingPattern                      InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeClosingPattern(ECharacterCustomizeEye InEye, EEyeClosingPattern InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeClosingPattern");

	Params::CharacterCustomizeSystem_SetEyeClosingPattern Parms{};

	Parms.InEye = InEye;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeColorPreset(const ECharacterCustomizeEye Eye, const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeColorPreset");

	Params::CharacterCustomizeSystem_SetEyeColorPreset Parms{};

	Parms.Eye = Eye;
	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeDetailMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeDetailMap(const ECharacterCustomizeEye Eye, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeDetailMap");

	Params::CharacterCustomizeSystem_SetEyeDetailMap Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeDetailOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeDetailOpacity(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeDetailOpacity");

	Params::CharacterCustomizeSystem_SetEyeDetailOpacity Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeDistance(float InDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeDistance");

	Params::CharacterCustomizeSystem_SetEyeDistance Parms{};

	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeHighlightColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeHighlightColor(const ECharacterCustomizeEye Eye, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeHighlightColor");

	Params::CharacterCustomizeSystem_SetEyeHighlightColor Parms{};

	Parms.Eye = Eye;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeHighLightMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeHighLightMap(const ECharacterCustomizeEye Eye, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeHighLightMap");

	Params::CharacterCustomizeSystem_SetEyeHighLightMap Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeHighLightOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeHighLightOpacity(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeHighLightOpacity");

	Params::CharacterCustomizeSystem_SetEyeHighLightOpacity Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeHighLightVerticalPos
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeHighLightVerticalPos(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeHighLightVerticalPos");

	Params::CharacterCustomizeSystem_SetEyeHighLightVerticalPos Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeHorizontalSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeHorizontalSize(float InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeHorizontalSize");

	Params::CharacterCustomizeSystem_SetEyeHorizontalSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyelashColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyelashColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyelashColor");

	Params::CharacterCustomizeSystem_SetEyelashColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyelashColorOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyelashColorOpacity(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyelashColorOpacity");

	Params::CharacterCustomizeSystem_SetEyelashColorOpacity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyelashMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyelashMap(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyelashMap");

	Params::CharacterCustomizeSystem_SetEyelashMap Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeLineColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeLineColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeLineColor");

	Params::CharacterCustomizeSystem_SetEyeLineColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeLineOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeLineOpacity(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeLineOpacity");

	Params::CharacterCustomizeSystem_SetEyeLineOpacity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeMouthBalance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeMouthBalance(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeMouthBalance");

	Params::CharacterCustomizeSystem_SetEyeMouthBalance Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeOdd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeOdd(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeOdd");

	Params::CharacterCustomizeSystem_SetEyeOdd Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyePositionU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyePositionU(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyePositionU");

	Params::CharacterCustomizeSystem_SetEyePositionU Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyePositionV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyePositionV(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyePositionV");

	Params::CharacterCustomizeSystem_SetEyePositionV Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeEye            Eye                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeScale(const ECharacterCustomizeEye Eye, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeScale");

	Params::CharacterCustomizeSystem_SetEyeScale Parms{};

	Parms.Eye = Eye;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeShape
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeShape(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeShape");

	Params::CharacterCustomizeSystem_SetEyeShape Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetEyeVerticalSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetEyeVerticalSize(float InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetEyeVerticalSize");

	Params::CharacterCustomizeSystem_SetEyeVerticalSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintColor(const ECharacterCustomizeFacePaintLayer Layer, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintColor");

	Params::CharacterCustomizeSystem_SetFacePaintColor Parms{};

	Parms.Layer = Layer;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Category                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintMask(ECharacterCustomizeFacePaintLayer Layer, const class FName& Category, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintMask");

	Params::CharacterCustomizeSystem_SetFacePaintMask Parms{};

	Parms.Layer = Layer;
	Parms.Category = Category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintMaskPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Category                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintMaskPreset(ECharacterCustomizeFacePaintLayer Layer, const class FName& Category, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintMaskPreset");

	Params::CharacterCustomizeSystem_SetFacePaintMaskPreset Parms{};

	Parms.Layer = Layer;
	Parms.Category = Category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintOffsetU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintOffsetU(ECharacterCustomizeFacePaintLayer Layer, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintOffsetU");

	Params::CharacterCustomizeSystem_SetFacePaintOffsetU Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintOffsetV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintOffsetV(ECharacterCustomizeFacePaintLayer Layer, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintOffsetV");

	Params::CharacterCustomizeSystem_SetFacePaintOffsetV Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintOpacity(ECharacterCustomizeFacePaintLayer Layer, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintOpacity");

	Params::CharacterCustomizeSystem_SetFacePaintOpacity Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintRotate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintRotate(ECharacterCustomizeFacePaintLayer Layer, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintRotate");

	Params::CharacterCustomizeSystem_SetFacePaintRotate Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintScale(ECharacterCustomizeFacePaintLayer Layer, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintScale");

	Params::CharacterCustomizeSystem_SetFacePaintScale Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeFacePaintLayer Layer                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SpecialColorPalette                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SpecialColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintSpecialColor(const ECharacterCustomizeFacePaintLayer Layer, const class FName& SpecialColorPalette, const class FName& SpecialColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintSpecialColor");

	Params::CharacterCustomizeSystem_SetFacePaintSpecialColor Parms{};

	Parms.Layer = Layer;
	Parms.SpecialColorPalette = SpecialColorPalette;
	Parms.SpecialColor = SpecialColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFacePaintSymmetry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeFacePaintLayer       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFacePaintSymmetry(ECharacterCustomizeFacePaintLayer Layer, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFacePaintSymmetry");

	Params::CharacterCustomizeSystem_SetFacePaintSymmetry Parms{};

	Parms.Layer = Layer;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Category                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarMap(const class FName& Category, const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarMap");

	Params::CharacterCustomizeSystem_SetFaceScarMap Parms{};

	Parms.Category = Category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarOffsetU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarOffsetU(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarOffsetU");

	Params::CharacterCustomizeSystem_SetFaceScarOffsetU Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarOffsetV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarOffsetV(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarOffsetV");

	Params::CharacterCustomizeSystem_SetFaceScarOffsetV Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarRotate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarRotate(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarRotate");

	Params::CharacterCustomizeSystem_SetFaceScarRotate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarScaleU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarScaleU(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarScaleU");

	Params::CharacterCustomizeSystem_SetFaceScarScaleU Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceScarScaleV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceScarScaleV(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceScarScaleV");

	Params::CharacterCustomizeSystem_SetFaceScarScaleV Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetFaceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetFaceType(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetFaceType");

	Params::CharacterCustomizeSystem_SetFaceType Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetGender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetGender(const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetGender");

	Params::CharacterCustomizeSystem_SetGender Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetGlovesColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeGlovesColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetGlovesColor(const ECharacterCustomizeGlovesColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetGlovesColor");

	Params::CharacterCustomizeSystem_SetGlovesColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetGlovesColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetGlovesColorPreset(const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetGlovesColorPreset");

	Params::CharacterCustomizeSystem_SetGlovesColorPreset Parms{};

	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetGlovesMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetGlovesMesh(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetGlovesMesh");

	Params::CharacterCustomizeSystem_SetGlovesMesh Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetGlovesSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeGlovesColorSlotColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetGlovesSpecialColor(const ECharacterCustomizeGlovesColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetGlovesSpecialColor");

	Params::CharacterCustomizeSystem_SetGlovesSpecialColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairAppendColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairAppendColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairAppendColor");

	Params::CharacterCustomizeSystem_SetHairAppendColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairAppendColorEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairAppendColorEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairAppendColorEnabled");

	Params::CharacterCustomizeSystem_SetHairAppendColorEnabled Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairBackLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairBackLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairBackLength");

	Params::CharacterCustomizeSystem_SetHairBackLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairBackMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairBackMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairBackMesh");

	Params::CharacterCustomizeSystem_SetHairBackMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairBaseColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairBaseColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairBaseColor");

	Params::CharacterCustomizeSystem_SetHairBaseColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairBaseLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairBaseLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairBaseLength");

	Params::CharacterCustomizeSystem_SetHairBaseLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairColorAppendPattern
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InPattern                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairColorAppendPattern(const class FName& InPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairColorAppendPattern");

	Params::CharacterCustomizeSystem_SetHairColorAppendPattern Parms{};

	Parms.InPattern = InPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairColorAppendPatternOffsetU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InOffset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairColorAppendPatternOffsetU(const float InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairColorAppendPatternOffsetU");

	Params::CharacterCustomizeSystem_SetHairColorAppendPatternOffsetU Parms{};

	Parms.InOffset = InOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairColorAppendPatternOffsetV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InOffset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairColorAppendPatternOffsetV(const float InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairColorAppendPatternOffsetV");

	Params::CharacterCustomizeSystem_SetHairColorAppendPatternOffsetV Parms{};

	Parms.InOffset = InOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairColorAppendPatternScaleU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairColorAppendPatternScaleU(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairColorAppendPatternScaleU");

	Params::CharacterCustomizeSystem_SetHairColorAppendPatternScaleU Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairColorAppendPatternScaleV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairColorAppendPatternScaleV(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairColorAppendPatternScaleV");

	Params::CharacterCustomizeSystem_SetHairColorAppendPatternScaleV Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlDensity(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlDensity");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlDensity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlDensityPlusAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlDensityPlusAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlDensityPlusAlpha");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlDensityPlusAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlRotation(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlRotation");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlRotation Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlRotationOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlRotationOffset(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlRotationOffset");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlRotationOffset Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlRotationOffsetPlusAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlRotationOffsetPlusAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlRotationOffsetPlusAlpha");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlRotationOffsetPlusAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlRotationPlusAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlRotationPlusAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlRotationPlusAlpha");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlRotationPlusAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlScale(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlScale");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlScale Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamCurlScalePlusAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamCurlScalePlusAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamCurlScalePlusAlpha");

	Params::CharacterCustomizeSystem_SetHairCurlParamCurlScalePlusAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamEndPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamEndPoint(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamEndPoint");

	Params::CharacterCustomizeSystem_SetHairCurlParamEndPoint Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamGradationAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamGradationAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamGradationAlpha");

	Params::CharacterCustomizeSystem_SetHairCurlParamGradationAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamGradationPeakEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamGradationPeakEnd(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamGradationPeakEnd");

	Params::CharacterCustomizeSystem_SetHairCurlParamGradationPeakEnd Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamGradationPeakStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamGradationPeakStart(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamGradationPeakStart");

	Params::CharacterCustomizeSystem_SetHairCurlParamGradationPeakStart Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamStartPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamStartPoint(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamStartPoint");

	Params::CharacterCustomizeSystem_SetHairCurlParamStartPoint Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamUseCurl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamUseCurl(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamUseCurl");

	Params::CharacterCustomizeSystem_SetHairCurlParamUseCurl Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamUseCurlToPart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeHairPart       InPart                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamUseCurlToPart(const ECharacterCustomizeHairPart InPart, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamUseCurlToPart");

	Params::CharacterCustomizeSystem_SetHairCurlParamUseCurlToPart Parms{};

	Parms.InPart = InPart;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamUVOffsetNoiseMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamUVOffsetNoiseMove(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamUVOffsetNoiseMove");

	Params::CharacterCustomizeSystem_SetHairCurlParamUVOffsetNoiseMove Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamUVOffsetNoiseScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamUVOffsetNoiseScale(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamUVOffsetNoiseScale");

	Params::CharacterCustomizeSystem_SetHairCurlParamUVOffsetNoiseScale Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlParamUVOffsetNoiseTilling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlParamUVOffsetNoiseTilling(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlParamUVOffsetNoiseTilling");

	Params::CharacterCustomizeSystem_SetHairCurlParamUVOffsetNoiseTilling Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairCurlPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairCurlPreset(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairCurlPreset");

	Params::CharacterCustomizeSystem_SetHairCurlPreset Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairFrontLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairFrontLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairFrontLength");

	Params::CharacterCustomizeSystem_SetHairFrontLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairFrontMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairFrontMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairFrontMesh");

	Params::CharacterCustomizeSystem_SetHairFrontMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairFrontSideLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairFrontSideLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairFrontSideLength");

	Params::CharacterCustomizeSystem_SetHairFrontSideLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairFrontSideMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairFrontSideMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairFrontSideMesh");

	Params::CharacterCustomizeSystem_SetHairFrontSideMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairHighlightIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairHighlightIntensity(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairHighlightIntensity");

	Params::CharacterCustomizeSystem_SetHairHighlightIntensity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairOtherLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairOtherLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairOtherLength");

	Params::CharacterCustomizeSystem_SetHairOtherLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairOtherMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairOtherMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairOtherMesh");

	Params::CharacterCustomizeSystem_SetHairOtherMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairSet
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairSet(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairSet");

	Params::CharacterCustomizeSystem_SetHairSet Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairSideLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairSideLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairSideLength");

	Params::CharacterCustomizeSystem_SetHairSideLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairSideMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairSideMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairSideMesh");

	Params::CharacterCustomizeSystem_SetHairSideMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairTaperPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairTaperPreset(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairTaperPreset");

	Params::CharacterCustomizeSystem_SetHairTaperPreset Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairTopLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairTopLength(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairTopLength");

	Params::CharacterCustomizeSystem_SetHairTopLength Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHairTopMesh
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHairTopMesh(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHairTopMesh");

	Params::CharacterCustomizeSystem_SetHairTopMesh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetHeadShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetHeadShape(const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetHeadShape");

	Params::CharacterCustomizeSystem_SetHeadShape Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetInnerColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeInnerColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetInnerColor(const ECharacterCustomizeInnerColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetInnerColor");

	Params::CharacterCustomizeSystem_SetInnerColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetInnerColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetInnerColorPreset(const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetInnerColorPreset");

	Params::CharacterCustomizeSystem_SetInnerColorPreset Parms{};

	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetInnerMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetInnerMesh(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetInnerMesh");

	Params::CharacterCustomizeSystem_SetInnerMesh Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetInnerPartVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeClothPartVisibilityInVisibility                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetInnerPartVisibility(const int32 InPartSlot, const ECharacterCustomizeClothPartVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetInnerPartVisibility");

	Params::CharacterCustomizeSystem_SetInnerPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetInnerSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeInnerColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetInnerSpecialColor(const ECharacterCustomizeInnerColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetInnerSpecialColor");

	Params::CharacterCustomizeSystem_SetInnerSpecialColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiMap(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiMap");

	Params::CharacterCustomizeSystem_SetKintsugiMap Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiOffsetU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiOffsetU(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiOffsetU");

	Params::CharacterCustomizeSystem_SetKintsugiOffsetU Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiOffsetV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiOffsetV(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiOffsetV");

	Params::CharacterCustomizeSystem_SetKintsugiOffsetV Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiRotate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiRotate(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiRotate");

	Params::CharacterCustomizeSystem_SetKintsugiRotate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiScaleU
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiScaleU(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiScaleU");

	Params::CharacterCustomizeSystem_SetKintsugiScaleU Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetKintsugiScaleV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetKintsugiScaleV(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetKintsugiScaleV");

	Params::CharacterCustomizeSystem_SetKintsugiScaleV Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetLipColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetLipColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetLipColor");

	Params::CharacterCustomizeSystem_SetLipColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetLipGlossness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetLipGlossness(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetLipGlossness");

	Params::CharacterCustomizeSystem_SetLipGlossness Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetLipOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetLipOpacity(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetLipOpacity");

	Params::CharacterCustomizeSystem_SetLipOpacity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetLookAtType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeLookAtType     InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetLookAtType(const ECharacterCustomizeLookAtType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetLookAtType");

	Params::CharacterCustomizeSystem_SetLookAtType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetManicureColor1
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetManicureColor1(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetManicureColor1");

	Params::CharacterCustomizeSystem_SetManicureColor1 Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetManicureColor2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetManicureColor2(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetManicureColor2");

	Params::CharacterCustomizeSystem_SetManicureColor2 Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetManicureColor3
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetManicureColor3(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetManicureColor3");

	Params::CharacterCustomizeSystem_SetManicureColor3 Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetManicureMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetManicureMap(const class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetManicureMap");

	Params::CharacterCustomizeSystem_SetManicureMap Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMaskColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeMaskColorSlot  ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMaskColor(const ECharacterCustomizeMaskColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMaskColor");

	Params::CharacterCustomizeSystem_SetMaskColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMaskColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMaskColorPreset(const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMaskColorPreset");

	Params::CharacterCustomizeSystem_SetMaskColorPreset Parms{};

	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMaskMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMaskMesh(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMaskMesh");

	Params::CharacterCustomizeSystem_SetMaskMesh Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMaskPartVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InPartSlot                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeClothPartVisibilityInVisibility                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMaskPartVisibility(const int32 InPartSlot, const ECharacterCustomizeClothPartVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMaskPartVisibility");

	Params::CharacterCustomizeSystem_SetMaskPartVisibility Parms{};

	Parms.InPartSlot = InPartSlot;
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMaskSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeMaskColorSlot  ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMaskSpecialColor(const ECharacterCustomizeMaskColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMaskSpecialColor");

	Params::CharacterCustomizeSystem_SetMaskSpecialColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetMouthType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetMouthType(class FName InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetMouthType");

	Params::CharacterCustomizeSystem_SetMouthType Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetOuterColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeOuterColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetOuterColor(const ECharacterCustomizeOuterColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetOuterColor");

	Params::CharacterCustomizeSystem_SetOuterColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetOuterColorPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ColorPresetName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetOuterColorPreset(const class FName& ColorPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetOuterColorPreset");

	Params::CharacterCustomizeSystem_SetOuterColorPreset Parms{};

	Parms.ColorPresetName = ColorPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetOuterMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetOuterMesh(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetOuterMesh");

	Params::CharacterCustomizeSystem_SetOuterMesh Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetOuterSpecialColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeOuterColorSlot ColorSlot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetOuterSpecialColor(const ECharacterCustomizeOuterColorSlot ColorSlot, const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetOuterSpecialColor");

	Params::CharacterCustomizeSystem_SetOuterSpecialColor Parms{};

	Parms.ColorSlot = ColorSlot;
	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetSkinColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetSkinColor(const class FName& Palette, const class FName& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetSkinColor");

	Params::CharacterCustomizeSystem_SetSkinColor Parms{};

	Parms.Palette = Palette;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SetVoiceType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InType                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SetVoiceType(const class FName& InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SetVoiceType");

	Params::CharacterCustomizeSystem_SetVoiceType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.SwitchAccessoryAttachTo
// (Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::SwitchAccessoryAttachTo(const ECharacterCustomizeAccessorySlot Slot, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "SwitchAccessoryAttachTo");

	Params::CharacterCustomizeSystem_SwitchAccessoryAttachTo Parms{};

	Parms.Slot = Slot;
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.UnbindSystemLoadCompleteEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizeSystem::UnbindSystemLoadCompleteEvent(TDelegate<void()> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "UnbindSystemLoadCompleteEvent");

	Params::CharacterCustomizeSystem_UnbindSystemLoadCompleteEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacterCustomizePawn*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterCustomizePawn* ACharacterCustomizeSystem::GetCharacterCustomizePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizePawn");

	Params::CharacterCustomizeSystem_GetCharacterCustomizePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizeSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomizeSettings*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCustomizeSettings* ACharacterCustomizeSystem::GetCharacterCustomizeSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizeSettings");

	Params::CharacterCustomizeSystem_GetCharacterCustomizeSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetCharacterCustomizeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterCustomizeType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeType ACharacterCustomizeSystem::GetCharacterCustomizeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetCharacterCustomizeType");

	Params::CharacterCustomizeSystem_GetCharacterCustomizeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.GetUserAvatarIconBySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECharacterCustomizeUserAvatarSlot InCharacterSlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ACharacterCustomizeSystem::GetUserAvatarIconBySlot(const ECharacterCustomizeUserAvatarSlot InCharacterSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "GetUserAvatarIconBySlot");

	Params::CharacterCustomizeSystem_GetUserAvatarIconBySlot Parms{};

	Parms.InCharacterSlot = InCharacterSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsAnyHatEquipped
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECharacterCustomizeAccessorySlot& InSlot                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsAnyHatEquipped(const ECharacterCustomizeAccessorySlot& InSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsAnyHatEquipped");

	Params::CharacterCustomizeSystem_IsAnyHatEquipped Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeSystem.IsSavedUserAvatarSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECharacterCustomizeUserAvatarSlot InCharacterSlot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterCustomizeSystem::IsSavedUserAvatarSlot(const ECharacterCustomizeUserAvatarSlot InCharacterSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeSystem", "IsSavedUserAvatarSlot");

	Params::CharacterCustomizeSystem_IsSavedUserAvatarSlot Parms{};

	Parms.InCharacterSlot = InCharacterSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.NotifyBackgroundChangeCompleted
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeUIObject::NotifyBackgroundChangeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "NotifyBackgroundChangeCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeUIObject.NotifyUserAvatarIconLoadCompleted
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeUIObject::NotifyUserAvatarIconLoadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "NotifyUserAvatarIconLoadCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeUIObject.NotifyUserAvatarParameterLoadCompleted
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeUIObject::NotifyUserAvatarParameterLoadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "NotifyUserAvatarParameterLoadCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeUIObject.NotifyUserAvatarSaveCompleted
// (Event, Public, BlueprintEvent)

void UCharacterCustomizeUIObject::NotifyUserAvatarSaveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "NotifyUserAvatarSaveCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CharacterCustomizeUIObject.SanitizePlayerName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InMaxCharCount                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeUIObject::SanitizePlayerName(const class FString& InString, const int32 InMaxCharCount, class FString* OutString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "SanitizePlayerName");

	Params::CharacterCustomizeUIObject_SanitizePlayerName Parms{};

	Parms.InString = std::move(InString);
	Parms.InMaxCharCount = InMaxCharCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.SetAdvancedEditMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEditMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUIObject::SetAdvancedEditMode(bool InEditMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "SetAdvancedEditMode");

	Params::CharacterCustomizeUIObject_SetAdvancedEditMode Parms{};

	Parms.InEditMode = InEditMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUIObject.SetAdvancedEditType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCustomizeAdvancedEditType     InEditType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUIObject::SetAdvancedEditType(ECharacterCustomizeAdvancedEditType InEditType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "SetAdvancedEditType");

	Params::CharacterCustomizeUIObject_SetAdvancedEditType Parms{};

	Parms.InEditType = InEditType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUIObject.SetTargetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeAccessorySlot  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUIObject::SetTargetAccessorySlot(const ECharacterCustomizeAccessorySlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "SetTargetAccessorySlot");

	Params::CharacterCustomizeUIObject_SetTargetAccessorySlot Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUIObject.SetTargetFacePaintLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ECharacterCustomizeFacePaintLayer InLayer                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUIObject::SetTargetFacePaintLayer(const ECharacterCustomizeFacePaintLayer InLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "SetTargetFacePaintLayer");

	Params::CharacterCustomizeUIObject_SetTargetFacePaintLayer Parms{};

	Parms.InLayer = InLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUIObject.GetAdvancedEditType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterCustomizeAdvancedEditType     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeAdvancedEditType UCharacterCustomizeUIObject::GetAdvancedEditType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetAdvancedEditType");

	Params::CharacterCustomizeUIObject_GetAdvancedEditType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.GetCustomizeExpression
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// ECharacterCustomizeExpression           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeExpression UCharacterCustomizeUIObject::GetCustomizeExpression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetCustomizeExpression");

	Params::CharacterCustomizeUIObject_GetCustomizeExpression Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.GetCustomizeLookAtType
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// ECharacterCustomizeLookAtType           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeLookAtType UCharacterCustomizeUIObject::GetCustomizeLookAtType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetCustomizeLookAtType");

	Params::CharacterCustomizeUIObject_GetCustomizeLookAtType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.GetCustomizePose
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// ECharacterCustomizePose                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizePose UCharacterCustomizeUIObject::GetCustomizePose() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetCustomizePose");

	Params::CharacterCustomizeUIObject_GetCustomizePose Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.GetTargetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterCustomizeAccessorySlot        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeAccessorySlot UCharacterCustomizeUIObject::GetTargetAccessorySlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetTargetAccessorySlot");

	Params::CharacterCustomizeUIObject_GetTargetAccessorySlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.GetTargetFacePaintLayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterCustomizeFacePaintLayer       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterCustomizeFacePaintLayer UCharacterCustomizeUIObject::GetTargetFacePaintLayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "GetTargetFacePaintLayer");

	Params::CharacterCustomizeUIObject_GetTargetFacePaintLayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUIObject.IsAdvancedEditMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeUIObject::IsAdvancedEditMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCustomizeUIObject", "IsAdvancedEditMode");

	Params::CharacterCustomizeUIObject_IsAdvancedEditMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUtility.DuplicateDMIAndSetTo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkMeshCompo                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaterialIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                SourceMaterialInstance                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeUtility::DuplicateDMIAndSetTo(class USkeletalMeshComponent* SkMeshCompo, int32 MaterialIndex, class UMaterialInstance* SourceMaterialInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "DuplicateDMIAndSetTo");

	Params::CharacterCustomizeUtility_DuplicateDMIAndSetTo Parms{};

	Parms.SkMeshCompo = SkMeshCompo;
	Parms.MaterialIndex = MaterialIndex;
	Parms.SourceMaterialInstance = SourceMaterialInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUtility.GetCharacterModelHeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizeUtility::GetCharacterModelHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "GetCharacterModelHeight");

	Params::CharacterCustomizeUtility_GetCharacterModelHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUtility.SetScalarParameterValueToAllMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUtility::SetScalarParameterValueToAllMaterial(class USkeletalMeshComponent* SkeletalMeshComponent, class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetScalarParameterValueToAllMaterial");

	Params::CharacterCustomizeUtility_SetScalarParameterValueToAllMaterial Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUtility.SetScalarParameterValueToAllMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUtility::SetScalarParameterValueToAllMesh(class AActor* Target, class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetScalarParameterValueToAllMesh");

	Params::CharacterCustomizeUtility_SetScalarParameterValueToAllMesh Parms{};

	Parms.Target = Target;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUtility.SetScalarParameterValueToSceneHierarchy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUtility::SetScalarParameterValueToSceneHierarchy(class USceneComponent* SceneComponent, class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetScalarParameterValueToSceneHierarchy");

	Params::CharacterCustomizeUtility_SetScalarParameterValueToSceneHierarchy Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUtility.SetSkeletalMeshAndDuplicateAllDMI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           OutSkMeshCompo                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InSkMeshCompo                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCustomizeUtility::SetSkeletalMeshAndDuplicateAllDMI(class USkeletalMeshComponent* OutSkMeshCompo, class USkeletalMeshComponent* InSkMeshCompo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetSkeletalMeshAndDuplicateAllDMI");

	Params::CharacterCustomizeUtility_SetSkeletalMeshAndDuplicateAllDMI Parms{};

	Parms.OutSkMeshCompo = OutSkMeshCompo;
	Parms.InSkMeshCompo = InSkMeshCompo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterCustomizeUtility.SetTextureParameterValueToAllMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUtility::SetTextureParameterValueToAllMaterial(class USkeletalMeshComponent* SkeletalMeshComponent, class FName ParameterName, class UTexture* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetTextureParameterValueToAllMaterial");

	Params::CharacterCustomizeUtility_SetTextureParameterValueToAllMaterial Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterCustomizeUtility.SetVectorParameterValueToAllMaterial
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCustomizeUtility::SetVectorParameterValueToAllMaterial(class USkeletalMeshComponent* SkeletalMeshComponent, class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCustomizeUtility", "SetVectorParameterValueToAllMaterial");

	Params::CharacterCustomizeUtility_SetVectorParameterValueToAllMaterial Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterHelper.GetActiveWeaponCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponCategory                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponCategory UCharacterHelper::GetActiveWeaponCategory(const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetActiveWeaponCategory");

	Params::CharacterHelper_GetActiveWeaponCategory Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.GetAnimationControlComponent_BP
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationControlComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationControlComponent* UCharacterHelper::GetAnimationControlComponent_BP(const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetAnimationControlComponent_BP");

	Params::CharacterHelper_GetAnimationControlComponent_BP Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsBuddy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsBuddy(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsBuddy");

	Params::CharacterHelper_IsBuddy Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsCharacterType_BP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InCharacterTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsCharacterType_BP(const class AActor* InActor, const struct FGameplayTag& InCharacterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsCharacterType_BP");

	Params::CharacterHelper_IsCharacterType_BP Parms{};

	Parms.InActor = InActor;
	Parms.InCharacterTag = std::move(InCharacterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsEnemy(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsEnemy");

	Params::CharacterHelper_IsEnemy Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsFemale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsFemale(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsFemale");

	Params::CharacterHelper_IsFemale Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsFieldNPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsFieldNPC(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsFieldNPC");

	Params::CharacterHelper_IsFieldNPC Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsGuestPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsGuestPlayer(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsGuestPlayer");

	Params::CharacterHelper_IsGuestPlayer Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsHostPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsHostPlayer(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsHostPlayer");

	Params::CharacterHelper_IsHostPlayer Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CharacterHelper.IsPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterHelper::IsPlayer(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "IsPlayer");

	Params::CharacterHelper_IsPlayer Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpBuffEndCondition_AttackHit.OnMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInterrupted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuffEndCondition_AttackHit::OnMontageBlendingOut(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffEndCondition_AttackHit", "OnMontageBlendingOut");

	Params::SpBuffEndCondition_AttackHit_OnMontageBlendingOut Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpBuffEndCondition_AttackHit.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuffEndCondition_AttackHit::OnMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffEndCondition_AttackHit", "OnMontageStarted");

	Params::SpBuffEndCondition_AttackHit_OnMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractionComponent.OnRep_ReplicatedFocusedInteraction
// (Final, Native, Protected)

void UInteractionComponent::OnRep_ReplicatedFocusedInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnRep_ReplicatedFocusedInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterInteractionComponent.NetMulticastEndLatestActMontage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UCharacterInteractionComponent::NetMulticastEndLatestActMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "NetMulticastEndLatestActMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterInteractionComponent.ServerStartInteraction
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const int32                             InTriggerOptionIndex                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::ServerStartInteraction(const int32 InTriggerOptionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "ServerStartInteraction");

	Params::CharacterInteractionComponent_ServerStartInteraction Parms{};

	Parms.InTriggerOptionIndex = InTriggerOptionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CharacterVisualControlInterface.K2_GetCharacterVisualControl
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCharacterVisualControlComponent*ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCharacterVisualControlComponent* ICharacterVisualControlInterface::K2_GetCharacterVisualControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CharacterVisualControlInterface", "K2_GetCharacterVisualControl");

	Params::CharacterVisualControlInterface_K2_GetCharacterVisualControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ChronosQuestCollectionActor.SetActorsHiddenInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FName                       InID                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInHidden                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChronosQuestCollectionActor::SetActorsHiddenInEditor(const class FName InID, const bool bInHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ChronosQuestCollectionActor", "SetActorsHiddenInEditor");

	Params::ChronosQuestCollectionActor_SetActorsHiddenInEditor Parms{};

	Parms.InID = InID;
	Parms.bInHidden = bInHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ChronosQuestCollectionActor.ForceActiveActors
// (Final, Native, Public, BlueprintCallable)

void AChronosQuestCollectionActor::ForceActiveActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChronosQuestCollectionActor", "ForceActiveActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ChronosQuestCollectionActor.ForceDeactiveActors
// (Final, Native, Public, BlueprintCallable)

void AChronosQuestCollectionActor::ForceDeactiveActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChronosQuestCollectionActor", "ForceDeactiveActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ChronosQuestCollectionActor.OnChangeBuddyType
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInShowMessage                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChronosQuestCollectionActor::OnChangeBuddyType(const struct FGameplayTag& InBuddyType, const bool bInShowMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChronosQuestCollectionActor", "OnChangeBuddyType");

	Params::ChronosQuestCollectionActor_OnChangeBuddyType Parms{};

	Parms.InBuddyType = std::move(InBuddyType);
	Parms.bInShowMessage = bInShowMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ChronosQuestCollectionActor.OnChangeTimeSeries
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTimeSeries                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChronosQuestCollectionActor::OnChangeTimeSeries(const struct FGameplayTag& InTimeSeries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChronosQuestCollectionActor", "OnChangeTimeSeries");

	Params::ChronosQuestCollectionActor_OnChangeTimeSeries Parms{};

	Parms.InTimeSeries = std::move(InTimeSeries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfAnimInstance.IsRidden
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountWolfAnimInstance::IsRidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfAnimInstance", "IsRidden");

	Params::MountWolfAnimInstance_IsRidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfAnimInstance.GetMountWolfCharacterMovementComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMountWolfMovementComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMountWolfMovementComponent* UMountWolfAnimInstance::GetMountWolfCharacterMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfAnimInstance", "GetMountWolfCharacterMovementComponent");

	Params::MountWolfAnimInstance_GetMountWolfCharacterMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfAnimInstance.GetRootMotionMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ERootMotionMode                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ERootMotionMode UMountWolfAnimInstance::GetRootMotionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfAnimInstance", "GetRootMotionMode");

	Params::MountWolfAnimInstance_GetRootMotionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.AbilityAirDash
// (Final, Native, Public, BlueprintCallable)

void UMountWolfMovementComponent::AbilityAirDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "AbilityAirDash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfMovementComponent.AbilityDashEnd
// (Final, Native, Public, BlueprintCallable)

void UMountWolfMovementComponent::AbilityDashEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "AbilityDashEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfMovementComponent.AbiltiyLandDash
// (Final, Native, Public, BlueprintCallable)

void UMountWolfMovementComponent::AbiltiyLandDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "AbiltiyLandDash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfMovementComponent.CalculateFly2FallPlayRateOnApex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InFly2FallMontage                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountWolfMovementComponent::CalculateFly2FallPlayRateOnApex(class UAnimMontage* InFly2FallMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "CalculateFly2FallPlayRateOnApex");

	Params::MountWolfMovementComponent_CalculateFly2FallPlayRateOnApex Parms{};

	Parms.InFly2FallMontage = InFly2FallMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.IsSprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountWolfMovementComponent::IsSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "IsSprint");

	Params::MountWolfMovementComponent_IsSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.Sprint
// (Final, Native, Public, BlueprintCallable)

void UMountWolfMovementComponent::Sprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "Sprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfMovementComponent.GetDashType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EMountWolfDashType                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EMountWolfDashType UMountWolfMovementComponent::GetDashType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "GetDashType");

	Params::MountWolfMovementComponent_GetDashType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.GetDelayedMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EMountWolfMoveType                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EMountWolfMoveType UMountWolfMovementComponent::GetDelayedMoveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "GetDelayedMoveState");

	Params::MountWolfMovementComponent_GetDelayedMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.GetFallAngleByHorizon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountWolfMovementComponent::GetFallAngleByHorizon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "GetFallAngleByHorizon");

	Params::MountWolfMovementComponent_GetFallAngleByHorizon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.GetLastRequestDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float UMountWolfMovementComponent::GetLastRequestDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "GetLastRequestDirection");

	Params::MountWolfMovementComponent_GetLastRequestDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfMovementComponent.GetMountWolfMoveType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EMountWolfMoveType                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EMountWolfMoveType UMountWolfMovementComponent::GetMountWolfMoveType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfMovementComponent", "GetMountWolfMoveType");

	Params::MountWolfMovementComponent_GetMountWolfMoveType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicBinkMediaActor.PlayMedia
// (Final, Native, Public, BlueprintCallable)

void ACinematicBinkMediaActor::PlayMedia()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicBinkMediaActor", "PlayMedia");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicBinkMediaActor.StopMedia
// (Final, Native, Public, BlueprintCallable)

void ACinematicBinkMediaActor::StopMedia()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicBinkMediaActor", "StopMedia");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StatusEffectGaugeInterface.SetStatusDownEffectApplied
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusDownEffectIconType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle IStatusEffectGaugeInterface::SetStatusDownEffectApplied(const EStatusDownEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("StatusEffectGaugeInterface", "SetStatusDownEffectApplied");

	Params::StatusEffectGaugeInterface_SetStatusDownEffectApplied Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StatusEffectGaugeInterface.SetStatusEffectRemoved
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InIconHandle                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IStatusEffectGaugeInterface::SetStatusEffectRemoved(const struct FStatusEffectIconHandle& InIconHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("StatusEffectGaugeInterface", "SetStatusEffectRemoved");

	Params::StatusEffectGaugeInterface_SetStatusEffectRemoved Parms{};

	Parms.InIconHandle = std::move(InIconHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StatusEffectGaugeInterface.SetStatusEffectTimeElapsed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InIconHandle                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IStatusEffectGaugeInterface::SetStatusEffectTimeElapsed(const struct FStatusEffectIconHandle& InIconHandle, const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("StatusEffectGaugeInterface", "SetStatusEffectTimeElapsed");

	Params::StatusEffectGaugeInterface_SetStatusEffectTimeElapsed Parms{};

	Parms.InIconHandle = std::move(InIconHandle);
	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StatusEffectGaugeInterface.SetStatusUpEffectApplied
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusUpEffectIconType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle IStatusEffectGaugeInterface::SetStatusUpEffectApplied(const EStatusUpEffectIconType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("StatusEffectGaugeInterface", "SetStatusUpEffectApplied");

	Params::StatusEffectGaugeInterface_SetStatusUpEffectApplied Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InfiniteBodilessEnemy.GetInfiniteSpawnEnemies
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FSTR_InfiniteSpawnEnemyParam>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSTR_InfiniteSpawnEnemyParam> AInfiniteBodilessEnemy::GetInfiniteSpawnEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfiniteBodilessEnemy", "GetInfiniteSpawnEnemies");

	Params::InfiniteBodilessEnemy_GetInfiniteSpawnEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpBuff_StaminaCostBase.OnMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInterrupted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuff_StaminaCostBase::OnMontageBlendingOut(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuff_StaminaCostBase", "OnMontageBlendingOut");

	Params::SpBuff_StaminaCostBase_OnMontageBlendingOut Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpBuff_StaminaCostBase.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuff_StaminaCostBase::OnMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuff_StaminaCostBase", "OnMontageStarted");

	Params::SpBuff_StaminaCostBase_OnMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicConversationChoicesShotTrack.OnAbortChoices
// (Final, Native, Private)

void UCinematicConversationChoicesShotTrack::OnAbortChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicConversationChoicesShotTrack", "OnAbortChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicConversationChoicesShotTrack.OnSelectChoices
// (Final, Native, Private)
// Parameters:
// const int32                             InSelectIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicConversationChoicesShotTrack::OnSelectChoices(const int32 InSelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicConversationChoicesShotTrack", "OnSelectChoices");

	Params::CinematicConversationChoicesShotTrack_OnSelectChoices Parms{};

	Parms.InSelectIndex = InSelectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.HideBrightnessSetting
// (Final, Native, Public, BlueprintCallable)

void UTitleInitialSettingsUIObject::HideBrightnessSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "HideBrightnessSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.HideConsentSection
// (Final, Native, Public, BlueprintCallable)

void UTitleInitialSettingsUIObject::HideConsentSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "HideConsentSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.HideMatchingRegionSelect
// (Final, Native, Public, BlueprintCallable)

void UTitleInitialSettingsUIObject::HideMatchingRegionSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "HideMatchingRegionSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.NotifyBrightnessSettingClosed
// (Final, Native, Public, BlueprintCallable)

void UTitleInitialSettingsUIObject::NotifyBrightnessSettingClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "NotifyBrightnessSettingClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.NotifyConsentSectionClosed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InDecided                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleInitialSettingsUIObject::NotifyConsentSectionClosed(bool InDecided)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "NotifyConsentSectionClosed");

	Params::TitleInitialSettingsUIObject_NotifyConsentSectionClosed Parms{};

	Parms.InDecided = InDecided;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.NotifyMatchingRegionSelectClosed
// (Final, Native, Public, BlueprintCallable)

void UTitleInitialSettingsUIObject::NotifyMatchingRegionSelectClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "NotifyMatchingRegionSelectClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowBrightnessSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InClosedDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleInitialSettingsUIObject::ShowBrightnessSetting(TDelegate<void()> InClosedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowBrightnessSetting");

	Params::TitleInitialSettingsUIObject_ShowBrightnessSetting Parms{};

	Parms.InClosedDelegate = InClosedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowBrightnessSettingBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleInitialSettingsUIObject::ShowBrightnessSettingBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowBrightnessSettingBP");

	Params::TitleInitialSettingsUIObject_ShowBrightnessSettingBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowConsentSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FConfigurationConsentTypeTags&InConsentTga                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool Decided)>           InClosedDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleInitialSettingsUIObject::ShowConsentSection(const struct FConfigurationConsentTypeTags& InConsentTga, TDelegate<void(bool Decided)> InClosedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowConsentSection");

	Params::TitleInitialSettingsUIObject_ShowConsentSection Parms{};

	Parms.InConsentTga = std::move(InConsentTga);
	Parms.InClosedDelegate = InClosedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowConsentSectionBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FConfigurationConsentTypeTags&InConsentTypeTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleInitialSettingsUIObject::ShowConsentSectionBP(const struct FConfigurationConsentTypeTags& InConsentTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowConsentSectionBP");

	Params::TitleInitialSettingsUIObject_ShowConsentSectionBP Parms{};

	Parms.InConsentTypeTag = std::move(InConsentTypeTag);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowMatchingRegionSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InClosedDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleInitialSettingsUIObject::ShowMatchingRegionSelect(TDelegate<void()> InClosedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowMatchingRegionSelect");

	Params::TitleInitialSettingsUIObject_ShowMatchingRegionSelect Parms{};

	Parms.InClosedDelegate = InClosedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleInitialSettingsUIObject.ShowMatchingRegionSelectBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleInitialSettingsUIObject::ShowMatchingRegionSelectBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleInitialSettingsUIObject", "ShowMatchingRegionSelectBP");

	Params::TitleInitialSettingsUIObject_ShowMatchingRegionSelectBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.CinematicConversationChoicesTrack.OnAbortChoices
// (Final, Native, Private)

void UCinematicConversationChoicesTrack::OnAbortChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicConversationChoicesTrack", "OnAbortChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicConversationChoicesTrack.OnSelectChoices
// (Final, Native, Private)
// Parameters:
// const int32                             SelectIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicConversationChoicesTrack::OnSelectChoices(const int32 SelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicConversationChoicesTrack", "OnSelectChoices");

	Params::CinematicConversationChoicesTrack_OnSelectChoices Parms{};

	Parms.SelectIndex = SelectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SengokuFunctionLibrary.MarkingObject_RemoveAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USengokuFunctionLibrary::MarkingObject_RemoveAll(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SengokuFunctionLibrary", "MarkingObject_RemoveAll");

	Params::SengokuFunctionLibrary_MarkingObject_RemoveAll Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.HandleFinished
// (Final, Native, Private)

void ACinematicFieldActor::HandleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "HandleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.MulticastMessageSkipLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACinematicFieldActor::MulticastMessageSkipLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "MulticastMessageSkipLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.MulticastPlayLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              bInReplay                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicFieldActor::MulticastPlayLevelSequence(const bool bInReplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "MulticastPlayLevelSequence");

	Params::CinematicFieldActor_MulticastPlayLevelSequence Parms{};

	Parms.bInReplay = bInReplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.MulticastStopLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACinematicFieldActor::MulticastStopLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "MulticastStopLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.OnChangeSmallScenario
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicFieldActor::OnChangeSmallScenario(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnChangeSmallScenario");

	Params::CinematicFieldActor_OnChangeSmallScenario Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.OnComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACinematicFieldActor::OnComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnComponentBeginOverlap");

	Params::CinematicFieldActor_OnComponentBeginOverlap Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.OnComponentEndOverlapStopLevelSequence
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicFieldActor::OnComponentEndOverlapStopLevelSequence(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnComponentEndOverlapStopLevelSequence");

	Params::CinematicFieldActor_OnComponentEndOverlapStopLevelSequence Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.OnEvaluationFormulaResultUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicFieldActor::OnEvaluationFormulaResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnEvaluationFormulaResultUpdated");

	Params::CinematicFieldActor_OnEvaluationFormulaResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.OnFinish
// (Event, Public, BlueprintEvent)

void ACinematicFieldActor::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnFinish");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CinematicFieldActor.OnStop
// (Event, Public, BlueprintEvent)

void ACinematicFieldActor::OnStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "OnStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CinematicFieldActor.ResetPlayRequest
// (Final, Native, Private, BlueprintCallable)

void ACinematicFieldActor::ResetPlayRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "ResetPlayRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFieldActor.StopRequest
// (Final, Native, Private, BlueprintCallable)

void ACinematicFieldActor::StopRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicFieldActor", "StopRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TransactionsMenuUIObject.GetBoosterUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetBoosterUIInfo(const int32 InIndex, struct FUIBoosterInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetBoosterUIInfo");

	Params::TransactionsMenuUIObject_GetBoosterUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetBuddyInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBuddyMetaInfo*                  OutMetaInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// int32*                                  OutTradePoint                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetBuddyInfo(struct FBuddyMetaInfo* OutMetaInfo, int32* OutTradePoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetBuddyInfo");

	Params::TransactionsMenuUIObject_GetBuddyInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMetaInfo != nullptr)
		*OutMetaInfo = std::move(Parms.OutMetaInfo);

	if (OutTradePoint != nullptr)
		*OutTradePoint = Parms.OutTradePoint;
}


// Function Extensions.TransactionsMenuUIObject.GetCounterparty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UTransactionsMenuUIObject::GetCounterparty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetCounterparty");

	Params::TransactionsMenuUIObject_GetCounterparty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.GetDefensiveGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetDefensiveGadgetUIInfo(const int32 InIndex, struct FUIDefensiveGadgetInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetDefensiveGadgetUIInfo");

	Params::TransactionsMenuUIObject_GetDefensiveGadgetUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetIndependentGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetIndependentGadgetUIInfo(const int32 InIndex, struct FUIIndependentGadgetInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetIndependentGadgetUIInfo");

	Params::TransactionsMenuUIObject_GetIndependentGadgetUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetItemUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetItemUIInfo(const int32 InIndex, struct FUIItemInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetItemUIInfo");

	Params::TransactionsMenuUIObject_GetItemUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetJailUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetJailUIInfo(const int32 InIndex, struct FUIJailInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetJailUIInfo");

	Params::TransactionsMenuUIObject_GetJailUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetPlayerStatusSummaryInfo");

	Params::TransactionsMenuUIObject_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetTradeArticleCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArticleCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EArticleCategory UTransactionsMenuUIObject::GetTradeArticleCategory(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetTradeArticleCategory");

	Params::TransactionsMenuUIObject_GetTradeArticleCategory Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.GetTransactionsMenuMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const ETransactionsMenuMode             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ETransactionsMenuMode UTransactionsMenuUIObject::GetTransactionsMenuMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetTransactionsMenuMode");

	Params::TransactionsMenuUIObject_GetTransactionsMenuMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.GetViewNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UTransactionsMenuUIObject::GetViewNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetViewNumber");

	Params::TransactionsMenuUIObject_GetViewNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.GetWeaponGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetWeaponGadgetUIInfo(const int32 InIndex, struct FUIWeaponGadgetInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetWeaponGadgetUIInfo");

	Params::TransactionsMenuUIObject_GetWeaponGadgetUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.GetWeaponUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::GetWeaponUIInfo(const int32 InIndex, struct FUIWeaponInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "GetWeaponUIInfo");

	Params::TransactionsMenuUIObject_GetWeaponUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuUIObject.OpenPresentMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UTransactionsMenuUIObject::OpenPresentMenu(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "OpenPresentMenu");

	Params::TransactionsMenuUIObject_OpenPresentMenu Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.OpenTradeMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UTransactionsMenuUIObject::OpenTradeMenu(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "OpenTradeMenu");

	Params::TransactionsMenuUIObject_OpenTradeMenu Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuUIObject.RequestTransactions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTransactionsMenuUIObject::RequestTransactions(const int32 InIndex, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuUIObject", "RequestTransactions");

	Params::TransactionsMenuUIObject_RequestTransactions Parms{};

	Parms.InIndex = InIndex;
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicFunctionLibrary.GetCameraLocations
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ULevelSequence*             LevelSequence                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 OutLocations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCinematicFunctionLibrary::GetCameraLocations(const class ULevelSequence* LevelSequence, TArray<struct FVector>* OutLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicFunctionLibrary", "GetCameraLocations");

	Params::CinematicFunctionLibrary_GetCameraLocations Parms{};

	Parms.LevelSequence = LevelSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocations != nullptr)
		*OutLocations = std::move(Parms.OutLocations);
}


// Function Extensions.CinematicFunctionLibrary.GetCinematicRootActorTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ULevelSequence*             LevelSequence                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicFunctionLibrary::GetCinematicRootActorTransform(const class ULevelSequence* LevelSequence, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicFunctionLibrary", "GetCinematicRootActorTransform");

	Params::CinematicFunctionLibrary_GetCinematicRootActorTransform Parms{};

	Parms.LevelSequence = LevelSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function Extensions.CinematicLookAtSection.GetCinematicLookAtParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCinematicLookAtParams           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCinematicLookAtParams UCinematicLookAtSection::GetCinematicLookAtParams(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicLookAtSection", "GetCinematicLookAtParams");

	Params::CinematicLookAtSection_GetCinematicLookAtParams Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicMemoryRemnantActor.HandleFinished
// (Final, Native, Private)

void ACinematicMemoryRemnantActor::HandleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantActor", "HandleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantActor.HandlePlay
// (Final, Native, Private)

void ACinematicMemoryRemnantActor::HandlePlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantActor", "HandlePlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantActor.MulticastMessageSkipLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACinematicMemoryRemnantActor::MulticastMessageSkipLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantActor", "MulticastMessageSkipLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantActor.MulticastPlayLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACinematicMemoryRemnantActor::MulticastPlayLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantActor", "MulticastPlayLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSkipActor.HandleFinished
// (Final, Native, Private)

void ACinematicMemoryRemnantSkipActor::HandleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSkipActor", "HandleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSkipActor.MulticastPlayLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              bInReplay                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicMemoryRemnantSkipActor::MulticastPlayLevelSequence(const bool bInReplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSkipActor", "MulticastPlayLevelSequence");

	Params::CinematicMemoryRemnantSkipActor_MulticastPlayLevelSequence Parms{};

	Parms.bInReplay = bInReplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSkipActor.MulticastStopLevelSequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACinematicMemoryRemnantSkipActor::MulticastStopLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSkipActor", "MulticastStopLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSkipActor.StopRequest
// (Final, Native, Private, BlueprintCallable)

void ACinematicMemoryRemnantSkipActor::StopRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSkipActor", "StopRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantStarter.HandleFinished
// (Final, Native, Private)

void ACinematicMemoryRemnantStarter::HandleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantStarter", "HandleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantStarter.OnInitialize
// (Final, Native, Private)

void ACinematicMemoryRemnantStarter::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantStarter", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantStarter.OnStreamingStateChange
// (Final, Native, Private)
// Parameters:
// const bool                              bIsStreaming                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicMemoryRemnantStarter::OnStreamingStateChange(const bool bIsStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantStarter", "OnStreamingStateChange");

	Params::CinematicMemoryRemnantStarter_OnStreamingStateChange Parms{};

	Parms.bIsStreaming = bIsStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSyncCameraActor.OnInitialize
// (Final, Native, Private)

void ACinematicMemoryRemnantSyncCameraActor::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSyncCameraActor", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSyncCameraActor.OnRep_CameraFOV
// (Final, Native, Protected)

void ACinematicMemoryRemnantSyncCameraActor::OnRep_CameraFOV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSyncCameraActor", "OnRep_CameraFOV");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSyncCameraActor.OnRep_CameraTransform
// (Final, Native, Protected)

void ACinematicMemoryRemnantSyncCameraActor::OnRep_CameraTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSyncCameraActor", "OnRep_CameraTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMemoryRemnantSyncCameraActor.OnStreamingStateChange
// (Final, Native, Private)
// Parameters:
// const bool                              bIsStreaming                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicMemoryRemnantSyncCameraActor::OnStreamingStateChange(const bool bIsStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMemoryRemnantSyncCameraActor", "OnStreamingStateChange");

	Params::CinematicMemoryRemnantSyncCameraActor_OnStreamingStateChange Parms{};

	Parms.bIsStreaming = bIsStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicMovieInstance.OnMediaOpened
// (Final, Native, Private)
// Parameters:
// const class FString&                    OpnedUrl                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicMovieInstance::OnMediaOpened(const class FString& OpnedUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicMovieInstance", "OnMediaOpened");

	Params::CinematicMovieInstance_OnMediaOpened Parms{};

	Parms.OpnedUrl = std::move(OpnedUrl);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VoiceSystemManager.Receive_Deinitialize
// (Event, Protected, BlueprintEvent)

void UVoiceSystemManager::Receive_Deinitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceSystemManager", "Receive_Deinitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.VoiceSystemManager.Receive_Initialize
// (Event, Protected, BlueprintEvent)

void UVoiceSystemManager::Receive_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceSystemManager", "Receive_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.CinematicSkeletalMeshActor.FreezePose
// (Native, Public, BlueprintCallable)

void ACinematicSkeletalMeshActor::FreezePose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSkeletalMeshActor", "FreezePose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSkeletalMeshActor.OnCutSceneMessageSkip
// (Final, Native, Public)

void ACinematicSkeletalMeshActor::OnCutSceneMessageSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSkeletalMeshActor", "OnCutSceneMessageSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSkeletalMeshActor.ResetDynamics
// (Final, Native, Public, BlueprintCallable)

void ACinematicSkeletalMeshActor::ResetDynamics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSkeletalMeshActor", "ResetDynamics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.GetCinematicInstancePlayFramerateFromName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InSequenceName                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCinematicSubsystem::GetCinematicInstancePlayFramerateFromName(const class FString& InSequenceName, int32* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "GetCinematicInstancePlayFramerateFromName");

	Params::CinematicSubsystem_GetCinematicInstancePlayFramerateFromName Parms{};

	Parms.InSequenceName = std::move(InSequenceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicSubsystem.PlayCinematic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCinematicInstanceExtensionSettings&InSettings                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkPlayEvent                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkSkipEvent                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEndEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCinematicInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCinematicInstance* UCinematicSubsystem::PlayCinematic(const class UObject* InWorldContextObject, class ULevelSequence* InLevelSequence, const struct FCinematicInstanceExtensionSettings& InSettings, class UAkAudioEvent* AkPlayEvent, class UAkAudioEvent* AkSkipEvent, class UAkAudioEvent* AkEndEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "PlayCinematic");

	Params::CinematicSubsystem_PlayCinematic Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InLevelSequence = InLevelSequence;
	Parms.InSettings = std::move(InSettings);
	Parms.AkPlayEvent = AkPlayEvent;
	Parms.AkSkipEvent = AkSkipEvent;
	Parms.AkEndEvent = AkEndEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicSubsystem.PlayMovie
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMediaPlayer*                     MediaPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMediaSource*                     MediaSource                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMediaTexture*                    MediaTexture                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEventSkip                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCinematicMovieInstance*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCinematicMovieInstance* UCinematicSubsystem::PlayMovie(const class UObject* InWorldContextObject, class UMediaPlayer* MediaPlayer, class UMediaSource* MediaSource, class UMediaTexture* MediaTexture, class UAkAudioEvent* AkEvent, class UAkAudioEvent* AkEventSkip, float VolumeMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "PlayMovie");

	Params::CinematicSubsystem_PlayMovie Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.MediaPlayer = MediaPlayer;
	Parms.MediaSource = MediaSource;
	Parms.MediaTexture = MediaTexture;
	Parms.AkEvent = AkEvent;
	Parms.AkEventSkip = AkEventSkip;
	Parms.VolumeMultiplier = VolumeMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicSubsystem.PreloadVirtualTexture_BP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    InMeshComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const float&                            InScale                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::PreloadVirtualTexture_BP(const TArray<class UMeshComponent*>& InMeshComponents, const float& InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "PreloadVirtualTexture_BP");

	Params::CinematicSubsystem_PreloadVirtualTexture_BP Parms{};

	Parms.InMeshComponents = std::move(InMeshComponents);
	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.PreloadVirtualTexture_MaskedMaterialName_BP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    InMeshComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const float&                            InScale                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            InMaskedMaterialNames                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCinematicSubsystem::PreloadVirtualTexture_MaskedMaterialName_BP(const TArray<class UMeshComponent*>& InMeshComponents, const float& InScale, const TArray<class FString>& InMaskedMaterialNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "PreloadVirtualTexture_MaskedMaterialName_BP");

	Params::CinematicSubsystem_PreloadVirtualTexture_MaskedMaterialName_BP Parms{};

	Parms.InMeshComponents = std::move(InMeshComponents);
	Parms.InScale = InScale;
	Parms.InMaskedMaterialNames = std::move(InMaskedMaterialNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.PreloadVirtualTextureImpl_BP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class UMaterialInterface*>&InMaterials                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 InScreenSpaceSize                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::PreloadVirtualTextureImpl_BP(const TArray<class UMaterialInterface*>& InMaterials, const struct FVector2D& InScreenSpaceSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "PreloadVirtualTextureImpl_BP");

	Params::CinematicSubsystem_PreloadVirtualTextureImpl_BP Parms{};

	Parms.InMaterials = std::move(InMaterials);
	Parms.InScreenSpaceSize = std::move(InScreenSpaceSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.SkipCinematic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::SkipCinematic(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CinematicSubsystem", "SkipCinematic");

	Params::CinematicSubsystem_SkipCinematic Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.FinalizeCinematicField
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::FinalizeCinematicField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "FinalizeCinematicField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.FinalizeDreamWorld
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::FinalizeDreamWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "FinalizeDreamWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.FinalizeMuseumField
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::FinalizeMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "FinalizeMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.GetPlayingCutSceneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCinematicSubsystem::GetPlayingCutSceneName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "GetPlayingCutSceneName");

	Params::CinematicSubsystem_GetPlayingCutSceneName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicSubsystem.InitializeCinematicField
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::InitializeCinematicField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "InitializeCinematicField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.InitializeDreamWorld
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::InitializeDreamWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "InitializeDreamWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.InitializeMuseumField
// (Final, Native, Public, BlueprintCallable)

void UCinematicSubsystem::InitializeMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "InitializeMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnAddScreenMaskTimeComplatedMuseumField
// (Final, Native, Private)

void UCinematicSubsystem::OnAddScreenMaskTimeComplatedMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnAddScreenMaskTimeComplatedMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnCutScene
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnCutScene(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnCutScene");

	Params::CinematicSubsystem_OnCutScene Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnFinishTeleportPlayerMuseumField
// (Final, Native, Private)

void UCinematicSubsystem::OnFinishTeleportPlayerMuseumField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnFinishTeleportPlayerMuseumField");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnGameModeLogoutEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnGameModeLogoutEvent(class AGameModeBase* InGameMode, class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnGameModeLogoutEvent");

	Params::CinematicSubsystem_OnGameModeLogoutEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnGameModePostLoginEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnGameModePostLoginEvent(class AGameModeBase* InGameMode, class APlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnGameModePostLoginEvent");

	Params::CinematicSubsystem_OnGameModePostLoginEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnGameStateSetEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   InGameStateBase                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnGameStateSetEvent(class AGameStateBase* InGameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnGameStateSetEvent");

	Params::CinematicSubsystem_OnGameStateSetEvent Parms{};

	Parms.InGameStateBase = InGameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnInCinematicField
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnInCinematicField(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnInCinematicField");

	Params::CinematicSubsystem_OnInCinematicField Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnInMuseumField
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnInMuseumField(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnInMuseumField");

	Params::CinematicSubsystem_OnInMuseumField Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnReturnToTitle
// (Final, Native, Private)

void UCinematicSubsystem::OnReturnToTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnReturnToTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.OnScreenMaskCompletedMuseumField
// (Final, Native, Private, HasDefaults)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InCameraYaw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseIncrementalFastTravel                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::OnScreenMaskCompletedMuseumField(const struct FVector& InLocation, const struct FRotator& InRotation, float InCameraYaw, bool bUseIncrementalFastTravel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "OnScreenMaskCompletedMuseumField");

	Params::CinematicSubsystem_OnScreenMaskCompletedMuseumField Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.InCameraYaw = InCameraYaw;
	Parms.bUseIncrementalFastTravel = bUseIncrementalFastTravel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicSubsystem.TeleportPlayerWithMuseumField
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InCameraYaw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAppPlayerStart*                  InPlayerStart                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAddScreenMaskTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScreenMaskSettings&       InScreenMaskSettings                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUseIncrementalFastTravel                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicSubsystem::TeleportPlayerWithMuseumField(const struct FVector& InLocation, const struct FRotator& InRotation, float InCameraYaw, class AAppPlayerStart* InPlayerStart, float InAddScreenMaskTime, const struct FScreenMaskSettings& InScreenMaskSettings, bool bUseIncrementalFastTravel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicSubsystem", "TeleportPlayerWithMuseumField");

	Params::CinematicSubsystem_TeleportPlayerWithMuseumField Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.InCameraYaw = InCameraYaw;
	Parms.InPlayerStart = InPlayerStart;
	Parms.InAddScreenMaskTime = InAddScreenMaskTime;
	Parms.InScreenMaskSettings = std::move(InScreenMaskSettings);
	Parms.bUseIncrementalFastTravel = bUseIncrementalFastTravel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CinematicTickActor.EditorTick_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACinematicTickActor::EditorTick_BP(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicTickActor", "EditorTick_BP");

	Params::CinematicTickActor_EditorTick_BP Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeywordManager.MemorizeKeyword
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InKeywordID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsHideTicker                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKeywordManager::MemorizeKeyword(const class UObject* InWorldContext, const class FName& InKeywordID, bool bInIsHideTicker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeywordManager", "MemorizeKeyword");

	Params::KeywordManager_MemorizeKeyword Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InKeywordID = InKeywordID;
	Parms.bInIsHideTicker = bInIsHideTicker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.KeywordManager.GetKeywordDataByID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InKeywordID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKeywordDataTableRow*            OutKeywordData                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeywordManager::GetKeywordDataByID(const class FName& InKeywordID, struct FKeywordDataTableRow* OutKeywordData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "GetKeywordDataByID");

	Params::KeywordManager_GetKeywordDataByID Parms{};

	Parms.InKeywordID = InKeywordID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeywordData != nullptr)
		*OutKeywordData = std::move(Parms.OutKeywordData);

	return Parms.ReturnValue;
}


// Function Extensions.KeywordManager.GetKeywordNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InKeywordID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNewFlag                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeywordManager::GetKeywordNewFlag(const class FName& InKeywordID, bool* OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "GetKeywordNewFlag");

	Params::KeywordManager_GetKeywordNewFlag Parms{};

	Parms.InKeywordID = InKeywordID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewFlag != nullptr)
		*OutNewFlag = Parms.OutNewFlag;

	return Parms.ReturnValue;
}


// Function Extensions.KeywordManager.GetNewAddItemArray
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>*                    OutNewAddItemArray                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKeywordManager::GetNewAddItemArray(TArray<class FName>* OutNewAddItemArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "GetNewAddItemArray");

	Params::KeywordManager_GetNewAddItemArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewAddItemArray != nullptr)
		*OutNewAddItemArray = std::move(Parms.OutNewAddItemArray);
}


// Function Extensions.KeywordManager.IsNewAddItemArrayContains
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeywordManager::IsNewAddItemArrayContains(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "IsNewAddItemArrayContains");

	Params::KeywordManager_IsNewAddItemArrayContains Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.KeywordManager.SetKeywordNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InKeywordID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutNewFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeywordManager::SetKeywordNewFlag(const class FName& InKeywordID, bool OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "SetKeywordNewFlag");

	Params::KeywordManager_SetKeywordNewFlag Parms{};

	Parms.InKeywordID = InKeywordID;
	Parms.OutNewFlag = OutNewFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.KeywordManager.WriteKeywordSaveData
// (Final, Native, Public, BlueprintCallable)

void UKeywordManager::WriteKeywordSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "WriteKeywordSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.KeywordManager.GetKeywordCategoryTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UKeywordManager::GetKeywordCategoryTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "GetKeywordCategoryTable");

	Params::KeywordManager_GetKeywordCategoryTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.KeywordManager.GetKeywordTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UKeywordManager::GetKeywordTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordManager", "GetKeywordTable");

	Params::KeywordManager_GetKeywordTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ClimbingSensor.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClimbingSensor::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbingSensor", "OnBeginOverlap");

	Params::ClimbingSensor_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ClimbingSensor.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClimbingSensor::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbingSensor", "OnEndOverlap");

	Params::ClimbingSensor_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Door.OnInteractionResultConfirmed_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EDoorInteractionResult            InResult                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnInteractionResultConfirmed_BP(const EDoorInteractionResult InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnInteractionResultConfirmed_BP");

	Params::Door_OnInteractionResultConfirmed_BP Parms{};

	Parms.InResult = InResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.Door.OnOpenSwitchActivated
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnOpenSwitchActivated(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnOpenSwitchActivated");

	Params::Door_OnOpenSwitchActivated Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Door.OnRep_ReplicatedDoorContext
// (Final, Native, Protected)

void ADoor::OnRep_ReplicatedDoorContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnRep_ReplicatedDoorContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Door.OnStoryFlagRequirementsResultUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnStoryFlagRequirementsResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnStoryFlagRequirementsResultUpdated");

	Params::Door_OnStoryFlagRequirementsResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Door.RegisterMeshAsClosedDoor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::RegisterMeshAsClosedDoor(class USceneComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "RegisterMeshAsClosedDoor");

	Params::Door_RegisterMeshAsClosedDoor Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Door.RegisterMeshAsOpenedDoor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::RegisterMeshAsOpenedDoor(class USceneComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "RegisterMeshAsOpenedDoor");

	Params::Door_RegisterMeshAsOpenedDoor Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerManager.GetEnemyParamOfOverlapVolumes
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLocationEnemyParam*             OutEnemyParam                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ULocationTriggerManager::GetEnemyParamOfOverlapVolumes(class AActor* InActor, struct FLocationEnemyParam* OutEnemyParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerManager", "GetEnemyParamOfOverlapVolumes");

	Params::LocationTriggerManager_GetEnemyParamOfOverlapVolumes Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEnemyParam != nullptr)
		*OutEnemyParam = std::move(Parms.OutEnemyParam);
}


// Function Extensions.LocationTriggerManager.OnGamePlayTagChanged
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocationTriggerManager::OnGamePlayTagChanged(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerManager", "OnGamePlayTagChanged");

	Params::LocationTriggerManager_OnGamePlayTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerManager.OnPlayerRespawn
// (Final, Native, Private)

void ULocationTriggerManager::OnPlayerRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerManager", "OnPlayerRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerManager.ShowLandmarkName
// (Final, Native, Private)
// Parameters:
// const class FText&                      InLandmarkName                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void ULocationTriggerManager::ShowLandmarkName(const class FText& InLandmarkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerManager", "ShowLandmarkName");

	Params::LocationTriggerManager_ShowLandmarkName Parms{};

	Parms.InLandmarkName = std::move(InLandmarkName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.CloseableDoor.CloseDoor_BP
// (Final, Native, Public, BlueprintCallable)

void ACloseableDoor::CloseDoor_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloseableDoor", "CloseDoor_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteBase.BuildColorPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::BuildColorPalette(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "BuildColorPalette");

	Params::ColorPaletteBase_BuildColorPalette Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteBase.BuildColorPaletteBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::BuildColorPaletteBP(const class FName& PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "BuildColorPaletteBP");

	Params::ColorPaletteBase_BuildColorPaletteBP Parms{};

	Parms.PaletteName = PaletteName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ColorPaletteBase.CheckColorPiece
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      ColorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::CheckColorPiece(const class FName& ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "CheckColorPiece");

	Params::ColorPaletteBase_CheckColorPiece Parms{};

	Parms.ColorName = ColorName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ColorPaletteBase.DeselectColorPiece
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UColorPaletteBase::DeselectColorPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "DeselectColorPiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ColorPaletteBase.EnterPalette
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UColorPaletteBase::EnterPalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "EnterPalette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ColorPaletteBase.FindColorPiece
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ColorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UColorPieceBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPieceBase* UColorPaletteBase::FindColorPiece(class FName ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "FindColorPiece");

	Params::ColorPaletteBase_FindColorPiece Parms{};

	Parms.ColorName = ColorName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.GetAllColorPieces
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UColorPieceBase*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UColorPieceBase*> UColorPaletteBase::GetAllColorPieces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "GetAllColorPieces");

	Params::ColorPaletteBase_GetAllColorPieces Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.GetCheckedColorPiece
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UColorPieceBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPieceBase* UColorPaletteBase::GetCheckedColorPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "GetCheckedColorPiece");

	Params::ColorPaletteBase_GetCheckedColorPiece Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.GetPaletteName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName*                            PaletteName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::GetPaletteName(class FName* PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "GetPaletteName");

	Params::ColorPaletteBase_GetPaletteName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PaletteName != nullptr)
		*PaletteName = Parms.PaletteName;
}


// Function Extensions.ColorPaletteBase.GetSelectedColorPiece
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UColorPieceBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPieceBase* UColorPaletteBase::GetSelectedColorPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "GetSelectedColorPiece");

	Params::ColorPaletteBase_GetSelectedColorPiece Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.GetSelectedColorPieceRowAndColumn
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32*                                  OutRow                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutColumn                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::GetSelectedColorPieceRowAndColumn(int32* OutRow, int32* OutColumn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "GetSelectedColorPieceRowAndColumn");

	Params::ColorPaletteBase_GetSelectedColorPieceRowAndColumn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRow != nullptr)
		*OutRow = Parms.OutRow;

	if (OutColumn != nullptr)
		*OutColumn = Parms.OutColumn;
}


// Function Extensions.ColorPaletteBase.IsSpecialPalette
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteBase::IsSpecialPalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "IsSpecialPalette");

	Params::ColorPaletteBase_IsSpecialPalette Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.LeavePalette
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UColorPaletteBase::LeavePalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "LeavePalette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ColorPaletteBase.SelectColorPiece
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      ColorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteBase::SelectColorPiece(const class FName& ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "SelectColorPiece");

	Params::ColorPaletteBase_SelectColorPiece Parms{};

	Parms.ColorName = ColorName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ColorPaletteBase.SelectColorPieceByDirection
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EDirectionKey                           InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutPaletteSwitched                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteBase::SelectColorPieceByDirection(EDirectionKey InDirection, bool* OutPaletteSwitched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "SelectColorPieceByDirection");

	Params::ColorPaletteBase_SelectColorPieceByDirection Parms{};

	Parms.InDirection = InDirection;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPaletteSwitched != nullptr)
		*OutPaletteSwitched = Parms.OutPaletteSwitched;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.SelectColorPieceByRowAndColumn
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InRow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InColumn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteBase::SelectColorPieceByRowAndColumn(int32 InRow, int32 InColumn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "SelectColorPieceByRowAndColumn");

	Params::ColorPaletteBase_SelectColorPieceByRowAndColumn Parms{};

	Parms.InRow = InRow;
	Parms.InColumn = InColumn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteBase.UncheckColorPiece
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UColorPaletteBase::UncheckColorPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteBase", "UncheckColorPiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.InteractionCollisionSystem.GetInteractionCollisionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       InSurfaceTypeName                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkSwitchValue*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkSwitchValue* UInteractionCollisionSystem::GetInteractionCollisionData(const class FName InSurfaceTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCollisionSystem", "GetInteractionCollisionData");

	Params::InteractionCollisionSystem_GetInteractionCollisionData Parms{};

	Parms.InSurfaceTypeName = InSurfaceTypeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.CheckColorPiece
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PaletteName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ColorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::CheckColorPiece(const class FName& PaletteName, const class FName& ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "CheckColorPiece");

	Params::ColorPaletteList_CheckColorPiece Parms{};

	Parms.PaletteName = PaletteName;
	Parms.ColorName = ColorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UColorPaletteList::ClearSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "ClearSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.CreatePalettes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowSpecialColor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ColorPackNameToOverride                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::CreatePalettes(bool bAllowSpecialColor, class FName ColorPackNameToOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "CreatePalettes");

	Params::ColorPaletteList_CreatePalettes Parms{};

	Parms.bAllowSpecialColor = bAllowSpecialColor;
	Parms.ColorPackNameToOverride = ColorPackNameToOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.DeselectCurrentSelection
// (Final, Native, Public, BlueprintCallable)

void UColorPaletteList::DeselectCurrentSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "DeselectCurrentSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.FindColorPalette
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PaletteName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UColorPaletteBase*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPaletteBase* UColorPaletteList::FindColorPalette(class FName PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "FindColorPalette");

	Params::ColorPaletteList_FindColorPalette Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.FindColorPiece
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PaletteName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ColorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UColorPieceBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPieceBase* UColorPaletteList::FindColorPiece(class FName PaletteName, class FName ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "FindColorPiece");

	Params::ColorPaletteList_FindColorPiece Parms{};

	Parms.PaletteName = PaletteName;
	Parms.ColorName = ColorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.GetAllColorPieces
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UColorPieceBase*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UColorPieceBase*> UColorPaletteList::GetAllColorPieces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetAllColorPieces");

	Params::ColorPaletteList_GetAllColorPieces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.SelectColorPalette
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PaletteName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteList::SelectColorPalette(class FName PaletteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectColorPalette");

	Params::ColorPaletteList_SelectColorPalette Parms{};

	Parms.PaletteName = PaletteName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.SelectColorPiece
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PaletteName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ColorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteList::SelectColorPiece(class FName PaletteName, class FName ColorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectColorPiece");

	Params::ColorPaletteList_SelectColorPiece Parms{};

	Parms.PaletteName = PaletteName;
	Parms.ColorName = ColorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.SelectColorPieceByDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDirectionKey                           InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UColorPaletteList::SelectColorPieceByDirection(EDirectionKey InDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectColorPieceByDirection");

	Params::ColorPaletteList_SelectColorPieceByDirection Parms{};

	Parms.InDirection = InDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.SelectLowerPalette
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUpdateVisual                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::SelectLowerPalette(bool bUpdateVisual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectLowerPalette");

	Params::ColorPaletteList_SelectLowerPalette Parms{};

	Parms.bUpdateVisual = bUpdateVisual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.SelectPaletteByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             SelectionIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::SelectPaletteByIndex(const int32 SelectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectPaletteByIndex");

	Params::ColorPaletteList_SelectPaletteByIndex Parms{};

	Parms.SelectionIndex = SelectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.SelectUpperPalette
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUpdateVisual                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::SelectUpperPalette(bool bUpdateVisual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "SelectUpperPalette");

	Params::ColorPaletteList_SelectUpperPalette Parms{};

	Parms.bUpdateVisual = bUpdateVisual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.UpdatePaletteSelectionByWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UWidget*                    Palette                                                (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::UpdatePaletteSelectionByWidget(const class UWidget* Palette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "UpdatePaletteSelectionByWidget");

	Params::ColorPaletteList_UpdatePaletteSelectionByWidget Parms{};

	Parms.Palette = Palette;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ColorPaletteList.GetCheckedColorName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            PaletteName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            ColorName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::GetCheckedColorName(class FName* PaletteName, class FName* ColorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetCheckedColorName");

	Params::ColorPaletteList_GetCheckedColorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PaletteName != nullptr)
		*PaletteName = Parms.PaletteName;

	if (ColorName != nullptr)
		*ColorName = Parms.ColorName;
}


// Function Extensions.ColorPaletteList.GetCheckedColorPalette
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UColorPaletteBase*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPaletteBase* UColorPaletteList::GetCheckedColorPalette() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetCheckedColorPalette");

	Params::ColorPaletteList_GetCheckedColorPalette Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.GetSelectedColor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName*                            PaletteName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            ColorName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteList::GetSelectedColor(class FName* PaletteName, class FName* ColorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetSelectedColor");

	Params::ColorPaletteList_GetSelectedColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PaletteName != nullptr)
		*PaletteName = Parms.PaletteName;

	if (ColorName != nullptr)
		*ColorName = Parms.ColorName;
}


// Function Extensions.ColorPaletteList.GetSelectedPalette
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UColorPaletteBase*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UColorPaletteBase* UColorPaletteList::GetSelectedPalette() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetSelectedPalette");

	Params::ColorPaletteList_GetSelectedPalette Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ColorPaletteList.GetSelectedPaltteIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UColorPaletteList::GetSelectedPaltteIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ColorPaletteList", "GetSelectedPaltteIndex");

	Params::ColorPaletteList_GetSelectedPaltteIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_GoalLocation.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UQSTask_GoalLocation::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_GoalLocation", "OnBeginOverlap");

	Params::QSTask_GoalLocation_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_GoalLocation.OnDespawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_GoalLocation::OnDespawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_GoalLocation", "OnDespawn");

	Params::QSTask_GoalLocation_OnDespawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_GoalLocation.OnPlayerCampFinished
// (Final, Native, Private)

void UQSTask_GoalLocation::OnPlayerCampFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_GoalLocation", "OnPlayerCampFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_GoalLocation.OnSpawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_GoalLocation::OnSpawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_GoalLocation", "OnSpawn");

	Params::QSTask_GoalLocation_OnSpawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.GetTimeSeriesType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTimeSeries                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimeSeriesTypeTag               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimeSeriesTypeTag UEnvironmentManager::GetTimeSeriesType(const struct FGameplayTag& InTimeSeries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentManager", "GetTimeSeriesType");

	Params::EnvironmentManager_GetTimeSeriesType Parms{};

	Parms.InTimeSeries = std::move(InTimeSeries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.OnCampRestExecute
// (Final, Native, Private)

void UEnvironmentManager::OnCampRestExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnCampRestExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnCampRestFinished
// (Final, Native, Private)

void UEnvironmentManager::OnCampRestFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnCampRestFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnCampRestRequest
// (Final, Native, Private)
// Parameters:
// const EUICampRestOption                 InCampRestOption                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnCampRestRequest(const EUICampRestOption InCampRestOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnCampRestRequest");

	Params::EnvironmentManager_OnCampRestRequest Parms{};

	Parms.InCampRestOption = InCampRestOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnChangeFieldRegion
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTagContainer&     InPreFieldRegion                                       (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InCurrentFieldRegion                                   (Parm, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnChangeFieldRegion(const struct FGameplayTagContainer& InPreFieldRegion, const struct FGameplayTagContainer& InCurrentFieldRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnChangeFieldRegion");

	Params::EnvironmentManager_OnChangeFieldRegion Parms{};

	Parms.InPreFieldRegion = std::move(InPreFieldRegion);
	Parms.InCurrentFieldRegion = std::move(InCurrentFieldRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnChangeGraphicGameModeType
// (Final, Native, Private)
// Parameters:
// EGraphicsGameModeType                   GraphicsGmeModeType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnChangeGraphicGameModeType(EGraphicsGameModeType GraphicsGmeModeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnChangeGraphicGameModeType");

	Params::EnvironmentManager_OnChangeGraphicGameModeType Parms{};

	Parms.GraphicsGmeModeType = GraphicsGmeModeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnChangeStoryFlag
// (Final, Native, Public)
// Parameters:
// const struct FStoryFlagChangeParam&     Param                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnChangeStoryFlag(const struct FStoryFlagChangeParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnChangeStoryFlag");

	Params::EnvironmentManager_OnChangeStoryFlag Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnChangeStoryFlagEvaluationFormula
// (Final, Native, Public)
// Parameters:
// const struct FStoryFlagDataLayerInfo&   DataLayerInfo                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::OnChangeStoryFlagEvaluationFormula(const struct FStoryFlagDataLayerInfo& DataLayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnChangeStoryFlagEvaluationFormula");

	Params::EnvironmentManager_OnChangeStoryFlagEvaluationFormula Parms{};

	Parms.DataLayerInfo = std::move(DataLayerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.OnChangeTimeSeries
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InNewTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnChangeTimeSeries(const struct FGameplayTag& InNewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnChangeTimeSeries");

	Params::EnvironmentManager_OnChangeTimeSeries Parms{};

	Parms.InNewTag = std::move(InNewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnGameModeLogoutEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnGameModeLogoutEvent(class AGameModeBase* InGameMode, class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnGameModeLogoutEvent");

	Params::EnvironmentManager_OnGameModeLogoutEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnGameModePostLoginEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::OnGameModePostLoginEvent(class AGameModeBase* InGameMode, class APlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnGameModePostLoginEvent");

	Params::EnvironmentManager_OnGameModePostLoginEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.OnWorldBeginPlayEvent
// (Final, Native, Private)

void UEnvironmentManager::OnWorldBeginPlayEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "OnWorldBeginPlayEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.RegisterLightController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALightController*                 InLightController                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::RegisterLightController(class ALightController* InLightController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "RegisterLightController");

	Params::EnvironmentManager_RegisterLightController Parms{};

	Parms.InLightController = InLightController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetCurrentWeatherRandom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsImmediate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetCurrentWeatherRandom(bool IsImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetCurrentWeatherRandom");

	Params::EnvironmentManager_SetCurrentWeatherRandom Parms{};

	Parms.IsImmediate = IsImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetEnableInGameClock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetEnableInGameClock(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetEnableInGameClock");

	Params::EnvironmentManager_SetEnableInGameClock Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetEnableWeatherChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetEnableWeatherChange(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetEnableWeatherChange");

	Params::EnvironmentManager_SetEnableWeatherChange Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetFastForwardRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// double                                  InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetFastForwardRate(double InRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetFastForwardRate");

	Params::EnvironmentManager_SetFastForwardRate Parms{};

	Parms.InRate = InRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetInGameClock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// double                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFastForward                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetInGameClock(double InTime, bool InFastForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetInGameClock");

	Params::EnvironmentManager_SetInGameClock Parms{};

	Parms.InTime = InTime;
	Parms.InFastForward = InFastForward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetNextWeather
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWeatherTypeTag&           InNextWeatherType                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetNextWeather(const struct FWeatherTypeTag& InNextWeatherType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetNextWeather");

	Params::EnvironmentManager_SetNextWeather Parms{};

	Parms.InNextWeatherType = std::move(InNextWeatherType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetTimeSeries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTimeSeries                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsChangeInGameClock                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsChangeWeather                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScreenMaskSettings&       InScreenMaskSettings                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsUseScreenMask                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResetGame                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetTimeSeries(const struct FGameplayTag& InTimeSeries, bool IsChangeInGameClock, bool IsChangeWeather, const struct FScreenMaskSettings& InScreenMaskSettings, bool IsUseScreenMask, bool IsResetGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetTimeSeries");

	Params::EnvironmentManager_SetTimeSeries Parms{};

	Parms.InTimeSeries = std::move(InTimeSeries);
	Parms.IsChangeInGameClock = IsChangeInGameClock;
	Parms.IsChangeWeather = IsChangeWeather;
	Parms.InScreenMaskSettings = std::move(InScreenMaskSettings);
	Parms.IsUseScreenMask = IsUseScreenMask;
	Parms.IsResetGame = IsResetGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.SetWeather
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWeatherTypeTag&           InWeatherType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsImmediate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetWeather(const struct FWeatherTypeTag& InWeatherType, bool IsImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetWeather");

	Params::EnvironmentManager_SetWeather Parms{};

	Parms.InWeatherType = std::move(InWeatherType);
	Parms.IsImmediate = IsImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentManager.GetCurrentWeather
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeatherTypeTag                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FWeatherTypeTag UEnvironmentManager::GetCurrentWeather() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetCurrentWeather");

	Params::EnvironmentManager_GetCurrentWeather Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetFastForwardRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UEnvironmentManager::GetFastForwardRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetFastForwardRate");

	Params::EnvironmentManager_GetFastForwardRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetInGameClock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UEnvironmentManager::GetInGameClock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetInGameClock");

	Params::EnvironmentManager_GetInGameClock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetLightController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALightController*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALightController* UEnvironmentManager::GetLightController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetLightController");

	Params::EnvironmentManager_GetLightController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetNextWeather
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeatherTypeTag                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FWeatherTypeTag UEnvironmentManager::GetNextWeather() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetNextWeather");

	Params::EnvironmentManager_GetNextWeather Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetPreTimeSeries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UEnvironmentManager::GetPreTimeSeries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetPreTimeSeries");

	Params::EnvironmentManager_GetPreTimeSeries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetReflectWeatherTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEnvironmentManager::GetReflectWeatherTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetReflectWeatherTime");

	Params::EnvironmentManager_GetReflectWeatherTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.GetTimeSeries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UEnvironmentManager::GetTimeSeries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetTimeSeries");

	Params::EnvironmentManager_GetTimeSeries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.IsEnableInGameClock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::IsEnableInGameClock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "IsEnableInGameClock");

	Params::EnvironmentManager_IsEnableInGameClock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.IsEnableLightController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::IsEnableLightController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "IsEnableLightController");

	Params::EnvironmentManager_IsEnableLightController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.IsEnableWeatherChange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::IsEnableWeatherChange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "IsEnableWeatherChange");

	Params::EnvironmentManager_IsEnableWeatherChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.IsFastForward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::IsFastForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "IsFastForward");

	Params::EnvironmentManager_IsFastForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnvironmentManager.IsReflectWeather
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnvironmentManager::IsReflectWeather() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "IsReflectWeather");

	Params::EnvironmentManager_IsReflectWeather Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.ApplyConfigAudioRTPCValue
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::ApplyConfigAudioRTPCValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "ApplyConfigAudioRTPCValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.GetConfigAccessibilitySaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationAccessibilitySaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationAccessibilitySaveData UConfigurationManager::GetConfigAccessibilitySaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigAccessibilitySaveData");

	Params::ConfigurationManager_GetConfigAccessibilitySaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigAudioSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationAudioData    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationAudioData UConfigurationManager::GetConfigAudioSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigAudioSaveData");

	Params::ConfigurationManager_GetConfigAudioSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationTags&        InCameraTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationCameraSaveData UConfigurationManager::GetConfigCameraSaveData(const struct FConfigurationTags& InCameraTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigCameraSaveData");

	Params::ConfigurationManager_GetConfigCameraSaveData Parms{};

	Parms.InCameraTag = std::move(InCameraTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigCharacterCustomizeCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationCharacterCustomizeCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationCharacterCustomizeCameraSaveData UConfigurationManager::GetConfigCharacterCustomizeCameraSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigCharacterCustomizeCameraSaveData");

	Params::ConfigurationManager_GetConfigCharacterCustomizeCameraSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigConsentSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationConsentTypeTags&InConsentTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationConsentSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationConsentSaveData UConfigurationManager::GetConfigConsentSaveData(const struct FConfigurationConsentTypeTags& InConsentTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigConsentSaveData");

	Params::ConfigurationManager_GetConfigConsentSaveData Parms{};

	Parms.InConsentTag = std::move(InConsentTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigDownloadContentsSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationDownloadContentsSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationDownloadContentsSaveData UConfigurationManager::GetConfigDownloadContentsSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigDownloadContentsSaveData");

	Params::ConfigurationManager_GetConfigDownloadContentsSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigGameSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationGameSaveData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationGameSaveData UConfigurationManager::GetConfigGameSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigGameSaveData");

	Params::ConfigurationManager_GetConfigGameSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigGraphicSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationGraphicData  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationGraphicData UConfigurationManager::GetConfigGraphicSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigGraphicSaveData");

	Params::ConfigurationManager_GetConfigGraphicSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigKeyAssignSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationKeyAssignSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationKeyAssignSaveData UConfigurationManager::GetConfigKeyAssignSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigKeyAssignSaveData");

	Params::ConfigurationManager_GetConfigKeyAssignSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigLanguageSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationLanguageSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationLanguageSaveData UConfigurationManager::GetConfigLanguageSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigLanguageSaveData");

	Params::ConfigurationManager_GetConfigLanguageSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigMonitorBrightnessSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UConfigurationManager::GetConfigMonitorBrightnessSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigMonitorBrightnessSaveData");

	Params::ConfigurationManager_GetConfigMonitorBrightnessSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigNetworkSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationNetworkSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationNetworkSaveData UConfigurationManager::GetConfigNetworkSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigNetworkSaveData");

	Params::ConfigurationManager_GetConfigNetworkSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigNetworkUserSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationNetworkUserSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationNetworkUserSaveData UConfigurationManager::GetConfigNetworkUserSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigNetworkUserSaveData");

	Params::ConfigurationManager_GetConfigNetworkUserSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigOperationSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationOperationSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationOperationSaveData UConfigurationManager::GetConfigOperationSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigOperationSaveData");

	Params::ConfigurationManager_GetConfigOperationSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigAccessibilitySaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationAccessibilitySaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationAccessibilitySaveData UConfigurationManager::GetDefaultConfigAccessibilitySaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigAccessibilitySaveData");

	Params::ConfigurationManager_GetDefaultConfigAccessibilitySaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigAudioSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationAudioData    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationAudioData UConfigurationManager::GetDefaultConfigAudioSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigAudioSaveData");

	Params::ConfigurationManager_GetDefaultConfigAudioSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationTags&        InCameraTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationCameraSaveData UConfigurationManager::GetDefaultConfigCameraSaveData(const struct FConfigurationTags& InCameraTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigCameraSaveData");

	Params::ConfigurationManager_GetDefaultConfigCameraSaveData Parms{};

	Parms.InCameraTag = std::move(InCameraTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigCharacterCustomizeCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationCharacterCustomizeCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationCharacterCustomizeCameraSaveData UConfigurationManager::GetDefaultConfigCharacterCustomizeCameraSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigCharacterCustomizeCameraSaveData");

	Params::ConfigurationManager_GetDefaultConfigCharacterCustomizeCameraSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigConsentSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationConsentTypeTags&InConsentTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationConsentSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationConsentSaveData UConfigurationManager::GetDefaultConfigConsentSaveData(const struct FConfigurationConsentTypeTags& InConsentTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigConsentSaveData");

	Params::ConfigurationManager_GetDefaultConfigConsentSaveData Parms{};

	Parms.InConsentTag = std::move(InConsentTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigDownloadContentsSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationDownloadContentsSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationDownloadContentsSaveData UConfigurationManager::GetDefaultConfigDownloadContentsSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigDownloadContentsSaveData");

	Params::ConfigurationManager_GetDefaultConfigDownloadContentsSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigGameSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationGameSaveData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationGameSaveData UConfigurationManager::GetDefaultConfigGameSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigGameSaveData");

	Params::ConfigurationManager_GetDefaultConfigGameSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigGraphicSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationGraphicData  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationGraphicData UConfigurationManager::GetDefaultConfigGraphicSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigGraphicSaveData");

	Params::ConfigurationManager_GetDefaultConfigGraphicSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigLanguageSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationLanguageSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationLanguageSaveData UConfigurationManager::GetDefaultConfigLanguageSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigLanguageSaveData");

	Params::ConfigurationManager_GetDefaultConfigLanguageSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigMonitorBrightnessSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UConfigurationManager::GetDefaultConfigMonitorBrightnessSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigMonitorBrightnessSaveData");

	Params::ConfigurationManager_GetDefaultConfigMonitorBrightnessSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigNetworkSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationNetworkSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationNetworkSaveData UConfigurationManager::GetDefaultConfigNetworkSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigNetworkSaveData");

	Params::ConfigurationManager_GetDefaultConfigNetworkSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigNetworkUserSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationNetworkUserSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationNetworkUserSaveData UConfigurationManager::GetDefaultConfigNetworkUserSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigNetworkUserSaveData");

	Params::ConfigurationManager_GetDefaultConfigNetworkUserSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigOperationSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FConfigurationOperationSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FConfigurationOperationSaveData UConfigurationManager::GetDefaultConfigOperationSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigOperationSaveData");

	Params::ConfigurationManager_GetDefaultConfigOperationSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetIsMatchingRegionSaved
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationManager::GetIsMatchingRegionSaved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetIsMatchingRegionSaved");

	Params::ConfigurationManager_GetIsMatchingRegionSaved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetIsMonitorBrightnessSaved
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationManager::GetIsMonitorBrightnessSaved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetIsMonitorBrightnessSaved");

	Params::ConfigurationManager_GetIsMonitorBrightnessSaved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetLocaleEULA
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UConfigurationManager::GetLocaleEULA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetLocaleEULA");

	Params::ConfigurationManager_GetLocaleEULA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetSupportedScreenResolutionArray
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntPoint>*               OutScreenResolutionArray                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationManager::GetSupportedScreenResolutionArray(TArray<struct FIntPoint>* OutScreenResolutionArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetSupportedScreenResolutionArray");

	Params::ConfigurationManager_GetSupportedScreenResolutionArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenResolutionArray != nullptr)
		*OutScreenResolutionArray = std::move(Parms.OutScreenResolutionArray);

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetSupportedScreenResolutionArrayFromScreenMode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EGraphicsScreenMode&              InScreenMode                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntPoint>*               OutScreenResolutionArray                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationManager::GetSupportedScreenResolutionArrayFromScreenMode(const EGraphicsScreenMode& InScreenMode, TArray<struct FIntPoint>* OutScreenResolutionArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetSupportedScreenResolutionArrayFromScreenMode");

	Params::ConfigurationManager_GetSupportedScreenResolutionArrayFromScreenMode Parms{};

	Parms.InScreenMode = InScreenMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenResolutionArray != nullptr)
		*OutScreenResolutionArray = std::move(Parms.OutScreenResolutionArray);

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.OnChangeGameModeType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EGraphicsGameModeType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationGraphicData& InGraphicData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::OnChangeGameModeType(EGraphicsGameModeType InType, const struct FConfigurationGraphicData& InGraphicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "OnChangeGameModeType");

	Params::ConfigurationManager_OnChangeGameModeType Parms{};

	Parms.InType = InType;
	Parms.InGraphicData = std::move(InGraphicData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.RestoreGraphicGameMode
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::RestoreGraphicGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "RestoreGraphicGameMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.RestoreIndoorShadowSetting
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::RestoreIndoorShadowSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "RestoreIndoorShadowSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetAmbientVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetAmbientVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetAmbientVolume");

	Params::ConfigurationManager_SetAmbientVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetBGMVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetBGMVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetBGMVolume");

	Params::ConfigurationManager_SetBGMVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigAccessibilitySaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationAccessibilitySaveData&InAccessibilityData                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigAccessibilitySaveData(const struct FConfigurationAccessibilitySaveData& InAccessibilityData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigAccessibilitySaveData");

	Params::ConfigurationManager_SetConfigAccessibilitySaveData Parms{};

	Parms.InAccessibilityData = std::move(InAccessibilityData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigAudioSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationAudioData&   InAudioData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigAudioSaveData(const struct FConfigurationAudioData& InAudioData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigAudioSaveData");

	Params::ConfigurationManager_SetConfigAudioSaveData Parms{};

	Parms.InAudioData = std::move(InAudioData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigCameraSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationTags&        InCameraTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationCameraSaveData&InCameraData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigCameraSaveData(const struct FConfigurationTags& InCameraTag, const struct FConfigurationCameraSaveData& InCameraData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigCameraSaveData");

	Params::ConfigurationManager_SetConfigCameraSaveData Parms{};

	Parms.InCameraTag = std::move(InCameraTag);
	Parms.InCameraData = std::move(InCameraData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigCharacterCustomizeCameraSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationCharacterCustomizeCameraSaveData&InCharacterCustomizeCameraSaveData                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigCharacterCustomizeCameraSaveData(const struct FConfigurationCharacterCustomizeCameraSaveData& InCharacterCustomizeCameraSaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigCharacterCustomizeCameraSaveData");

	Params::ConfigurationManager_SetConfigCharacterCustomizeCameraSaveData Parms{};

	Parms.InCharacterCustomizeCameraSaveData = std::move(InCharacterCustomizeCameraSaveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigConsentSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationConsentTypeTags&InConsentTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FConfigurationConsentSaveData&InConsentData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigConsentSaveData(const struct FConfigurationConsentTypeTags& InConsentTag, const struct FConfigurationConsentSaveData& InConsentData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigConsentSaveData");

	Params::ConfigurationManager_SetConfigConsentSaveData Parms{};

	Parms.InConsentTag = std::move(InConsentTag);
	Parms.InConsentData = std::move(InConsentData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigDownloadContentsSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationDownloadContentsSaveData&InDownloadContentsSaveData                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigDownloadContentsSaveData(const struct FConfigurationDownloadContentsSaveData& InDownloadContentsSaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigDownloadContentsSaveData");

	Params::ConfigurationManager_SetConfigDownloadContentsSaveData Parms{};

	Parms.InDownloadContentsSaveData = std::move(InDownloadContentsSaveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigGameSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationGameSaveData&InGameData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigGameSaveData(const struct FConfigurationGameSaveData& InGameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigGameSaveData");

	Params::ConfigurationManager_SetConfigGameSaveData Parms{};

	Parms.InGameData = std::move(InGameData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigGraphicSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationGraphicData& InGraphicData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigGraphicSaveData(const struct FConfigurationGraphicData& InGraphicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigGraphicSaveData");

	Params::ConfigurationManager_SetConfigGraphicSaveData Parms{};

	Parms.InGraphicData = std::move(InGraphicData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigKeyAssignSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationKeyAssignSaveData&InKeyAssignData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigKeyAssignSaveData(const struct FConfigurationKeyAssignSaveData& InKeyAssignData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigKeyAssignSaveData");

	Params::ConfigurationManager_SetConfigKeyAssignSaveData Parms{};

	Parms.InKeyAssignData = std::move(InKeyAssignData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigLanguageSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationLanguageSaveData&InLanguageData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigLanguageSaveData(const struct FConfigurationLanguageSaveData& InLanguageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigLanguageSaveData");

	Params::ConfigurationManager_SetConfigLanguageSaveData Parms{};

	Parms.InLanguageData = std::move(InLanguageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigMonitorBrightnessSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBrightness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigMonitorBrightnessSaveData(float InBrightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigMonitorBrightnessSaveData");

	Params::ConfigurationManager_SetConfigMonitorBrightnessSaveData Parms{};

	Parms.InBrightness = InBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigNetworkSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationNetworkSaveData&InNetworkData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigNetworkSaveData(const struct FConfigurationNetworkSaveData& InNetworkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigNetworkSaveData");

	Params::ConfigurationManager_SetConfigNetworkSaveData Parms{};

	Parms.InNetworkData = std::move(InNetworkData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigNetworkUserSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationNetworkUserSaveData&InNetworkData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigNetworkUserSaveData(const struct FConfigurationNetworkUserSaveData& InNetworkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigNetworkUserSaveData");

	Params::ConfigurationManager_SetConfigNetworkUserSaveData Parms{};

	Parms.InNetworkData = std::move(InNetworkData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigOperationSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationOperationSaveData&InOperationData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigOperationSaveData(const struct FConfigurationOperationSaveData& InOperationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigOperationSaveData");

	Params::ConfigurationManager_SetConfigOperationSaveData Parms{};

	Parms.InOperationData = std::move(InOperationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigPhotoModeCameraSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationPhotoModeCameraSaveData&InCameraData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigPhotoModeCameraSaveData(const struct FConfigurationPhotoModeCameraSaveData& InCameraData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigPhotoModeCameraSaveData");

	Params::ConfigurationManager_SetConfigPhotoModeCameraSaveData Parms{};

	Parms.InCameraData = std::move(InCameraData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetConfigPhotoModeSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigurationPhotoModeSaveData&InPhotoModeData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConfigurationManager::SetConfigPhotoModeSaveData(const struct FConfigurationPhotoModeSaveData& InPhotoModeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetConfigPhotoModeSaveData");

	Params::ConfigurationManager_SetConfigPhotoModeSaveData Parms{};

	Parms.InPhotoModeData = std::move(InPhotoModeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetF11TogglesFullscreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetF11TogglesFullscreen(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetF11TogglesFullscreen");

	Params::ConfigurationManager_SetF11TogglesFullscreen Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetMasterVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetMasterVolume");

	Params::ConfigurationManager_SetMasterVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetMenuVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetMenuVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetMenuVolume");

	Params::ConfigurationManager_SetMenuVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetSeVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetSeVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetSeVolume");

	Params::ConfigurationManager_SetSeVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetSpeakerType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetSpeakerType(int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetSpeakerType");

	Params::ConfigurationManager_SetSpeakerType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetTemporalGraphicGameMode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ETemporalGraphicsGameMode&        InMode                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetTemporalGraphicGameMode(const ETemporalGraphicsGameMode& InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetTemporalGraphicGameMode");

	Params::ConfigurationManager_SetTemporalGraphicGameMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.SetVoiceVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::SetVoiceVolume(float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "SetVoiceVolume");

	Params::ConfigurationManager_SetVoiceVolume Parms{};

	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.UpdateF11TogglesFullscreen
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::UpdateF11TogglesFullscreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "UpdateF11TogglesFullscreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.UpdateIndoorShadowSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            InResolutionLodBiasDirectional                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            InResolutionLodBiasLocal                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationManager::UpdateIndoorShadowSetting(const float& InResolutionLodBiasDirectional, const float& InResolutionLodBiasLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "UpdateIndoorShadowSetting");

	Params::ConfigurationManager_UpdateIndoorShadowSetting Parms{};

	Parms.InResolutionLodBiasDirectional = InResolutionLodBiasDirectional;
	Parms.InResolutionLodBiasLocal = InResolutionLodBiasLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.WriteConfigSaveData
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::WriteConfigSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "WriteConfigSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.WriteConfigUserSaveData
// (Final, Native, Public, BlueprintCallable)

void UConfigurationManager::WriteConfigUserSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "WriteConfigUserSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationManager.GetConfigPhotoModeCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigurationPhotoModeCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationPhotoModeCameraSaveData UConfigurationManager::GetConfigPhotoModeCameraSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigPhotoModeCameraSaveData");

	Params::ConfigurationManager_GetConfigPhotoModeCameraSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetConfigPhotoModeSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigurationPhotoModeSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationPhotoModeSaveData UConfigurationManager::GetConfigPhotoModeSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetConfigPhotoModeSaveData");

	Params::ConfigurationManager_GetConfigPhotoModeSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigPhotoModeCameraSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigurationPhotoModeCameraSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationPhotoModeCameraSaveData UConfigurationManager::GetDefaultConfigPhotoModeCameraSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigPhotoModeCameraSaveData");

	Params::ConfigurationManager_GetDefaultConfigPhotoModeCameraSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationManager.GetDefaultConfigPhotoModeSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigurationPhotoModeSaveDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FConfigurationPhotoModeSaveData UConfigurationManager::GetDefaultConfigPhotoModeSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationManager", "GetDefaultConfigPhotoModeSaveData");

	Params::ConfigurationManager_GetDefaultConfigPhotoModeSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.BindDelegate
// (Final, Native, Public, BlueprintCallable)

void UConfigurationUIObject::BindDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "BindDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.CanSelectTitleMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationUIObject::CanSelectTitleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "CanSelectTitleMenu");

	Params::ConfigurationUIObject_CanSelectTitleMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetConfigDisplayType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EConfigDisplayType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConfigDisplayType UConfigurationUIObject::GetConfigDisplayType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetConfigDisplayType");

	Params::ConfigurationUIObject_GetConfigDisplayType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetEmotionTextArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>*                    OutRowName                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FText>*                    OutTextArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationUIObject::GetEmotionTextArray(TArray<class FName>* OutRowName, TArray<class FText>* OutTextArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetEmotionTextArray");

	Params::ConfigurationUIObject_GetEmotionTextArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRowName != nullptr)
		*OutRowName = std::move(Parms.OutRowName);

	if (OutTextArray != nullptr)
		*OutTextArray = std::move(Parms.OutTextArray);

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetIsConsole
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationUIObject::GetIsConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetIsConsole");

	Params::ConfigurationUIObject_GetIsConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.OnNoSelectReturnToTitle
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInNoSelectReturnToTitle                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationUIObject::OnNoSelectReturnToTitle(bool bInNoSelectReturnToTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "OnNoSelectReturnToTitle");

	Params::ConfigurationUIObject_OnNoSelectReturnToTitle Parms{};

	Parms.bInNoSelectReturnToTitle = bInNoSelectReturnToTitle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ConfigurationUIObject.OnSetCurrentAudioCultureCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurationUIObject::OnSetCurrentAudioCultureCompleted(bool bSucceeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "OnSetCurrentAudioCultureCompleted");

	Params::ConfigurationUIObject_OnSetCurrentAudioCultureCompleted Parms{};

	Parms.bSucceeded = bSucceeded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ConfigurationUIObject.RevartKeyAssign
// (Final, Native, Public, BlueprintCallable)

void UConfigurationUIObject::RevartKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "RevartKeyAssign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.SetCustomActionKeyAssignInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InGamePad                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InKeyboardAndMouse_Main                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InKeyboardAndMouse_Sub                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationUIObject::SetCustomActionKeyAssignInfo(const struct FGameplayTag& InTag, const TArray<struct FKey>& InGamePad, const TArray<struct FKey>& InKeyboardAndMouse_Main, const TArray<struct FKey>& InKeyboardAndMouse_Sub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "SetCustomActionKeyAssignInfo");

	Params::ConfigurationUIObject_SetCustomActionKeyAssignInfo Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InGamePad = std::move(InGamePad);
	Parms.InKeyboardAndMouse_Main = std::move(InKeyboardAndMouse_Main);
	Parms.InKeyboardAndMouse_Sub = std::move(InKeyboardAndMouse_Sub);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.SetCustomMoveAndLookKeyAssignInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigMoveAndLookKeyAssignInfo&InMoveAndLookKeyAssignInfo                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationUIObject::SetCustomMoveAndLookKeyAssignInfo(const struct FConfigMoveAndLookKeyAssignInfo& InMoveAndLookKeyAssignInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "SetCustomMoveAndLookKeyAssignInfo");

	Params::ConfigurationUIObject_SetCustomMoveAndLookKeyAssignInfo Parms{};

	Parms.InMoveAndLookKeyAssignInfo = std::move(InMoveAndLookKeyAssignInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.SetSaveKeyAssign
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InGamePad                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InKeyboardAndMouse_Main                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FKey>&              InKeyboardAndMouse_Sub                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationUIObject::SetSaveKeyAssign(const struct FGameplayTag& InTag, const TArray<struct FKey>& InGamePad, const TArray<struct FKey>& InKeyboardAndMouse_Main, const TArray<struct FKey>& InKeyboardAndMouse_Sub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "SetSaveKeyAssign");

	Params::ConfigurationUIObject_SetSaveKeyAssign Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InGamePad = std::move(InGamePad);
	Parms.InKeyboardAndMouse_Main = std::move(InKeyboardAndMouse_Main);
	Parms.InKeyboardAndMouse_Sub = std::move(InKeyboardAndMouse_Sub);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.SetSaveMoveAndLookKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FConfigMoveAndLookKeyAssignInfo&InMoveAndLookKeyAssignInfo                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConfigurationUIObject::SetSaveMoveAndLookKey(const struct FConfigMoveAndLookKeyAssignInfo& InMoveAndLookKeyAssignInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "SetSaveMoveAndLookKey");

	Params::ConfigurationUIObject_SetSaveMoveAndLookKey Parms{};

	Parms.InMoveAndLookKeyAssignInfo = std::move(InMoveAndLookKeyAssignInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.UnbindDelegate
// (Final, Native, Public, BlueprintCallable)

void UConfigurationUIObject::UnbindDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "UnbindDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.UpdateKeyAssign
// (Final, Native, Public, BlueprintCallable)

void UConfigurationUIObject::UpdateKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "UpdateKeyAssign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ConfigurationUIObject.GetCustomActionKeyAssignInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutGamePad                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Main                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Sub                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UConfigurationUIObject::GetCustomActionKeyAssignInfo(const struct FGameplayTag& InTag, TArray<struct FKey>* OutGamePad, TArray<struct FKey>* OutKeyboardAndMouse_Main, TArray<struct FKey>* OutKeyboardAndMouse_Sub) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetCustomActionKeyAssignInfo");

	Params::ConfigurationUIObject_GetCustomActionKeyAssignInfo Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGamePad != nullptr)
		*OutGamePad = std::move(Parms.OutGamePad);

	if (OutKeyboardAndMouse_Main != nullptr)
		*OutKeyboardAndMouse_Main = std::move(Parms.OutKeyboardAndMouse_Main);

	if (OutKeyboardAndMouse_Sub != nullptr)
		*OutKeyboardAndMouse_Sub = std::move(Parms.OutKeyboardAndMouse_Sub);
}


// Function Extensions.ConfigurationUIObject.GetCustomMoveAndLookKeyAssignInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigMoveAndLookKeyAssignInfoReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FConfigMoveAndLookKeyAssignInfo UConfigurationUIObject::GetCustomMoveAndLookKeyAssignInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetCustomMoveAndLookKeyAssignInfo");

	Params::ConfigurationUIObject_GetCustomMoveAndLookKeyAssignInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetDefaultActionKeyAssignInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutGamePad                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Main                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Sub                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UConfigurationUIObject::GetDefaultActionKeyAssignInfo(const struct FGameplayTag& InTag, TArray<struct FKey>* OutGamePad, TArray<struct FKey>* OutKeyboardAndMouse_Main, TArray<struct FKey>* OutKeyboardAndMouse_Sub) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetDefaultActionKeyAssignInfo");

	Params::ConfigurationUIObject_GetDefaultActionKeyAssignInfo Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGamePad != nullptr)
		*OutGamePad = std::move(Parms.OutGamePad);

	if (OutKeyboardAndMouse_Main != nullptr)
		*OutKeyboardAndMouse_Main = std::move(Parms.OutKeyboardAndMouse_Main);

	if (OutKeyboardAndMouse_Sub != nullptr)
		*OutKeyboardAndMouse_Sub = std::move(Parms.OutKeyboardAndMouse_Sub);
}


// Function Extensions.ConfigurationUIObject.GetDefaultMoveAndLookKeyAssignInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigMoveAndLookKeyAssignInfoReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FConfigMoveAndLookKeyAssignInfo UConfigurationUIObject::GetDefaultMoveAndLookKeyAssignInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetDefaultMoveAndLookKeyAssignInfo");

	Params::ConfigurationUIObject_GetDefaultMoveAndLookKeyAssignInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetSaveKeyAssign
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutGamePad                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Main                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FKey>*                    OutKeyboardAndMouse_Sub                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConfigurationUIObject::GetSaveKeyAssign(const struct FGameplayTag& InTag, TArray<struct FKey>* OutGamePad, TArray<struct FKey>* OutKeyboardAndMouse_Main, TArray<struct FKey>* OutKeyboardAndMouse_Sub) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetSaveKeyAssign");

	Params::ConfigurationUIObject_GetSaveKeyAssign Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGamePad != nullptr)
		*OutGamePad = std::move(Parms.OutGamePad);

	if (OutKeyboardAndMouse_Main != nullptr)
		*OutKeyboardAndMouse_Main = std::move(Parms.OutKeyboardAndMouse_Main);

	if (OutKeyboardAndMouse_Sub != nullptr)
		*OutKeyboardAndMouse_Sub = std::move(Parms.OutKeyboardAndMouse_Sub);

	return Parms.ReturnValue;
}


// Function Extensions.ConfigurationUIObject.GetSaveMoveAndLookKeyAssignInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FConfigMoveAndLookKeyAssignInfoReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FConfigMoveAndLookKeyAssignInfo UConfigurationUIObject::GetSaveMoveAndLookKeyAssignInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurationUIObject", "GetSaveMoveAndLookKeyAssignInfo");

	Params::ConfigurationUIObject_GetSaveMoveAndLookKeyAssignInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CustomizeFacePostProcessAnimInstance.OnMouthCoverChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsCovered                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizeFacePostProcessAnimInstance::OnMouthCoverChanged(bool IsCovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizeFacePostProcessAnimInstance", "OnMouthCoverChanged");

	Params::CustomizeFacePostProcessAnimInstance_OnMouthCoverChanged Parms{};

	Parms.IsCovered = IsCovered;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.CustomizeFacePostProcessAnimInstance.GetFacialParameter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimFacialParameter       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAnimFacialParameter UCustomizeFacePostProcessAnimInstance::GetFacialParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizeFacePostProcessAnimInstance", "GetFacialParameter");

	Params::CustomizeFacePostProcessAnimInstance_GetFacialParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GCN_StatusEffect_Looping.PostAudioEvents_Application
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGCN_StatusEffect_Looping::PostAudioEvents_Application(class AActor* InTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GCN_StatusEffect_Looping", "PostAudioEvents_Application");

	Params::GCN_StatusEffect_Looping_PostAudioEvents_Application Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GCN_StatusEffect_Looping.PostAudioEvents_Recurring
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGCN_StatusEffect_Looping::PostAudioEvents_Recurring(class AActor* InTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GCN_StatusEffect_Looping", "PostAudioEvents_Recurring");

	Params::GCN_StatusEffect_Looping_PostAudioEvents_Recurring Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GCN_StatusEffect_Looping.PostAudioEvents_Removal
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGCN_StatusEffect_Looping::PostAudioEvents_Removal(class AActor* InTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GCN_StatusEffect_Looping", "PostAudioEvents_Removal");

	Params::GCN_StatusEffect_Looping_PostAudioEvents_Removal Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DamageGimmickSendInterface.GetDamageGimmickID
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName IDamageGimmickSendInterface::GetDamageGimmickID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DamageGimmickSendInterface", "GetDamageGimmickID");

	Params::DamageGimmickSendInterface_GetDamageGimmickID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.MakeVolatileFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESmallScenarioVolatileFlagBit           Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASmallScenarioBase::MakeVolatileFlag(ESmallScenarioVolatileFlagBit Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "MakeVolatileFlag");

	Params::SmallScenarioBase_MakeVolatileFlag Parms{};

	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.OpenBloodCodeConfirmDialog
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FArticleBulkInfo&          ArticleBulkInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OpenBloodCodeConfirmDialog(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FArticleBulkInfo& ArticleBulkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "OpenBloodCodeConfirmDialog");

	Params::SmallScenarioBase_OpenBloodCodeConfirmDialog Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ArticleBulkInfo = std::move(ArticleBulkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESmallScenarioOpenMenuType              MenuType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShopName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              BuddyTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArticleSyntheticType                   ArticleSyntheticType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OpenMenu(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ESmallScenarioOpenMenuType MenuType, class FName ShopName, const struct FGameplayTag& BuddyTag, EArticleSyntheticType ArticleSyntheticType, const struct FGameplayTag& CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "OpenMenu");

	Params::SmallScenarioBase_OpenMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MenuType = MenuType;
	Parms.ShopName = ShopName;
	Parms.BuddyTag = std::move(BuddyTag);
	Parms.ArticleSyntheticType = ArticleSyntheticType;
	Parms.CharacterType = std::move(CharacterType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OpenSystemDialogue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESystemDialogType                       SystemDialogType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDialogInfo&               DialogInfo                                             (Parm, NativeAccessSpecifierPublic)
// ESmallScenarioSystemDialogueResult*     Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OpenSystemDialogue(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ESystemDialogType SystemDialogType, const struct FDialogInfo& DialogInfo, ESmallScenarioSystemDialogueResult* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "OpenSystemDialogue");

	Params::SmallScenarioBase_OpenSystemDialogue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SystemDialogType = SystemDialogType;
	Parms.DialogInfo = std::move(DialogInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function Extensions.SmallScenarioBase.PlayAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimationName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WaitPlayEnd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::PlayAnimation(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FGameplayTag& CharacterType, class FName AnimationName, bool WaitPlayEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "PlayAnimation");

	Params::SmallScenarioBase_PlayAnimation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.CharacterType = std::move(CharacterType);
	Parms.AnimationName = AnimationName;
	Parms.WaitPlayEnd = WaitPlayEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.PlayInternalSmallScenario
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class ASmallScenarioBase>   Scenario                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESmallScenarioResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::PlayInternalSmallScenario(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class ASmallScenarioBase> Scenario, ESmallScenarioResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "PlayInternalSmallScenario");

	Params::SmallScenarioBase_PlayInternalSmallScenario Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Scenario = Scenario;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Extensions.SmallScenarioBase.SetSpeakerActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetSpeakerActor(class UObject* WorldContextObject, const struct FGameplayTag& CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "SetSpeakerActor");

	Params::SmallScenarioBase_SetSpeakerActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterType = std::move(CharacterType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.ShopBegin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::ShopBegin(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "ShopBegin");

	Params::SmallScenarioBase_ShopBegin Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.ShopEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::ShopEnd(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "ShopEnd");

	Params::SmallScenarioBase_ShopEnd Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.ShowChoicesDialogue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class FText>&              Dialogues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESmallScenarioResult*                   Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SelectIndex                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InitialSelectIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESelectionDialogDisplayType             DisplayType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::ShowChoicesDialogue(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<class FText>& Dialogues, ESmallScenarioResult* Branches, int32* SelectIndex, int32 InitialSelectIndex, ESelectionDialogDisplayType DisplayType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "ShowChoicesDialogue");

	Params::SmallScenarioBase_ShowChoicesDialogue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Dialogues = std::move(Dialogues);
	Parms.InitialSelectIndex = InitialSelectIndex;
	Parms.DisplayType = DisplayType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (SelectIndex != nullptr)
		*SelectIndex = Parms.SelectIndex;
}


// Function Extensions.SmallScenarioBase.ShowDialogue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const class FText&                      Speaker                                                (Parm, NativeAccessSpecifierPublic)
// const class FText&                      Dialogue                                               (Parm, NativeAccessSpecifierPublic)
// class FName                             VoiceName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVoiceEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESmallScenarioDialogueEndType           DialogueEndType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequenceBase> FacialAnimation                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSkipDelay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsDisplayOnScreenMask                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::ShowDialogue(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FText& Speaker, const class FText& Dialogue, class FName VoiceName, const struct FGameplayTag& CharacterType, bool IsVoiceEffect, float DelayTime, ESmallScenarioDialogueEndType DialogueEndType, TSoftObjectPtr<class UAnimSequenceBase> FacialAnimation, bool IsSkipDelay, bool IsDisplayOnScreenMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "ShowDialogue");

	Params::SmallScenarioBase_ShowDialogue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Speaker = std::move(Speaker);
	Parms.Dialogue = std::move(Dialogue);
	Parms.VoiceName = VoiceName;
	Parms.CharacterType = std::move(CharacterType);
	Parms.IsVoiceEffect = IsVoiceEffect;
	Parms.DelayTime = DelayTime;
	Parms.DialogueEndType = DialogueEndType;
	Parms.FacialAnimation = FacialAnimation;
	Parms.IsSkipDelay = IsSkipDelay;
	Parms.IsDisplayOnScreenMask = IsDisplayOnScreenMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.ShowDialogueFromDialogueData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FSmallScenarioDialogData&  DialogData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   AddShowDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::ShowDialogueFromDialogueData(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FSmallScenarioDialogData& DialogData, float AddShowDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "ShowDialogueFromDialogueData");

	Params::SmallScenarioBase_ShowDialogueFromDialogueData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.DialogData = std::move(DialogData);
	Parms.AddShowDelay = AddShowDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.TurnToFace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CharacterType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTargetPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              TargetCharacterType                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WaitTurnEnd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::TurnToFace(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FGameplayTag& CharacterType, bool IsTargetPlayer, const struct FGameplayTag& TargetCharacterType, float PlayRate, bool WaitTurnEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmallScenarioBase", "TurnToFace");

	Params::SmallScenarioBase_TurnToFace Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.CharacterType = std::move(CharacterType);
	Parms.IsTargetPlayer = IsTargetPlayer;
	Parms.TargetCharacterType = std::move(TargetCharacterType);
	Parms.PlayRate = PlayRate;
	Parms.WaitTurnEnd = WaitTurnEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.AddVolatileFlags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::AddVolatileFlags(int32 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "AddVolatileFlags");

	Params::SmallScenarioBase_AddVolatileFlags Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.GetBaseNoShowDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASmallScenarioBase::GetBaseNoShowDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetBaseNoShowDelay");

	Params::SmallScenarioBase_GetBaseNoShowDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetBaseShowDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASmallScenarioBase::GetBaseShowDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetBaseShowDelay");

	Params::SmallScenarioBase_GetBaseShowDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetDialogueDataFromDataTable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSmallScenarioDialogData*        OutRow                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::GetDialogueDataFromDataTable(class UDataTable* DataTable, int32 Index_0, struct FSmallScenarioDialogData* OutRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetDialogueDataFromDataTable");

	Params::SmallScenarioBase_GetDialogueDataFromDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRow != nullptr)
		*OutRow = std::move(Parms.OutRow);

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetDialoguesFromDataTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ASmallScenarioBase::GetDialoguesFromDataTable(class UDataTable* DataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetDialoguesFromDataTable");

	Params::SmallScenarioBase_GetDialoguesFromDataTable Parms{};

	Parms.DataTable = DataTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetNoShowDelayFromDialogueData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSmallScenarioDialogData&  Data                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASmallScenarioBase::GetNoShowDelayFromDialogueData(const struct FSmallScenarioDialogData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetNoShowDelayFromDialogueData");

	Params::SmallScenarioBase_GetNoShowDelayFromDialogueData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetSelectChoicesIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASmallScenarioBase::GetSelectChoicesIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetSelectChoicesIndex");

	Params::SmallScenarioBase_GetSelectChoicesIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsAborted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsAborted");

	Params::SmallScenarioBase_IsAborted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsInternalScenarioCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsInternalScenarioCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsInternalScenarioCompleted");

	Params::SmallScenarioBase_IsInternalScenarioCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsUseNormalAbortRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsUseNormalAbortRule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsUseNormalAbortRule");

	Params::SmallScenarioBase_IsUseNormalAbortRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.JumpToSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SequenceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::JumpToSequence(class FName SequenceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "JumpToSequence");

	Params::SmallScenarioBase_JumpToSequence Parms{};

	Parms.SequenceName = SequenceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnAbortChoices
// (Final, Native, Protected)

void ASmallScenarioBase::OnAbortChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnAbortChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnCloseBloodCodeConfirmDialog
// (Final, Native, Protected)

void ASmallScenarioBase::OnCloseBloodCodeConfirmDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnCloseBloodCodeConfirmDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnDecideSystemDialogue
// (Final, Native, Protected)
// Parameters:
// uint8                                   DecideNumber                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OnDecideSystemDialogue(uint8 DecideNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnDecideSystemDialogue");

	Params::SmallScenarioBase_OnDecideSystemDialogue Parms{};

	Parms.DecideNumber = DecideNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnFinishAnimation
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OnFinishAnimation(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnFinishAnimation");

	Params::SmallScenarioBase_OnFinishAnimation Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnFinishFacialAnimation
// (Final, Native, Protected)

void ASmallScenarioBase::OnFinishFacialAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnFinishFacialAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnFinishLoadedFacialAnimation
// (Final, Native, Protected)

void ASmallScenarioBase::OnFinishLoadedFacialAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnFinishLoadedFacialAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnFinishTurnToFace
// (Final, Native, Protected)

void ASmallScenarioBase::OnFinishTurnToFace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnFinishTurnToFace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnMenuClose
// (Final, Native, Protected)

void ASmallScenarioBase::OnMenuClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnMenuClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnMenuUsedFeature
// (Final, Native, Protected)
// Parameters:
// const struct FScenarioNPCEventInfo&     InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OnMenuUsedFeature(const struct FScenarioNPCEventInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnMenuUsedFeature");

	Params::SmallScenarioBase_OnMenuUsedFeature Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnSelectChoices
// (Final, Native, Protected)
// Parameters:
// const int32                             SelectIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OnSelectChoices(const int32 SelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnSelectChoices");

	Params::SmallScenarioBase_OnSelectChoices Parms{};

	Parms.SelectIndex = SelectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnSkipDelayFinished
// (Final, Native, Protected)

void ASmallScenarioBase::OnSkipDelayFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnSkipDelayFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnSkipDialogue
// (Final, Native, Protected)

void ASmallScenarioBase::OnSkipDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnSkipDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnStartSmallScenario
// (Final, Native, Protected)

void ASmallScenarioBase::OnStartSmallScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnStartSmallScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.OnVoicePlayEnd
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAppAudioVoicePlayerDelegateInfo&InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASmallScenarioBase::OnVoicePlayEnd(const struct FAppAudioVoicePlayerDelegateInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "OnVoicePlayEnd");

	Params::SmallScenarioBase_OnVoicePlayEnd Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.RemoveVolatileFlags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::RemoveVolatileFlags(int32 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "RemoveVolatileFlags");

	Params::SmallScenarioBase_RemoveVolatileFlags Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SelectSmallScenario
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESmallScenarioSelectRuleType            SelectRule                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ASmallScenarioBase>*  ScenarioClass                                          (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoChoises                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SelectSmallScenario(class UDataTable* DataTable, ESmallScenarioSelectRuleType SelectRule, TSubclassOf<class ASmallScenarioBase>* ScenarioClass, bool* NoChoises)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SelectSmallScenario");

	Params::SmallScenarioBase_SelectSmallScenario Parms{};

	Parms.DataTable = DataTable;
	Parms.SelectRule = SelectRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ScenarioClass != nullptr)
		*ScenarioClass = Parms.ScenarioClass;

	if (NoChoises != nullptr)
		*NoChoises = Parms.NoChoises;
}


// Function Extensions.SmallScenarioBase.SelectSmallScenarioDataTable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable**                      ScenarioDataTable                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStoryFlagLabel*                 OccurrenceFlag                                         (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SelectSmallScenarioDataTable(class UDataTable* DataTable, class UDataTable** ScenarioDataTable, struct FStoryFlagLabel* OccurrenceFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SelectSmallScenarioDataTable");

	Params::SmallScenarioBase_SelectSmallScenarioDataTable Parms{};

	Parms.DataTable = DataTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ScenarioDataTable != nullptr)
		*ScenarioDataTable = Parms.ScenarioDataTable;

	if (OccurrenceFlag != nullptr)
		*OccurrenceFlag = std::move(Parms.OccurrenceFlag);
}


// Function Extensions.SmallScenarioBase.SetAbortOnce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESmallScenarioAbortCause                InAbortCause                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetAbortOnce(ESmallScenarioAbortCause InAbortCause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetAbortOnce");

	Params::SmallScenarioBase_SetAbortOnce Parms{};

	Parms.InAbortCause = InAbortCause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SetCurrentBuddyType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              BuddyType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowMeesage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WithScreenMask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetCurrentBuddyType(const struct FGameplayTag& BuddyType, bool ShowMeesage, bool WithScreenMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetCurrentBuddyType");

	Params::SmallScenarioBase_SetCurrentBuddyType Parms{};

	Parms.BuddyType = std::move(BuddyType);
	Parms.ShowMeesage = ShowMeesage;
	Parms.WithScreenMask = WithScreenMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SetInTermSequence
// (Final, Native, Public, BlueprintCallable)

void ASmallScenarioBase::SetInTermSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetInTermSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SetScenarioResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESmallScenarioResult                    InScenarioResult                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetScenarioResult(ESmallScenarioResult InScenarioResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetScenarioResult");

	Params::SmallScenarioBase_SetScenarioResult Parms{};

	Parms.InScenarioResult = InScenarioResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SetUseNormalAbortRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetUseNormalAbortRule(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetUseNormalAbortRule");

	Params::SmallScenarioBase_SetUseNormalAbortRule Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.SetVolatileFlags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmallScenarioBase::SetVolatileFlags(int32 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "SetVolatileFlags");

	Params::SmallScenarioBase_SetVolatileFlags Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioBase.GetAbortCause
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESmallScenarioAbortCause                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESmallScenarioAbortCause ASmallScenarioBase::GetAbortCause() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetAbortCause");

	Params::SmallScenarioBase_GetAbortCause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetCurrentBuddyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ASmallScenarioBase::GetCurrentBuddyType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetCurrentBuddyType");

	Params::SmallScenarioBase_GetCurrentBuddyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetScenarioResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESmallScenarioResult                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESmallScenarioResult ASmallScenarioBase::GetScenarioResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetScenarioResult");

	Params::SmallScenarioBase_GetScenarioResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.GetVolatileFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASmallScenarioBase::GetVolatileFlags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "GetVolatileFlags");

	Params::SmallScenarioBase_GetVolatileFlags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.HasBloodCode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FArticleBulkInfo&          ArticleBulkInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::HasBloodCode(const struct FArticleBulkInfo& ArticleBulkInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "HasBloodCode");

	Params::SmallScenarioBase_HasBloodCode Parms{};

	Parms.ArticleBulkInfo = std::move(ArticleBulkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsCurrentBuddyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              BuddyType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsCurrentBuddyType(const struct FGameplayTag& BuddyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsCurrentBuddyType");

	Params::SmallScenarioBase_IsCurrentBuddyType Parms{};

	Parms.BuddyType = std::move(BuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsSmallScenarioSelectable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DataTableMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsSmallScenarioSelectable(class UDataTable* DataTable, bool DataTableMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsSmallScenarioSelectable");

	Params::SmallScenarioBase_IsSmallScenarioSelectable Parms{};

	Parms.DataTable = DataTable;
	Parms.DataTableMode = DataTableMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SmallScenarioBase.IsVolatileFlagsSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASmallScenarioBase::IsVolatileFlagsSet(int32 Flags_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioBase", "IsVolatileFlagsSet");

	Params::SmallScenarioBase_IsVolatileFlagsSet Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SkeletalMeshFunctionLibrary.DrawDebugSkeletalMeshCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class USkeletalMeshComponent*     SkeletalMesh                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreDisabledCollision                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshFunctionLibrary::DrawDebugSkeletalMeshCollision(const class USkeletalMeshComponent* SkeletalMesh, bool IgnoreDisabledCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkeletalMeshFunctionLibrary", "DrawDebugSkeletalMeshCollision");

	Params::SkeletalMeshFunctionLibrary_DrawDebugSkeletalMeshCollision Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.IgnoreDisabledCollision = IgnoreDisabledCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SkeletalMeshFunctionLibrary.GetFocusedAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USkeletalMeshComponent*     SkeletalMesh                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              EyeSocketNames                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   ViewLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  ViewRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshFunctionLibrary::GetFocusedAtLocation(const class USkeletalMeshComponent* SkeletalMesh, const TArray<class FName>& EyeSocketNames, const struct FVector& ViewLocation, const struct FRotator& ViewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkeletalMeshFunctionLibrary", "GetFocusedAtLocation");

	Params::SkeletalMeshFunctionLibrary_GetFocusedAtLocation Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.EyeSocketNames = std::move(EyeSocketNames);
	Parms.ViewLocation = std::move(ViewLocation);
	Parms.ViewRotation = std::move(ViewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DebugDamageTester.ApplyDamageToEnemyFromBuddy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AttackID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABodilessEnemy*                   DestEnemy                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugDamageTester::ApplyDamageToEnemyFromBuddy(class FName AttackID, class ABodilessEnemy* DestEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDamageTester", "ApplyDamageToEnemyFromBuddy");

	Params::DebugDamageTester_ApplyDamageToEnemyFromBuddy Parms{};

	Parms.AttackID = AttackID;
	Parms.DestEnemy = DestEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DebugDamageTester.ApplyDamageToPlayerFromEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABodilessEnemy*                   SrcEnemy                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttackID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugDamageTester::ApplyDamageToPlayerFromEnemy(class ABodilessEnemy* SrcEnemy, class FName AttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugDamageTester", "ApplyDamageToPlayerFromEnemy");

	Params::DebugDamageTester_ApplyDamageToPlayerFromEnemy Parms{};

	Parms.SrcEnemy = SrcEnemy;
	Parms.AttackID = AttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DebugFieldActionInteraface.RunFieldAction
// (Native, Event, Public, BlueprintEvent)

void IDebugFieldActionInteraface::RunFieldAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DebugFieldActionInteraface", "RunFieldAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DebugFieldActionInteraface.GetFieldActionCategory
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IDebugFieldActionInteraface::GetFieldActionCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DebugFieldActionInteraface", "GetFieldActionCategory");

	Params::DebugFieldActionInteraface_GetFieldActionCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DebugFieldActionInteraface.GetFieldActionName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IDebugFieldActionInteraface::GetFieldActionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DebugFieldActionInteraface", "GetFieldActionName");

	Params::DebugFieldActionInteraface_GetFieldActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DecalManager.SpawnDecal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDecalSpawnParameters&     InParameters                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDecalManager::SpawnDecal(const struct FDecalSpawnParameters& InParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalManager", "SpawnDecal");

	Params::DecalManager_SpawnDecal Parms{};

	Parms.InParameters = std::move(InParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.JukeBoxUIObject.GetJukeBoxInfoArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FUIJukeBoxInfo>*          OutJukeBoxInfoArray                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJukeBoxUIObject::GetJukeBoxInfoArray(TArray<struct FUIJukeBoxInfo>* OutJukeBoxInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JukeBoxUIObject", "GetJukeBoxInfoArray");

	Params::JukeBoxUIObject_GetJukeBoxInfoArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJukeBoxInfoArray != nullptr)
		*OutJukeBoxInfoArray = std::move(Parms.OutJukeBoxInfoArray);
}


// Function Extensions.JukeBoxUIObject.GetJukeBoxPlayIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJukeBoxUIObject::GetJukeBoxPlayIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JukeBoxUIObject", "GetJukeBoxPlayIndex");

	Params::JukeBoxUIObject_GetJukeBoxPlayIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.JukeBoxUIObject.PlayJukeBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPlayIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJukeBoxUIObject::PlayJukeBox(int32 InPlayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JukeBoxUIObject", "PlayJukeBox");

	Params::JukeBoxUIObject_PlayJukeBox Parms{};

	Parms.InPlayIndex = InPlayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.JukeBoxUIObject.StopJukeBox
// (Final, Native, Public, BlueprintCallable)

void UJukeBoxUIObject::StopJukeBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JukeBoxUIObject", "StopJukeBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.CloseDescriptionWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::CloseDescriptionWindow(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DescriptionUIObject", "CloseDescriptionWindow");

	Params::DescriptionUIObject_CloseDescriptionWindow Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.OpenDescriptionWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InDescriptionID                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::OpenDescriptionWindow(const class UObject* InWorldContext, const struct FGameplayTag& InDescriptionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DescriptionUIObject", "OpenDescriptionWindow");

	Params::DescriptionUIObject_OpenDescriptionWindow Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InDescriptionID = std::move(InDescriptionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.OpenDescriptionWindowWithDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InDescriptionID                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InOnCloseDelegate                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDescriptionUIObject::OpenDescriptionWindowWithDelegate(const class UObject* InWorldContext, const struct FGameplayTag& InDescriptionID, TDelegate<void()> InOnCloseDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DescriptionUIObject", "OpenDescriptionWindowWithDelegate");

	Params::DescriptionUIObject_OpenDescriptionWindowWithDelegate Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InDescriptionID = std::move(InDescriptionID);
	Parms.InOnCloseDelegate = InOnCloseDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.CallDelegateQueue
// (Final, Native, Protected, BlueprintCallable)

void UDescriptionUIObject::CallDelegateQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "CallDelegateQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.GetDescriptionNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InDescriptionID                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNewFlag                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDescriptionUIObject::GetDescriptionNewFlag(const class FName& InDescriptionID, bool* OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetDescriptionNewFlag");

	Params::DescriptionUIObject_GetDescriptionNewFlag Parms{};

	Parms.InDescriptionID = InDescriptionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewFlag != nullptr)
		*OutNewFlag = Parms.OutNewFlag;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetNewAddItemArray
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTutorialNewAddItemData>* OutNewAddItemArray                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDescriptionUIObject::GetNewAddItemArray(TArray<struct FTutorialNewAddItemData>* OutNewAddItemArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetNewAddItemArray");

	Params::DescriptionUIObject_GetNewAddItemArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewAddItemArray != nullptr)
		*OutNewAddItemArray = std::move(Parms.OutNewAddItemArray);
}


// Function Extensions.DescriptionUIObject.IsNewAddItemArrayContains
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTutorialNewAddItemData&   InName                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDescriptionUIObject::IsNewAddItemArrayContains(const struct FTutorialNewAddItemData& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "IsNewAddItemArrayContains");

	Params::DescriptionUIObject_IsNewAddItemArrayContains Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.OnCutScene
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::OnCutScene(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "OnCutScene");

	Params::DescriptionUIObject_OnCutScene Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.OnDisableInput
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::OnDisableInput(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "OnDisableInput");

	Params::DescriptionUIObject_OnDisableInput Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.OpenDescriptionWindowDelayed
// (Final, Native, Protected)

void UDescriptionUIObject::OpenDescriptionWindowDelayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "OpenDescriptionWindowDelayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.SetCurrentPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::SetCurrentPage(int32 InPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "SetCurrentPage");

	Params::DescriptionUIObject_SetCurrentPage Parms{};

	Parms.InPage = InPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.SetDescriptionInfoTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       InDescriptionData                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDescriptionUIObject::SetDescriptionInfoTable(class UDataTable* InDescriptionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "SetDescriptionInfoTable");

	Params::DescriptionUIObject_SetDescriptionInfoTable Parms{};

	Parms.InDescriptionData = InDescriptionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.SetDescriptionNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InDescriptionID                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutNewFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDescriptionUIObject::SetDescriptionNewFlag(const class FName& InDescriptionID, bool OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "SetDescriptionNewFlag");

	Params::DescriptionUIObject_SetDescriptionNewFlag Parms{};

	Parms.InDescriptionID = InDescriptionID;
	Parms.OutNewFlag = OutNewFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.ShouldPauseOnDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDescriptionUIObject::ShouldPauseOnDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "ShouldPauseOnDescription");

	Params::DescriptionUIObject_ShouldPauseOnDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.WriteDescriptionSaveData
// (Final, Native, Public, BlueprintCallable)

void UDescriptionUIObject::WriteDescriptionSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "WriteDescriptionSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DescriptionUIObject.GetCurrentPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDescriptionUIObject::GetCurrentPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetCurrentPage");

	Params::DescriptionUIObject_GetCurrentPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDescriptionUIObject::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetDescription");

	Params::DescriptionUIObject_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetDescriptionCategoryTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UDescriptionUIObject::GetDescriptionCategoryTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetDescriptionCategoryTable");

	Params::DescriptionUIObject_GetDescriptionCategoryTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetDescriptionImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UDescriptionUIObject::GetDescriptionImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetDescriptionImage");

	Params::DescriptionUIObject_GetDescriptionImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetDescriptionInfoTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UDescriptionUIObject::GetDescriptionInfoTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetDescriptionInfoTable");

	Params::DescriptionUIObject_GetDescriptionInfoTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetPageCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDescriptionUIObject::GetPageCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetPageCount");

	Params::DescriptionUIObject_GetPageCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DescriptionUIObject.GetTitleName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDescriptionUIObject::GetTitleName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescriptionUIObject", "GetTitleName");

	Params::DescriptionUIObject_GetTitleName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.KeepOutWall.OnEndForceMove_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutWall::OnEndForceMove_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutWall", "OnEndForceMove_BP");

	Params::KeepOutWall_OnEndForceMove_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutWall.OnForceMoving_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutWall::OnForceMoving_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutWall", "OnForceMoving_BP");

	Params::KeepOutWall_OnForceMoving_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KeepOutWall.OnStartForceMove_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActionHumanCharacter*            InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeepOutWall::OnStartForceMove_BP(class AActionHumanCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeepOutWall", "OnStartForceMove_BP");

	Params::KeepOutWall_OnStartForceMove_BP Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.DramaEventAction_PlayVoice.OnVoicePlayEnd
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FAppAudioVoicePlayerDelegateInfo&Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDramaEventAction_PlayVoice::OnVoicePlayEnd(const struct FAppAudioVoicePlayerDelegateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DramaEventAction_PlayVoice", "OnVoicePlayEnd");

	Params::DramaEventAction_PlayVoice_OnVoicePlayEnd Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Enemy.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UQSTask_Enemy::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Enemy", "OnBeginOverlap");

	Params::QSTask_Enemy_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Enemy.OnDespawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_Enemy::OnDespawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Enemy", "OnDespawn");

	Params::QSTask_Enemy_OnDespawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Enemy.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_Enemy::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Enemy", "OnEndOverlap");

	Params::QSTask_Enemy_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Enemy.OnSpawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_Enemy::OnSpawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Enemy", "OnSpawn");

	Params::QSTask_Enemy_OnSpawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Enemy.OnWaitEnemySetupFinish
// (Final, Native, Private)

void UQSTask_Enemy::OnWaitEnemySetupFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Enemy", "OnWaitEnemySetupFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DrawScarComponent.BloodFeed
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InHitLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InAttacker                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDrawScarComponent::BloodFeed(const struct FVector& InHitLocation, class USkeletalMeshComponent* InAttacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "BloodFeed");

	Params::DrawScarComponent_BloodFeed Parms{};

	Parms.InHitLocation = std::move(InHitLocation);
	Parms.InAttacker = InAttacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DrawScarComponent.GetAndClearScarInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 OutLocationArray                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDrawScarComponent::GetAndClearScarInfo(TArray<struct FVector>* OutLocationArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "GetAndClearScarInfo");

	Params::DrawScarComponent_GetAndClearScarInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationArray != nullptr)
		*OutLocationArray = std::move(Parms.OutLocationArray);
}


// Function Extensions.DrawScarComponent.GetScarInfoCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDrawScarComponent::GetScarInfoCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "GetScarInfoCount");

	Params::DrawScarComponent_GetScarInfoCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DrawScarComponent.Hit
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InNormal                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InScarSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawScarType                           InScarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBleedingDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBleedingAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxBleedingAmount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDrawScarComponent::Hit(const struct FVector& InLocation, const struct FVector& InNormal, const struct FVector& InDirection, const class FName& InBoneName, float InScarSize, EDrawScarType InScarType, float InBleedingDamage, float InBleedingAmount, float InMaxBleedingAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "Hit");

	Params::DrawScarComponent_Hit Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InNormal = std::move(InNormal);
	Parms.InDirection = std::move(InDirection);
	Parms.InBoneName = InBoneName;
	Parms.InScarSize = InScarSize;
	Parms.InScarType = InScarType;
	Parms.InBleedingDamage = InBleedingDamage;
	Parms.InBleedingAmount = InBleedingAmount;
	Parms.InMaxBleedingAmount = InMaxBleedingAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DrawScarComponent.Initialize
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDrawScarElementParameter*        InDrawScarParameter                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDrawScarComponent::Initialize(class USkeletalMeshComponent* InSkeletalMesh, class UDrawScarElementParameter* InDrawScarParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "Initialize");

	Params::DrawScarComponent_Initialize Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InDrawScarParameter = InDrawScarParameter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DrawScarComponent.SetBloodFeedProcess
// (Event, Public, BlueprintEvent)

void UDrawScarComponent::SetBloodFeedProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "SetBloodFeedProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.DrawScarComponent.UpdateBleedingAmountReduction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InPreBleedingAmount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBleedingAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDrawScarComponent::UpdateBleedingAmountReduction(float InPreBleedingAmount, float InBleedingAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "UpdateBleedingAmountReduction");

	Params::DrawScarComponent_UpdateBleedingAmountReduction Parms{};

	Parms.InPreBleedingAmount = InPreBleedingAmount;
	Parms.InBleedingAmount = InBleedingAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DrawScarComponent.GetDrawScarParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDrawScarElementParameter*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDrawScarElementParameter* UDrawScarComponent::GetDrawScarParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "GetDrawScarParameter");

	Params::DrawScarComponent_GetDrawScarParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DrawScarComponent.GetTargetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UDrawScarComponent::GetTargetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "GetTargetMesh");

	Params::DrawScarComponent_GetTargetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DrawScarComponent.IsDrawScarDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDrawScarComponent::IsDrawScarDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DrawScarComponent", "IsDrawScarDebugInfo");

	Params::DrawScarComponent_IsDrawScarDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldLib.SetPropertyCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFieldLibResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFieldLibResult UFieldLib::SetPropertyCategory(class UObject* Object, class FName PropertyName, const class FString& CategoryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldLib", "SetPropertyCategory");

	Params::FieldLib_SetPropertyCategory Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.CategoryName = std::move(CategoryName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DropEmptyShell.OnHitCallback
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADropEmptyShell::OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropEmptyShell", "OnHitCallback");

	Params::DropEmptyShell_OnHitCallback Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DummyPlayerCharacter.EditorTick
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADummyPlayerCharacter::EditorTick(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DummyPlayerCharacter", "EditorTick");

	Params::DummyPlayerCharacter_EditorTick Parms{};

	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DummyPlayerCharacter.IsCharacterHidden
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADummyPlayerCharacter::IsCharacterHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DummyPlayerCharacter", "IsCharacterHidden");

	Params::DummyPlayerCharacter_IsCharacterHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DummyPlayerCharacter.SetCameraRotation
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADummyPlayerCharacter::SetCameraRotation(const struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DummyPlayerCharacter", "SetCameraRotation");

	Params::DummyPlayerCharacter_SetCameraRotation Parms{};

	Parms.InRotator = std::move(InRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DummyPlayerCharacter.SetCharacterHidden
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADummyPlayerCharacter::SetCharacterHidden(bool InHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DummyPlayerCharacter", "SetCharacterHidden");

	Params::DummyPlayerCharacter_SetCharacterHidden Parms{};

	Parms.InHidden = InHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DummyPlayerCharacter.SetCharacterRotation
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADummyPlayerCharacter::SetCharacterRotation(const struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DummyPlayerCharacter", "SetCharacterRotation");

	Params::DummyPlayerCharacter_SetCharacterRotation Parms{};

	Parms.InRotator = std::move(InRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DynamicPostProcessManager.AddDynamicPostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDynamicPostProcessPriority             InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVolumeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDynamicPostProcessHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDynamicPostProcessHandle UDynamicPostProcessManager::AddDynamicPostProcessMaterial(const class UObject* WorldContextObject, class UMaterialInterface* InMaterial, float InWeight, EDynamicPostProcessPriority InPriority, class FName InVolumeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "AddDynamicPostProcessMaterial");

	Params::DynamicPostProcessManager_AddDynamicPostProcessMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMaterial = InMaterial;
	Parms.InWeight = InWeight;
	Parms.InPriority = InPriority;
	Parms.InVolumeName = InVolumeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DynamicPostProcessManager.AddDynamicPostProcessSettings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPostProcessSettings&      InPPSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDynamicPostProcessPriority             InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVolumeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDynamicPostProcessHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDynamicPostProcessHandle UDynamicPostProcessManager::AddDynamicPostProcessSettings(const class UObject* WorldContextObject, const struct FPostProcessSettings& InPPSettings, float InWeight, EDynamicPostProcessPriority InPriority, class FName InVolumeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "AddDynamicPostProcessSettings");

	Params::DynamicPostProcessManager_AddDynamicPostProcessSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPPSettings = std::move(InPPSettings);
	Parms.InWeight = InWeight;
	Parms.InPriority = InPriority;
	Parms.InVolumeName = InVolumeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DynamicPostProcessManager.GetDynamicPostProcessVolume
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDynamicPostProcessHandle& InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class APostProcessVolume*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APostProcessVolume* UDynamicPostProcessManager::GetDynamicPostProcessVolume(const class UObject* WorldContextObject, const struct FDynamicPostProcessHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "GetDynamicPostProcessVolume");

	Params::DynamicPostProcessManager_GetDynamicPostProcessVolume Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.DynamicPostProcessManager.RemoveDynamicPostProcess
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDynamicPostProcessHandle& InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDynamicPostProcessManager::RemoveDynamicPostProcess(const class UObject* WorldContextObject, const struct FDynamicPostProcessHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "RemoveDynamicPostProcess");

	Params::DynamicPostProcessManager_RemoveDynamicPostProcess Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DynamicPostProcessManager.SetDynamicPostProcessMaterialScalarParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDynamicPostProcessHandle& InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicPostProcessManager::SetDynamicPostProcessMaterialScalarParameter(const class UObject* WorldContextObject, const struct FDynamicPostProcessHandle& InHandle, const class FName InName, const float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "SetDynamicPostProcessMaterialScalarParameter");

	Params::DynamicPostProcessManager_SetDynamicPostProcessMaterialScalarParameter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHandle = std::move(InHandle);
	Parms.InName = InName;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DynamicPostProcessManager.SetDynamicPostProcessMaterialVectorParameter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDynamicPostProcessHandle& InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  InValue                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicPostProcessManager::SetDynamicPostProcessMaterialVectorParameter(const class UObject* WorldContextObject, const struct FDynamicPostProcessHandle& InHandle, const class FName InName, const struct FVector4& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "SetDynamicPostProcessMaterialVectorParameter");

	Params::DynamicPostProcessManager_SetDynamicPostProcessMaterialVectorParameter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHandle = std::move(InHandle);
	Parms.InName = InName;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.DynamicPostProcessManager.SetDynamicPostProcessWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDynamicPostProcessHandle& InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InWeight                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicPostProcessManager::SetDynamicPostProcessWeight(const class UObject* WorldContextObject, const struct FDynamicPostProcessHandle& InHandle, const float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DynamicPostProcessManager", "SetDynamicPostProcessWeight");

	Params::DynamicPostProcessManager_SetDynamicPostProcessWeight Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHandle = std::move(InHandle);
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.AccumulateAttributeWidgetInterface.UpdateAccumulateStateValue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FAccumulateGaugeInfo&      InGaugeInfo                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InAttributeInfo                                        (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAccumulateAttributeWidgetInterface::UpdateAccumulateStateValue(const struct FAccumulateGaugeInfo& InGaugeInfo, const struct FAccumulateAttributeUIInfo& InAttributeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AccumulateAttributeWidgetInterface", "UpdateAccumulateStateValue");

	Params::AccumulateAttributeWidgetInterface_UpdateAccumulateStateValue Parms{};

	Parms.InGaugeInfo = std::move(InGaugeInfo);
	Parms.InAttributeInfo = std::move(InAttributeInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemProxy.Consume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InAmount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemProxy::Consume(const int32 InAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemProxy", "Consume");

	Params::ItemProxy_Consume Parms{};

	Parms.InAmount = InAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemProxy.GetArticleID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGuid                      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGuid AItemProxy::GetArticleID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemProxy", "GetArticleID");

	Params::ItemProxy_GetArticleID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.FirstOpen
// (Event, Public, BlueprintEvent)

void UItemPaletteMenu::FirstOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "FirstOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ItemPaletteMenu.GetItemNameBlockPiece
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UItemPaletteMenu::GetItemNameBlockPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemNameBlockPiece");

	Params::ItemPaletteMenu_GetItemNameBlockPiece Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemNameTextBlock
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTextBlock*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextBlock* UItemPaletteMenu::GetItemNameTextBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemNameTextBlock");

	Params::ItemPaletteMenu_GetItemNameTextBlock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_Center
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_Center()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_Center");

	Params::ItemPaletteMenu_GetItemPaletteSlot_Center Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_L1
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_L1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_L1");

	Params::ItemPaletteMenu_GetItemPaletteSlot_L1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_L2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_L2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_L2");

	Params::ItemPaletteMenu_GetItemPaletteSlot_L2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_L3
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_L3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_L3");

	Params::ItemPaletteMenu_GetItemPaletteSlot_L3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_L4
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_L4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_L4");

	Params::ItemPaletteMenu_GetItemPaletteSlot_L4 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_L5
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_L5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_L5");

	Params::ItemPaletteMenu_GetItemPaletteSlot_L5 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_R1
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_R1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_R1");

	Params::ItemPaletteMenu_GetItemPaletteSlot_R1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_R2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_R2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_R2");

	Params::ItemPaletteMenu_GetItemPaletteSlot_R2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_R3
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_R3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_R3");

	Params::ItemPaletteMenu_GetItemPaletteSlot_R3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_R4
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_R4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_R4");

	Params::ItemPaletteMenu_GetItemPaletteSlot_R4 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetItemPaletteSlot_R5
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteMenu::GetItemPaletteSlot_R5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetItemPaletteSlot_R5");

	Params::ItemPaletteMenu_GetItemPaletteSlot_R5 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetRotateLeftAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UItemPaletteMenu::GetRotateLeftAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetRotateLeftAnimation");

	Params::ItemPaletteMenu_GetRotateLeftAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.GetRotateRightAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UItemPaletteMenu::GetRotateRightAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "GetRotateRightAnimation");

	Params::ItemPaletteMenu_GetRotateRightAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.ItemPaletteEnd
// (Final, Native, Private, BlueprintCallable)

void UItemPaletteMenu::ItemPaletteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "ItemPaletteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenu.RequestItemPaletteEdit
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteMenu::RequestItemPaletteEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "RequestItemPaletteEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenu.RequestSwitchEmotionPalette
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteMenu::RequestSwitchEmotionPalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "RequestSwitchEmotionPalette");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenu.RequestUseCurrentItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteMenu::RequestUseCurrentItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "RequestUseCurrentItem");

	Params::ItemPaletteMenu_RequestUseCurrentItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.RotateSlotLeft
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInCanWrap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteMenu::RotateSlotLeft(bool bInCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "RotateSlotLeft");

	Params::ItemPaletteMenu_RotateSlotLeft Parms{};

	Parms.bInCanWrap = bInCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenu.RotateSlotRight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInCanWrap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteMenu::RotateSlotRight(bool bInCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenu", "RotateSlotRight");

	Params::ItemPaletteMenu_RotateSlotRight Parms{};

	Parms.bInCanWrap = bInCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EdenEventScriptScenario.DelayScenario
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptScenario::DelayScenario(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "DelayScenario");

	Params::EdenEventScriptScenario_DelayScenario Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptScenario.ExecuteWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UEdenEventScriptWork> WorkClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptScenario::ExecuteWork(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class UEdenEventScriptWork> WorkClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "ExecuteWork");

	Params::EdenEventScriptScenario_ExecuteWork Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.WorkClass = WorkClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptScenario.FinishScenario
// (Final, Native, Public, BlueprintCallable)

void UEdenEventScriptScenario::FinishScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "FinishScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptScenario.ReceivePostUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             DeltaSeconds                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptScenario::ReceivePostUpdate(const float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "ReceivePostUpdate");

	Params::EdenEventScriptScenario_ReceivePostUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EdenEventScriptScenario.ReceivePreUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             DeltaSeconds                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptScenario::ReceivePreUpdate(const float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "ReceivePreUpdate");

	Params::EdenEventScriptScenario_ReceivePreUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EdenEventScriptScenario.ReceiveRun
// (Event, Protected, BlueprintEvent)

void UEdenEventScriptScenario::ReceiveRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "ReceiveRun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EdenEventScriptScenario.ResetPlayerCharacterMovementRestrictType
// (Final, Native, Public, BlueprintCallable)

void UEdenEventScriptScenario::ResetPlayerCharacterMovementRestrictType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "ResetPlayerCharacterMovementRestrictType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptScenario.SetPlayerCharacterMovementRestrictType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerMessageMoveTypeRestrictType      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptScenario::SetPlayerCharacterMovementRestrictType(EPlayerMessageMoveTypeRestrictType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "SetPlayerCharacterMovementRestrictType");

	Params::EdenEventScriptScenario_SetPlayerCharacterMovementRestrictType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptScenario.IsFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEdenEventScriptScenario::IsFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptScenario", "IsFinished");

	Params::EdenEventScriptScenario_IsFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EdenEventScriptWork.CompleteWork
// (Final, Native, Public, BlueprintCallable)

void UEdenEventScriptWork::CompleteWork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "CompleteWork");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.DelayWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::DelayWork(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "DelayWork");

	Params::EdenEventScriptWork_DelayWork Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.PlaySoundWithSubtitles
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SoundLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Speaker                                                (Parm, NativeAccessSpecifierPublic)
// const class FText&                      Talk                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   ShowTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::PlaySoundWithSubtitles(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class UAkAudioEvent* SoundEvent, class AActor* SoundActor, class FName AttachPointName, const struct FVector& SoundLocation, const class FText& Speaker, const class FText& Talk, float ShowTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "PlaySoundWithSubtitles");

	Params::EdenEventScriptWork_PlaySoundWithSubtitles Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SoundEvent = SoundEvent;
	Parms.SoundActor = SoundActor;
	Parms.AttachPointName = AttachPointName;
	Parms.SoundLocation = std::move(SoundLocation);
	Parms.Speaker = std::move(Speaker);
	Parms.Talk = std::move(Talk);
	Parms.ShowTime = ShowTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.PostSoundEvent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    SoundEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::PostSoundEvent(class UAkAudioEvent* SoundEvent, class AActor* Actor, class FName AttachPointName, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "PostSoundEvent");

	Params::EdenEventScriptWork_PostSoundEvent Parms{};

	Parms.SoundEvent = SoundEvent;
	Parms.Actor = Actor;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.ReceiveExecute
// (Event, Protected, BlueprintEvent)

void UEdenEventScriptWork::ReceiveExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "ReceiveExecute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EdenEventScriptWork.ReceiveUpdate
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const float&                            DeltaSeconds                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::ReceiveUpdate(const float& DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "ReceiveUpdate");

	Params::EdenEventScriptWork_ReceiveUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EdenEventScriptWork.ResetPlayerCharacterMovementRestrictType
// (Final, Native, Public, BlueprintCallable)

void UEdenEventScriptWork::ResetPlayerCharacterMovementRestrictType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "ResetPlayerCharacterMovementRestrictType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.SetPlayerCharacterMovementRestrictType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerMessageMoveTypeRestrictType      RestrictType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::SetPlayerCharacterMovementRestrictType(EPlayerMessageMoveTypeRestrictType RestrictType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "SetPlayerCharacterMovementRestrictType");

	Params::EdenEventScriptWork_SetPlayerCharacterMovementRestrictType Parms{};

	Parms.RestrictType = RestrictType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.SetSubtitles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      Speaker                                                (Parm, NativeAccessSpecifierPublic)
// const class FText&                      Talk                                                   (Parm, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::SetSubtitles(const class FText& Speaker, const class FText& Talk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "SetSubtitles");

	Params::EdenEventScriptWork_SetSubtitles Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Talk = std::move(Talk);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.SetTravelSelectResult
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ResultIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::SetTravelSelectResult(int32 ResultIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "SetTravelSelectResult");

	Params::EdenEventScriptWork_SetTravelSelectResult Parms{};

	Parms.ResultIndex = ResultIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.ShowSubtitles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const class FText&                      Speaker                                                (Parm, NativeAccessSpecifierPublic)
// const class FText&                      Talk                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   ShowTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEdenEventScriptWork::ShowSubtitles(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FText& Speaker, const class FText& Talk, float ShowTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "ShowSubtitles");

	Params::EdenEventScriptWork_ShowSubtitles Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Speaker = std::move(Speaker);
	Parms.Talk = std::move(Talk);
	Parms.ShowTime = ShowTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenEventScriptWork.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEdenEventScriptWork::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenEventScriptWork", "IsCompleted");

	Params::EdenEventScriptWork_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.ArticleExchange
// (Final, Native, Public)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::ArticleExchange(const EArticleSyntheticType InType, const struct FUIArticleQueryInfo& InQuery, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "ArticleExchange");

	Params::ItemSyntheticComponent_ArticleExchange Parms{};

	Parms.InType = InType;
	Parms.InQuery = std::move(InQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.ArticleSynthetic
// (Final, Native, Public)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::ArticleSynthetic(const EArticleSyntheticType InType, const int32 InIndex, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "ArticleSynthetic");

	Params::ItemSyntheticComponent_ArticleSynthetic Parms{};

	Parms.InType = InType;
	Parms.InIndex = InIndex;
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.BoosterSynthetic
// (Final, Native, Public)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::BoosterSynthetic(const struct FUIBoosterQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "BoosterSynthetic");

	Params::ItemSyntheticComponent_BoosterSynthetic Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetAvailableArticleSyntheticRecipeNum
// (Final, Native, Public)
// Parameters:
// EArticleSyntheticType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetAvailableArticleSyntheticRecipeNum(EArticleSyntheticType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetAvailableArticleSyntheticRecipeNum");

	Params::ItemSyntheticComponent_GetAvailableArticleSyntheticRecipeNum Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetAvailableBoosterRecipeNum
// (Final, Native, Public)
// Parameters:
// const EUIBoosterCategory                InBoosterCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetAvailableBoosterRecipeNum(const EUIBoosterCategory InBoosterCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetAvailableBoosterRecipeNum");

	Params::ItemSyntheticComponent_GetAvailableBoosterRecipeNum Parms{};

	Parms.InBoosterCategory = InBoosterCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetAvailableExchangeNum
// (Final, Native, Public)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIMainCategory                   InArticleCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetAvailableExchangeNum(const EArticleSyntheticType InType, const EUIMainCategory InArticleCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetAvailableExchangeNum");

	Params::ItemSyntheticComponent_GetAvailableExchangeNum Parms{};

	Parms.InType = InType;
	Parms.InArticleCategory = InArticleCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetAvailableItemRecipeNum
// (Final, Native, Public)
// Parameters:
// const EUIExpendableItemCategory         InItemCategory                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetAvailableItemRecipeNum(const EUIExpendableItemCategory InItemCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetAvailableItemRecipeNum");

	Params::ItemSyntheticComponent_GetAvailableItemRecipeNum Parms{};

	Parms.InItemCategory = InItemCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetAvailableWeaponGadgetRecipeNum
// (Final, Native, Public)
// Parameters:
// const EUIWeaponGadgetCategory           InWeaponGadgetCategory                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetAvailableWeaponGadgetRecipeNum(const EUIWeaponGadgetCategory InWeaponGadgetCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetAvailableWeaponGadgetRecipeNum");

	Params::ItemSyntheticComponent_GetAvailableWeaponGadgetRecipeNum Parms{};

	Parms.InWeaponGadgetCategory = InWeaponGadgetCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetExchangeItemUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetExchangeItemUIInfo(const EArticleSyntheticType InType, const struct FUIArticleQueryInfo& InArticleQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExchangeItemUIInfo");

	Params::ItemSyntheticComponent_GetExchangeItemUIInfo Parms{};

	Parms.InType = InType;
	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetExchangeMenuTitle
// (Final, Native, Public)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemSyntheticComponent::GetExchangeMenuTitle(const EArticleSyntheticType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExchangeMenuTitle");

	Params::ItemSyntheticComponent_GetExchangeMenuTitle Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetExchangeUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemExchangeUIInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetExchangeUIInfo(const EArticleSyntheticType InType, const struct FUIArticleQueryInfo& InQuery, struct FItemExchangeUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExchangeUIInfo");

	Params::ItemSyntheticComponent_GetExchangeUIInfo Parms{};

	Parms.InType = InType;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetExchangeWeaponGadgetUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetExchangeWeaponGadgetUIInfo(const EArticleSyntheticType InType, const struct FUIArticleQueryInfo& InArticleQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExchangeWeaponGadgetUIInfo");

	Params::ItemSyntheticComponent_GetExchangeWeaponGadgetUIInfo Parms{};

	Parms.InType = InType;
	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetExchangeWeaponUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const EArticleSyntheticType             InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIArticleQueryInfo&       InArticleQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetExchangeWeaponUIInfo(const EArticleSyntheticType InType, const struct FUIArticleQueryInfo& InArticleQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExchangeWeaponUIInfo");

	Params::ItemSyntheticComponent_GetExchangeWeaponUIInfo Parms{};

	Parms.InType = InType;
	Parms.InArticleQuery = std::move(InArticleQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetExp
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticComponent::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetExp");

	Params::ItemSyntheticComponent_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticBoosterRecipeUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticBoosterRecipeUIInfo(const struct FUIBoosterQueryInfo& InBoosterQuery, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticBoosterRecipeUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticBoosterRecipeUIInfo Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticBoosterResultUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticBoosterResultUIInfo(const struct FUIBoosterQueryInfo& InQueryInfo, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticBoosterResultUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticBoosterResultUIInfo Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticItemRecipeUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticItemRecipeUIInfo(const struct FUIEquippableItemQueryInfo& InItemQuery, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticItemRecipeUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticItemRecipeUIInfo Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticItemResultUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticItemResultUIInfo(const struct FUIEquippableItemQueryInfo& InItemQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticItemResultUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticItemResultUIInfo Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticRecipeUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// EArticleSyntheticType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InAvailableRecipeIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticRecipeUIInfo(EArticleSyntheticType InType, const int32 InAvailableRecipeIndex, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticRecipeUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticRecipeUIInfo Parms{};

	Parms.InType = InType;
	Parms.InAvailableRecipeIndex = InAvailableRecipeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticWeaponGadgetRecipeUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InWeaponGadgetQuery                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticWeaponGadgetRecipeUIInfo(const struct FUIWeaponGadgetQueryInfo& InWeaponGadgetQuery, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticWeaponGadgetRecipeUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticWeaponGadgetRecipeUIInfo Parms{};

	Parms.InWeaponGadgetQuery = std::move(InWeaponGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticComponent.GetSyntheticWeaponGadgetResultUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InWeaponGadgetQuery                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticComponent::GetSyntheticWeaponGadgetResultUIInfo(const struct FUIWeaponGadgetQueryInfo& InWeaponGadgetQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "GetSyntheticWeaponGadgetResultUIInfo");

	Params::ItemSyntheticComponent_GetSyntheticWeaponGadgetResultUIInfo Parms{};

	Parms.InWeaponGadgetQuery = std::move(InWeaponGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticComponent.IsOwnedSyntheticBooster
// (Final, Native, Public)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::IsOwnedSyntheticBooster(const struct FUIBoosterQueryInfo& InQueryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "IsOwnedSyntheticBooster");

	Params::ItemSyntheticComponent_IsOwnedSyntheticBooster Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.ItemSynthetic
// (Final, Native, Public)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::ItemSynthetic(const struct FUIEquippableItemQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "ItemSynthetic");

	Params::ItemSyntheticComponent_ItemSynthetic Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticComponent.WeaponGadgetSynthetic
// (Final, Native, Public)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticComponent::WeaponGadgetSynthetic(const struct FUIWeaponGadgetQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticComponent", "WeaponGadgetSynthetic");

	Params::ItemSyntheticComponent_WeaponGadgetSynthetic Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EdenLevelSequenceTrigger.OnBeginOverlapped
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEdenLevelSequenceTrigger::OnBeginOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenLevelSequenceTrigger", "OnBeginOverlapped");

	Params::EdenLevelSequenceTrigger_OnBeginOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenLevelSequenceTrigger.OnEndOverlapped
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEdenLevelSequenceTrigger::OnEndOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenLevelSequenceTrigger", "OnEndOverlapped");

	Params::EdenLevelSequenceTrigger_OnEndOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenLevelSequenceTrigger.OnPlayerAutoMoved
// (Final, Native, Private)
// Parameters:
// const EPlayerAutoMoveEventType          EventType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEdenLevelSequenceTrigger::OnPlayerAutoMoved(const EPlayerAutoMoveEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenLevelSequenceTrigger", "OnPlayerAutoMoved");

	Params::EdenLevelSequenceTrigger_OnPlayerAutoMoved Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenLevelSequenceTrigger.OnPlaySequence
// (Final, Native, Private)

void AEdenLevelSequenceTrigger::OnPlaySequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenLevelSequenceTrigger", "OnPlaySequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EdenLevelSequenceTrigger.OnStopSequence
// (Final, Native, Private)

void AEdenLevelSequenceTrigger::OnStopSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EdenLevelSequenceTrigger", "OnStopSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_ArchiveEnd.OnArchiveEndCompleted
// (Native, Public)

void UQSTask_ArchiveEnd::OnArchiveEndCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ArchiveEnd", "OnArchiveEndCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EffectControllerInterface.GetEffectControlComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UEffectControlComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEffectControlComponent* IEffectControllerInterface::GetEffectControlComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("EffectControllerInterface", "GetEffectControlComponent");

	Params::EffectControllerInterface_GetEffectControlComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_BuddyGuidanceBegin.OnDespawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_BuddyGuidanceBegin::OnDespawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_BuddyGuidanceBegin", "OnDespawn");

	Params::QSTask_BuddyGuidanceBegin_OnDespawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_BuddyGuidanceBegin.OnSpawn
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_BuddyGuidanceBegin::OnSpawn(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_BuddyGuidanceBegin", "OnSpawn");

	Params::QSTask_BuddyGuidanceBegin_OnSpawn Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_BloodCodeAddProficiency.OnAssetsLoaded
// (Final, Native, Private)

void UQSTask_BloodCodeAddProficiency::OnAssetsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_BloodCodeAddProficiency", "OnAssetsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnAnyActorEntersCabinButton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AElevator::OnAnyActorEntersCabinButton(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnAnyActorEntersCabinButton");

	Params::Elevator_OnAnyActorEntersCabinButton Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnAnyActorLeavesCabinButton
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnAnyActorLeavesCabinButton(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnAnyActorLeavesCabinButton");

	Params::Elevator_OnAnyActorLeavesCabinButton Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnCallSwitchActivated_Lower
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnCallSwitchActivated_Lower(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnCallSwitchActivated_Lower");

	Params::Elevator_OnCallSwitchActivated_Lower Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnCallSwitchActivated_Upper
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnCallSwitchActivated_Upper(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnCallSwitchActivated_Upper");

	Params::Elevator_OnCallSwitchActivated_Upper Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnComponentBeginOverlap_CabinVolume
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AElevator::OnComponentBeginOverlap_CabinVolume(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnComponentBeginOverlap_CabinVolume");

	Params::Elevator_OnComponentBeginOverlap_CabinVolume Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnComponentEndOverlap_CabinVolume
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnComponentEndOverlap_CabinVolume(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnComponentEndOverlap_CabinVolume");

	Params::Elevator_OnComponentEndOverlap_CabinVolume Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnFastTravelBegin
// (Native, Protected)

void AElevator::OnFastTravelBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnFastTravelBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnRep_bReplicated_CabinButtonAppearancePressed
// (Final, Native, Protected)

void AElevator::OnRep_bReplicated_CabinButtonAppearancePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnRep_bReplicated_CabinButtonAppearancePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnRep_ReplicatedContext
// (Final, Native, Protected)

void AElevator::OnRep_ReplicatedContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnRep_ReplicatedContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnStoryFlagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AElevator::OnStoryFlagChanged(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnStoryFlagChanged");

	Params::Elevator_OnStoryFlagChanged Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Elevator.OnTryToUseCallSwitch_Lower
// (Final, Native, Protected)
// Parameters:
// const bool                              bInNoSideEffect                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AElevator::OnTryToUseCallSwitch_Lower(const bool bInNoSideEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnTryToUseCallSwitch_Lower");

	Params::Elevator_OnTryToUseCallSwitch_Lower Parms{};

	Parms.bInNoSideEffect = bInNoSideEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Elevator.OnTryToUseCallSwitch_Upper
// (Final, Native, Protected)
// Parameters:
// const bool                              bInNoSideEffect                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AElevator::OnTryToUseCallSwitch_Upper(const bool bInNoSideEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnTryToUseCallSwitch_Upper");

	Params::Elevator_OnTryToUseCallSwitch_Upper Parms{};

	Parms.bInNoSideEffect = bInNoSideEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionMenuUIObject.GetEmotionIndexNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EEmotionEntry                     InEntry                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEmotionMenuUIObject::GetEmotionIndexNumber(const EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionMenuUIObject", "GetEmotionIndexNumber");

	Params::EmotionMenuUIObject_GetEmotionIndexNumber Parms{};

	Parms.InEntry = InEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionMenuUIObject.SetCurrentSlotGestureInfoByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionMenuUIObject::SetCurrentSlotGestureInfoByIndex(const int32 InIndex, bool bIsFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionMenuUIObject", "SetCurrentSlotGestureInfoByIndex");

	Params::EmotionMenuUIObject_SetCurrentSlotGestureInfoByIndex Parms{};

	Parms.InIndex = InIndex;
	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionMenuUIObject.SetCurrentSlotStampInfoByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionMenuUIObject::SetCurrentSlotStampInfoByIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionMenuUIObject", "SetCurrentSlotStampInfoByIndex");

	Params::EmotionMenuUIObject_SetCurrentSlotStampInfoByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionMenuUIObject.SetCurrentSlotVoiceInfoByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionMenuUIObject::SetCurrentSlotVoiceInfoByIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionMenuUIObject", "SetCurrentSlotVoiceInfoByIndex");

	Params::EmotionMenuUIObject_SetCurrentSlotVoiceInfoByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.EditEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteEditAssignMenu::EditEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "EditEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.EmotionPaletteEnd
// (Final, Native, Public, BlueprintCallable)

void UEmotionPaletteEditAssignMenu::EmotionPaletteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "EmotionPaletteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetFemaleSelecter
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UEmotionPaletteEditAssignMenu::GetFemaleSelecter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetFemaleSelecter");

	Params::EmotionPaletteEditAssignMenu_GetFemaleSelecter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetGestureUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionGestureUIInfo*           OutGestureInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::GetGestureUIInfoByAvailableIndex(const int32 InIndex, struct FEmotionGestureUIInfo* OutGestureInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetGestureUIInfoByAvailableIndex");

	Params::EmotionPaletteEditAssignMenu_GetGestureUIInfoByAvailableIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGestureInfo != nullptr)
		*OutGestureInfo = std::move(Parms.OutGestureInfo);
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetIcomVeiwer
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionPalettePieceWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmotionPalettePieceWidget* UEmotionPaletteEditAssignMenu::GetIcomVeiwer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetIcomVeiwer");

	Params::EmotionPaletteEditAssignMenu_GetIcomVeiwer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetIndexCurentSlotEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EEmotionEntry                     InEntry                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEmotionPaletteEditAssignMenu::GetIndexCurentSlotEntry(const EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetIndexCurentSlotEntry");

	Params::EmotionPaletteEditAssignMenu_GetIndexCurentSlotEntry Parms{};

	Parms.InEntry = InEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetMaleSelecter
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UEmotionPaletteEditAssignMenu::GetMaleSelecter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetMaleSelecter");

	Params::EmotionPaletteEditAssignMenu_GetMaleSelecter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetSelectMenuPieceBase
// (Event, Public, BlueprintEvent)
// Parameters:
// EEmotionEntry                           InEntry                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuPieceBase*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuPieceBase* UEmotionPaletteEditAssignMenu::GetSelectMenuPieceBase(EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetSelectMenuPieceBase");

	Params::EmotionPaletteEditAssignMenu_GetSelectMenuPieceBase Parms{};

	Parms.InEntry = InEntry;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetStampUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionStampUIInfo*             OutGestureInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::GetStampUIInfoByAvailableIndex(const int32 InIndex, struct FEmotionStampUIInfo* OutGestureInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetStampUIInfoByAvailableIndex");

	Params::EmotionPaletteEditAssignMenu_GetStampUIInfoByAvailableIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGestureInfo != nullptr)
		*OutGestureInfo = std::move(Parms.OutGestureInfo);
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetVoiceUIInfoByAvailableIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmotionVoiceUIInfo*             OutVoiceInfo                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::GetVoiceUIInfoByAvailableIndex(const int32 InIndex, struct FEmotionVoiceUIInfo* OutVoiceInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetVoiceUIInfoByAvailableIndex");

	Params::EmotionPaletteEditAssignMenu_GetVoiceUIInfoByAvailableIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVoiceInfo != nullptr)
		*OutVoiceInfo = std::move(Parms.OutVoiceInfo);
}


// Function Extensions.EmotionPaletteEditAssignMenu.MoveEntryDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::MoveEntryDown(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "MoveEntryDown");

	Params::EmotionPaletteEditAssignMenu_MoveEntryDown Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.MoveEntryUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanWrap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::MoveEntryUp(bool bCanWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "MoveEntryUp");

	Params::EmotionPaletteEditAssignMenu_MoveEntryUp Parms{};

	Parms.bCanWrap = bCanWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.RequestVoiceTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::RequestVoiceTest(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "RequestVoiceTest");

	Params::EmotionPaletteEditAssignMenu_RequestVoiceTest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SelectEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmotionEntry                           InEntry                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SelectEntry(EEmotionEntry InEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SelectEntry");

	Params::EmotionPaletteEditAssignMenu_SelectEntry Parms{};

	Parms.InEntry = InEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SelectGestureType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsFemale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsInit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SelectGestureType(bool InbIsFemale, bool InbIsInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SelectGestureType");

	Params::EmotionPaletteEditAssignMenu_SelectGestureType Parms{};

	Parms.InbIsFemale = InbIsFemale;
	Parms.InbIsInit = InbIsInit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SetRegistrationGesutureIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SetRegistrationGesutureIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SetRegistrationGesutureIndex");

	Params::EmotionPaletteEditAssignMenu_SetRegistrationGesutureIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SetRegistrationStampIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SetRegistrationStampIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SetRegistrationStampIndex");

	Params::EmotionPaletteEditAssignMenu_SetRegistrationStampIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SetRegistrationVoiceIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SetRegistrationVoiceIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SetRegistrationVoiceIndex");

	Params::EmotionPaletteEditAssignMenu_SetRegistrationVoiceIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EmotionPaletteEditAssignMenu.SeUpGridScroller
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEmotionMenuUIObject*             InCaller                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmotionPaletteEditAssignMenu::SeUpGridScroller(class UEmotionMenuUIObject* InCaller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "SeUpGridScroller");

	Params::EmotionPaletteEditAssignMenu_SeUpGridScroller Parms{};

	Parms.InCaller = InCaller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EmotionPaletteEditAssignMenu.GetCurrentSelectEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEmotionEntry                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EEmotionEntry UEmotionPaletteEditAssignMenu::GetCurrentSelectEntry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPaletteEditAssignMenu", "GetCurrentSelectEntry");

	Params::EmotionPaletteEditAssignMenu_GetCurrentSelectEntry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPalettePieceWidget.GetFemaleWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UEmotionPalettePieceWidget::GetFemaleWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPalettePieceWidget", "GetFemaleWidget");

	Params::EmotionPalettePieceWidget_GetFemaleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPalettePieceWidget.GetGesutureImageBase
// (Event, Public, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UEmotionPalettePieceWidget::GetGesutureImageBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPalettePieceWidget", "GetGesutureImageBase");

	Params::EmotionPalettePieceWidget_GetGesutureImageBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPalettePieceWidget.GetMaleWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UEmotionPalettePieceWidget::GetMaleWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPalettePieceWidget", "GetMaleWidget");

	Params::EmotionPalettePieceWidget_GetMaleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPalettePieceWidget.GetStampImageBase
// (Event, Public, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UEmotionPalettePieceWidget::GetStampImageBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPalettePieceWidget", "GetStampImageBase");

	Params::EmotionPalettePieceWidget_GetStampImageBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionPalettePieceWidget.GetVoiceTextBlock
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTextBlock*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextBlock* UEmotionPalettePieceWidget::GetVoiceTextBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionPalettePieceWidget", "GetVoiceTextBlock");

	Params::EmotionPalettePieceWidget_GetVoiceTextBlock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EmotionStampWidget.GetBaseImage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UEmotionStampWidget::GetBaseImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmotionStampWidget", "GetBaseImage");

	Params::EmotionStampWidget_GetBaseImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpawnBulletIF.GetSpawnBulletParameter
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBulletCreateInfo*               InOutInfo                                              (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ISpawnBulletIF::GetSpawnBulletParameter(struct FBulletCreateInfo* InOutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletIF", "GetSpawnBulletParameter");

	Params::SpawnBulletIF_GetSpawnBulletParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InOutInfo != nullptr)
		*InOutInfo = std::move(Parms.InOutInfo);
}


// Function Extensions.SpawnBulletIF.OnBulletDestroyed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class FName                       BulletID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EBulletDestroyedReason            InReason                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnBulletIF::OnBulletDestroyed(const class FName BulletID, const EBulletDestroyedReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletIF", "OnBulletDestroyed");

	Params::SpawnBulletIF_OnBulletDestroyed Parms{};

	Parms.BulletID = BulletID;
	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletIF.OnBulletHitResult
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAttackCollisionResult&    InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ISpawnBulletIF::OnBulletHitResult(const struct FAttackCollisionResult& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletIF", "OnBulletHitResult");

	Params::SpawnBulletIF_OnBulletHitResult Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletIF.OnSpawnBullet
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class ABulletBase*                InBullet                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnBulletIF::OnSpawnBullet(const class ABulletBase* InBullet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SpawnBulletIF", "OnSpawnBullet");

	Params::SpawnBulletIF_OnSpawnBullet Parms{};

	Parms.InBullet = InBullet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.HowlingActivateTerrain.GetRemainingTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHowlingActivateTerrain::GetRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HowlingActivateTerrain", "GetRemainingTime");

	Params::HowlingActivateTerrain_GetRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.HowlingActivateTerrain.ReceiveActivated
// (Event, Protected, BlueprintEvent)

void AHowlingActivateTerrain::ReceiveActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HowlingActivateTerrain", "ReceiveActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.HowlingActivateTerrain.ReceiveUnActivated
// (Event, Protected, BlueprintEvent)

void AHowlingActivateTerrain::ReceiveUnActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HowlingActivateTerrain", "ReceiveUnActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.WaterInteractionActor.BeginOverlapWaterNative
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AWaterSurfaceVolume*              WaterSurface                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWaterInteractionActor::BeginOverlapWaterNative(class AWaterSurfaceVolume* WaterSurface, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterInteractionActor", "BeginOverlapWaterNative");

	Params::WaterInteractionActor_BeginOverlapWaterNative Parms{};

	Parms.WaterSurface = WaterSurface;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.WaterInteractionActor.EndOverlapWaterNative
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AWaterSurfaceVolume*              WaterSurface                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWaterInteractionActor::EndOverlapWaterNative(class AWaterSurfaceVolume* WaterSurface, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterInteractionActor", "EndOverlapWaterNative");

	Params::WaterInteractionActor_EndOverlapWaterNative Parms{};

	Parms.WaterSurface = WaterSurface;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveIndicatorUIObject.HideAutoSaveEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveIndicatorUIObject::HideAutoSaveEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveIndicatorUIObject", "HideAutoSaveEffect");

	Params::SaveIndicatorUIObject_HideAutoSaveEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SaveIndicatorUIObject.ShowAutoSaveEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveIndicatorUIObject::ShowAutoSaveEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveIndicatorUIObject", "ShowAutoSaveEffect");

	Params::SaveIndicatorUIObject_ShowAutoSaveEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StringTableFunctionLibrary.K2_AddSourceStringToStringTable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FName                       InTableId                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InKey                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InSourceString                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStringTableFunctionLibrary::K2_AddSourceStringToStringTable(const class FName InTableId, const class FString& InKey, const class FString& InSourceString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringTableFunctionLibrary", "K2_AddSourceStringToStringTable");

	Params::StringTableFunctionLibrary_K2_AddSourceStringToStringTable Parms{};

	Parms.InTableId = InTableId;
	Parms.InKey = std::move(InKey);
	Parms.InSourceString = std::move(InSourceString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StringTableFunctionLibrary.K2_ClearStringTable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FName                       InTableId                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStringTableFunctionLibrary::K2_ClearStringTable(const class FName InTableId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringTableFunctionLibrary", "K2_ClearStringTable");

	Params::StringTableFunctionLibrary_K2_ClearStringTable Parms{};

	Parms.InTableId = InTableId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StringTableFunctionLibrary.K2_RemoveSourceStringToStringTable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FName                       InTableId                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InKey                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStringTableFunctionLibrary::K2_RemoveSourceStringToStringTable(const class FName InTableId, const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringTableFunctionLibrary", "K2_RemoveSourceStringToStringTable");

	Params::StringTableFunctionLibrary_K2_RemoveSourceStringToStringTable Parms{};

	Parms.InTableId = InTableId;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyAnimInstance.GetEnemyAnimParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FEnemyAnimParameter        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEnemyAnimParameter UEnemyAnimInstance::GetEnemyAnimParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInstance", "GetEnemyAnimParameter");

	Params::EnemyAnimInstance_GetEnemyAnimParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyAnimInstance.GetIdleMotionWeaponCategory
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponCategory                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponCategory UEnemyAnimInstance::GetIdleMotionWeaponCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInstance", "GetIdleMotionWeaponCategory");

	Params::EnemyAnimInstance_GetIdleMotionWeaponCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyAnimInstance.IsFemaleIdleMotion
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyAnimInstance::IsFemaleIdleMotion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInstance", "IsFemaleIdleMotion");

	Params::EnemyAnimInstance_IsFemaleIdleMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.BindOnUpdateKeyAssign
// (Final, Native, Protected, BlueprintCallable)

void UGadgetIndicatorUIObject::BindOnUpdateKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "BindOnUpdateKeyAssign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetIndicatorUIObject.InitializeIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentIchorAmount                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxIchorAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::InitializeIndicator(const float InCurrentIchorAmount, const float InMaxIchorAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "InitializeIndicator");

	Params::GadgetIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InCurrentIchorAmount = InCurrentIchorAmount;
	Parms.InMaxIchorAmount = InMaxIchorAmount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyDefensiveGadgetChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EDefensiveGadgetType              NewGadgetType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyDefensiveGadgetChanged(const EDefensiveGadgetType NewGadgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyDefensiveGadgetChanged");

	Params::GadgetIndicatorUIObject_NotifyDefensiveGadgetChanged Parms{};

	Parms.NewGadgetType = NewGadgetType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyGadgetActivated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EGadgetPanelSlot                  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyGadgetActivated(const EGadgetPanelSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyGadgetActivated");

	Params::GadgetIndicatorUIObject_NotifyGadgetActivated Parms{};

	Parms.InSlot = InSlot;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyGadgetActiveTimeUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EGadgetPanelSlot                  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyGadgetActiveTimeUpdated(const EGadgetPanelSlot InSlot, const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyGadgetActiveTimeUpdated");

	Params::GadgetIndicatorUIObject_NotifyGadgetActiveTimeUpdated Parms{};

	Parms.InSlot = InSlot;
	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyGadgetCostUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EGadgetPanelSlot                  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCost                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyGadgetCostUpdated(const EGadgetPanelSlot InSlot, const int32 InCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyGadgetCostUpdated");

	Params::GadgetIndicatorUIObject_NotifyGadgetCostUpdated Parms{};

	Parms.InSlot = InSlot;
	Parms.InCost = InCost;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyGadgetStateUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EGadgetPanelSlot                  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGadgetIconState                  InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyGadgetStateUpdated(const EGadgetPanelSlot InSlot, const EGadgetIconState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyGadgetStateUpdated");

	Params::GadgetIndicatorUIObject_NotifyGadgetStateUpdated Parms{};

	Parms.InSlot = InSlot;
	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyIchorChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentIchorAmount                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxIchorAmount                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyIchorChanged(const float InCurrentIchorAmount, const float InMaxIchorAmount, const EResourceChangeFactor InChangeFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyIchorChanged");

	Params::GadgetIndicatorUIObject_NotifyIchorChanged Parms{};

	Parms.InCurrentIchorAmount = InCurrentIchorAmount;
	Parms.InMaxIchorAmount = InMaxIchorAmount;
	Parms.InChangeFactor = InChangeFactor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.NotifyWeaponChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EPlayerWeaponType                 NewWeaponType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::NotifyWeaponChanged(const EPlayerWeaponType NewWeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "NotifyWeaponChanged");

	Params::GadgetIndicatorUIObject_NotifyWeaponChanged Parms{};

	Parms.NewWeaponType = NewWeaponType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetIndicatorUIObject.OnUpdateKeyAssign
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UGadgetIndicatorUIObject::OnUpdateKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "OnUpdateKeyAssign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.GadgetIndicatorUIObject.SetGadgetIcon
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EGadgetPanelSlot                  InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>& InTexture                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGadgetIndicatorUIObject::SetGadgetIcon(const EGadgetPanelSlot InSlot, const TSoftObjectPtr<class UTexture2D>& InTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetIndicatorUIObject", "SetGadgetIcon");

	Params::GadgetIndicatorUIObject_SetGadgetIcon Parms{};

	Parms.InSlot = InSlot;
	Parms.InTexture = InTexture;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenMaskManager.OnScreenMaskCompleted
// (Final, Native, Private)

void UScreenMaskManager::OnScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskManager", "OnScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskManager.OnScreenMaskRemoved
// (Final, Native, Private)

void UScreenMaskManager::OnScreenMaskRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskManager", "OnScreenMaskRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GameplayTagUtility.GetRightmostString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayTagUtility::GetRightmostString(const struct FGameplayTag& InTag, const int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTagUtility", "GetRightmostString");

	Params::GameplayTagUtility_GetRightmostString Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyDefeatMessageBase.SetDefeatMessage
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnemyDefeatAppearanceType              InAppearanceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyDefeatMessageBase::SetDefeatMessage(EEnemyDefeatAppearanceType InAppearanceType, const class FText& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDefeatMessageBase", "SetDefeatMessage");

	Params::EnemyDefeatMessageBase_SetDefeatMessage Parms{};

	Parms.InAppearanceType = InAppearanceType;
	Parms.InMessage = std::move(InMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EquipmentVisualControlInterface.K2_GetEquipmentVisualControl
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UEquipmentVisualControlComponent*ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UEquipmentVisualControlComponent* IEquipmentVisualControlInterface::K2_GetEquipmentVisualControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("EquipmentVisualControlInterface", "K2_GetEquipmentVisualControl");

	Params::EquipmentVisualControlInterface_K2_GetEquipmentVisualControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_ShowInstruction.OnChangeGameFlag
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_ShowInstruction::OnChangeGameFlag(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ShowInstruction", "OnChangeGameFlag");

	Params::QSTask_ShowInstruction_OnChangeGameFlag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.OnAnyActorEntersAdventureTalkEventArea
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AExtendableLadder::OnAnyActorEntersAdventureTalkEventArea(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnAnyActorEntersAdventureTalkEventArea");

	Params::ExtendableLadder_OnAnyActorEntersAdventureTalkEventArea Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.OnAnyActorLeavesAdventureTalkEventArea
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtendableLadder::OnAnyActorLeavesAdventureTalkEventArea(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnAnyActorLeavesAdventureTalkEventArea");

	Params::ExtendableLadder_OnAnyActorLeavesAdventureTalkEventArea Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.OnCharacterFellOffFromTopMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMovementMode                     InPrevMovementMode                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             PrevCustomMovementMode                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtendableLadder::OnCharacterFellOffFromTopMovementModeChanged(class ACharacter* InCharacter, const EMovementMode InPrevMovementMode, const uint8 PrevCustomMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnCharacterFellOffFromTopMovementModeChanged");

	Params::ExtendableLadder_OnCharacterFellOffFromTopMovementModeChanged Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InPrevMovementMode = InPrevMovementMode;
	Parms.PrevCustomMovementMode = PrevCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.OnContextUpdated_BP
// (Event, Protected, BlueprintEvent)

void AExtendableLadder::OnContextUpdated_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnContextUpdated_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ExtendableLadder.OnExtendSwitchActivated
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtendableLadder::OnExtendSwitchActivated(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnExtendSwitchActivated");

	Params::ExtendableLadder_OnExtendSwitchActivated Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.OnRep_ReplicatedContext
// (Final, Native, Protected)

void AExtendableLadder::OnRep_ReplicatedContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "OnRep_ReplicatedContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtendableLadder.GetExtendLength
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AExtendableLadder::GetExtendLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "GetExtendLength");

	Params::ExtendableLadder_GetExtendLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ExtendableLadder.GetHeight
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AExtendableLadder::GetHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "GetHeight");

	Params::ExtendableLadder_GetHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ExtendableLadder.GetTopLedgeTransform
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform AExtendableLadder::GetTopLedgeTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendableLadder", "GetTopLedgeTransform");

	Params::ExtendableLadder_GetTopLedgeTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipActor.GetMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FEquipPositionBindTag&     InEquipPosition                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AEnemyEquipActor::GetMesh(const struct FEquipPositionBindTag& InEquipPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipActor", "GetMesh");

	Params::EnemyEquipActor_GetMesh Parms{};

	Parms.InEquipPosition = std::move(InEquipPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipActor.GetMeshComponentByName
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AEnemyEquipActor::GetMeshComponentByName(const class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipActor", "GetMeshComponentByName");

	Params::EnemyEquipActor_GetMeshComponentByName Parms{};

	Parms.InName = InName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipActor.K2_GetVisualControlClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEquipmentVisualControlComponent>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UEquipmentVisualControlComponent> AEnemyEquipActor::K2_GetVisualControlClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipActor", "K2_GetVisualControlClass");

	Params::EnemyEquipActor_K2_GetVisualControlClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipActor.K2_SetVisualControlClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEquipmentVisualControlComponent>InVisualControlClass                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyEquipActor::K2_SetVisualControlClass(TSubclassOf<class UEquipmentVisualControlComponent> InVisualControlClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipActor", "K2_SetVisualControlClass");

	Params::EnemyEquipActor_K2_SetVisualControlClass Parms{};

	Parms.InVisualControlClass = InVisualControlClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyEquipActor.RegistryEquipMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       InAttachSocket                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InAttachOffset                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEquipPositionBindTag&     InEquipPositionBindTag                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInIsShow                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyEquipActor::RegistryEquipMesh(class USkeletalMeshComponent* InMeshComponent, const class FName InAttachSocket, const struct FTransform& InAttachOffset, const struct FEquipPositionBindTag& InEquipPositionBindTag, const bool bInIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipActor", "RegistryEquipMesh");

	Params::EnemyEquipActor_RegistryEquipMesh Parms{};

	Parms.InMeshComponent = InMeshComponent;
	Parms.InAttachSocket = InAttachSocket;
	Parms.InAttachOffset = std::move(InAttachOffset);
	Parms.InEquipPositionBindTag = std::move(InEquipPositionBindTag);
	Parms.bInIsShow = bInIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyEquipControlComponent.SetActiveEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInIsActive                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyEquipControlComponent::SetActiveEquip(const int32 InIndex, const bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipControlComponent", "SetActiveEquip");

	Params::EnemyEquipControlComponent_SetActiveEquip Parms{};

	Parms.InIndex = InIndex;
	Parms.bInIsActive = bInIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyEquipControlComponent.GetEquipActorByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemyEquipActor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyEquipActor* UEnemyEquipControlComponent::GetEquipActorByIndex(const int32 InIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyEquipControlComponent", "GetEquipActorByIndex");

	Params::EnemyEquipControlComponent_GetEquipActorByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLocomotionAnimInstance.CacheLocomotionAnimationAssets
// (Final, Native, Protected, BlueprintCallable)

void UEnemyLocomotionAnimInstance::CacheLocomotionAnimationAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLocomotionAnimInstance", "CacheLocomotionAnimationAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyLocomotionAnimInstance.GetBlendUpperBodySettings
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FEnemyBlendUpperBodySettingsReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEnemyBlendUpperBodySettings UEnemyLocomotionAnimInstance::GetBlendUpperBodySettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLocomotionAnimInstance", "GetBlendUpperBodySettings");

	Params::EnemyLocomotionAnimInstance_GetBlendUpperBodySettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLocomotionAnimInstance.GetEnemyLocomotionAnimationParam
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FEnemyLocomotionAnimationParamReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEnemyLocomotionAnimationParam UEnemyLocomotionAnimInstance::GetEnemyLocomotionAnimationParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLocomotionAnimInstance", "GetEnemyLocomotionAnimationParam");

	Params::EnemyLocomotionAnimInstance_GetEnemyLocomotionAnimationParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLocomotionAnimInstance.IsCycleAnimation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAnimSequenceBase*          Animation                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyLocomotionAnimInstance::IsCycleAnimation(const class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLocomotionAnimInstance", "IsCycleAnimation");

	Params::EnemyLocomotionAnimInstance_IsCycleAnimation Parms{};

	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyLocomotionAnimInstance.IsEnemyLookAtAnimInstanceLinked
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyLocomotionAnimInstance::IsEnemyLookAtAnimInstanceLinked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyLocomotionAnimInstance", "IsEnemyLookAtAnimInstanceLinked");

	Params::EnemyLocomotionAnimInstance_IsEnemyLookAtAnimInstanceLinked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyManager.NotifyPhenomenon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPhenomenonNotifyType                   InNotifyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyManager::NotifyPhenomenon(EPhenomenonNotifyType InNotifyType, class AActor* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyManager", "NotifyPhenomenon");

	Params::EnemyManager_NotifyPhenomenon Parms{};

	Parms.InNotifyType = InNotifyType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemySkeletalMeshComponent.OnWeaponHitGround
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEnemySkeletalMeshComponent::OnWeaponHitGround(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySkeletalMeshComponent", "OnWeaponHitGround");

	Params::EnemySkeletalMeshComponent_OnWeaponHitGround Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_BleedingAmount
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldBleedingAmount                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_BleedingAmount(const struct FGameplayAttributeData& OldBleedingAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_BleedingAmount");

	Params::EnemyStatusAttributeSet_OnRep_BleedingAmount Parms{};

	Parms.OldBleedingAmount = std::move(OldBleedingAmount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_BurningState
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldBurningState                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_BurningState(const struct FGameplayAttributeData& OldBurningState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_BurningState");

	Params::EnemyStatusAttributeSet_OnRep_BurningState Parms{};

	Parms.OldBurningState = std::move(OldBurningState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_EnhancementSupporterAttackRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldEnhancementSupporterAttackRate                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_EnhancementSupporterAttackRate(const struct FGameplayAttributeData& OldEnhancementSupporterAttackRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_EnhancementSupporterAttackRate");

	Params::EnemyStatusAttributeSet_OnRep_EnhancementSupporterAttackRate Parms{};

	Parms.OldEnhancementSupporterAttackRate = std::move(OldEnhancementSupporterAttackRate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_EnhancementSupporterStaminaDamageRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldEnhancementSupporterStaminaDamageRate               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_EnhancementSupporterStaminaDamageRate(const struct FGameplayAttributeData& OldEnhancementSupporterStaminaDamageRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_EnhancementSupporterStaminaDamageRate");

	Params::EnemyStatusAttributeSet_OnRep_EnhancementSupporterStaminaDamageRate Parms{};

	Parms.OldEnhancementSupporterStaminaDamageRate = std::move(OldEnhancementSupporterStaminaDamageRate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_Health
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldHealth                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_Health(const struct FGameplayAttributeData& OldHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_Health");

	Params::EnemyStatusAttributeSet_OnRep_Health Parms{};

	Parms.OldHealth = std::move(OldHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_InvalidDamageCount
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldInvalidDamageCount                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_InvalidDamageCount(const struct FGameplayAttributeData& OldInvalidDamageCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_InvalidDamageCount");

	Params::EnemyStatusAttributeSet_OnRep_InvalidDamageCount Parms{};

	Parms.OldInvalidDamageCount = std::move(OldInvalidDamageCount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_MaxBleedingAmount
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxBleedingAmount                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_MaxBleedingAmount(const struct FGameplayAttributeData& OldMaxBleedingAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_MaxBleedingAmount");

	Params::EnemyStatusAttributeSet_OnRep_MaxBleedingAmount Parms{};

	Parms.OldMaxBleedingAmount = std::move(OldMaxBleedingAmount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_MaxHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldHealth                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_MaxHealth");

	Params::EnemyStatusAttributeSet_OnRep_MaxHealth Parms{};

	Parms.OldHealth = std::move(OldHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyStatusAttributeSet.OnRep_RecoverHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldRecoverHealth                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnemyStatusAttributeSet::OnRep_RecoverHealth(const struct FGameplayAttributeData& OldRecoverHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyStatusAttributeSet", "OnRep_RecoverHealth");

	Params::EnemyStatusAttributeSet_OnRep_RecoverHealth Parms{};

	Parms.OldRecoverHealth = std::move(OldRecoverHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyVisualControlComponent.BeginBloodThirstSign
// (Event, Public, BlueprintEvent)

void UEnemyVisualControlComponent::BeginBloodThirstSign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "BeginBloodThirstSign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnemyVisualControlComponent.EnableBattleStateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::EnableBattleStateEvent(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "EnableBattleStateEvent");

	Params::EnemyVisualControlComponent_EnableBattleStateEvent Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnemyVisualControlComponent.EndBloodThirstSign
// (Event, Public, BlueprintEvent)

void UEnemyVisualControlComponent::EndBloodThirstSign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "EndBloodThirstSign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnemyVisualControlComponent.GeneralWarpEffect_Begin
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InVanishTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::GeneralWarpEffect_Begin(float InVanishTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "GeneralWarpEffect_Begin");

	Params::EnemyVisualControlComponent_GeneralWarpEffect_Begin Parms{};

	Parms.InVanishTime = InVanishTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.GeneralWarpEffect_End
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InAppearTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::GeneralWarpEffect_End(float InAppearTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "GeneralWarpEffect_End");

	Params::EnemyVisualControlComponent_GeneralWarpEffect_End Parms{};

	Parms.InAppearTime = InAppearTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.GetDrawScar
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDrawScarComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDrawScarComponent* UEnemyVisualControlComponent::GetDrawScar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "GetDrawScar");

	Params::EnemyVisualControlComponent_GetDrawScar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyVisualControlComponent.GetVisualControlParameter
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVisualControlParameter*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVisualControlParameter* UEnemyVisualControlComponent::GetVisualControlParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "GetVisualControlParameter");

	Params::EnemyVisualControlComponent_GetVisualControlParameter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.EnemyVisualControlComponent.OnBattleStateBegin
// (Event, Public, BlueprintEvent)

void UEnemyVisualControlComponent::OnBattleStateBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "OnBattleStateBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnemyVisualControlComponent.OnBattleStateEnd
// (Event, Public, BlueprintEvent)

void UEnemyVisualControlComponent::OnBattleStateEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "OnBattleStateEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnemyVisualControlComponent.OnChangeCharacterMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVisualControlParameter*          InVisualControlParameter                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InDrawScarMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::OnChangeCharacterMesh(class UVisualControlParameter* InVisualControlParameter, class USkeletalMeshComponent* InDrawScarMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "OnChangeCharacterMesh");

	Params::EnemyVisualControlComponent_OnChangeCharacterMesh Parms{};

	Parms.InVisualControlParameter = InVisualControlParameter;
	Parms.InDrawScarMesh = InDrawScarMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.OnSpawnEffectAlways
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UNiagaraComponent*                InEffect                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InEffectName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::OnSpawnEffectAlways(class UNiagaraComponent* InEffect, const class FName& InEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "OnSpawnEffectAlways");

	Params::EnemyVisualControlComponent_OnSpawnEffectAlways Parms{};

	Parms.InEffect = InEffect;
	Parms.InEffectName = InEffectName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.OnSpawnEffectRecoverHealth
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UNiagaraComponent*                InEffect                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InEffectName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::OnSpawnEffectRecoverHealth(class UNiagaraComponent* InEffect, const class FName& InEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "OnSpawnEffectRecoverHealth");

	Params::EnemyVisualControlComponent_OnSpawnEffectRecoverHealth Parms{};

	Parms.InEffect = InEffect;
	Parms.InEffectName = InEffectName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.ReinitializeVisualControl
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVisualControlParameter*          InVisualControlParameter                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyVisualControlComponent::ReinitializeVisualControl(class UVisualControlParameter* InVisualControlParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "ReinitializeVisualControl");

	Params::EnemyVisualControlComponent_ReinitializeVisualControl Parms{};

	Parms.InVisualControlParameter = InVisualControlParameter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.EnemyVisualControlComponent.SpawnGeneralVanishEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEnemyVisualControlComponent::SpawnGeneralVanishEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyVisualControlComponent", "SpawnGeneralVanishEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.EnhancementMenuUIObject.CreatePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UEnhancementMenuUIObject::CreatePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "CreatePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnhancementMenuUIObject.DeletePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UEnhancementMenuUIObject::DeletePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "DeletePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnhancementMenuUIObject.GetDefenceGadgetEnchantNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InDefenceGadgetIndex                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEnhancementMenuUIObject::GetDefenceGadgetEnchantNumber(const int32 InDefenceGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetDefenceGadgetEnchantNumber");

	Params::EnhancementMenuUIObject_GetDefenceGadgetEnchantNumber Parms{};

	Parms.InDefenceGadgetIndex = InDefenceGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetDefenceGadgetEnchantUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InDefenceGadgetInfo                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetDefenceGadgetEnchantUIInfo(const int32 InDefenceGadgetInfo, const int32 InEnchantIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetDefenceGadgetEnchantUIInfo");

	Params::EnhancementMenuUIObject_GetDefenceGadgetEnchantUIInfo Parms{};

	Parms.InDefenceGadgetInfo = InDefenceGadgetInfo;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetDefenceGadgetNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetDefenceGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetDefenceGadgetNumber");

	Params::EnhancementMenuUIObject_GetDefenceGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetDefenceGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InDefenceGadgetIndex                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetDefenceGadgetUIInfo(const int32 InDefenceGadgetIndex, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetDefenceGadgetUIInfo");

	Params::EnhancementMenuUIObject_GetDefenceGadgetUIInfo Parms{};

	Parms.InDefenceGadgetIndex = InDefenceGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetEnchantedDefenceGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InDefenceGadgetIndex                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutDefenceGadgetInfo                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetEnchantedDefenceGadgetUIInfo(const int32 InDefenceGadgetIndex, const int32 InEnchantIndex, struct FUIDefensiveGadgetInfo* OutDefenceGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEnchantedDefenceGadgetUIInfo");

	Params::EnhancementMenuUIObject_GetEnchantedDefenceGadgetUIInfo Parms{};

	Parms.InDefenceGadgetIndex = InDefenceGadgetIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefenceGadgetInfo != nullptr)
		*OutDefenceGadgetInfo = std::move(Parms.OutDefenceGadgetInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetEnchantedWeaponUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetEnchantedWeaponUIInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const int32 InEnchantIndex, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEnchantedWeaponUIInfo");

	Params::EnhancementMenuUIObject_GetEnchantedWeaponUIInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetEnhancementEquipmentType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIArticleCategory                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIArticleCategory UEnhancementMenuUIObject::GetEnhancementEquipmentType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEnhancementEquipmentType");

	Params::EnhancementMenuUIObject_GetEnhancementEquipmentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetEquipDefenceGadget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetEquipDefenceGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEquipDefenceGadget");

	Params::EnhancementMenuUIObject_GetEquipDefenceGadget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetEquipIndependentGadget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetEquipIndependentGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEquipIndependentGadget");

	Params::EnhancementMenuUIObject_GetEquipIndependentGadget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetEquipJailIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetEquipJailIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEquipJailIndex");

	Params::EnhancementMenuUIObject_GetEquipJailIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetEquipWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetEquipWeaponIndex(const EUIWeaponSlot InWeaponSlot, const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetEquipWeaponIndex");

	Params::EnhancementMenuUIObject_GetEquipWeaponIndex Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetExp");

	Params::EnhancementMenuUIObject_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetIndependentGadgetLevelUpUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetIndependentGadgetLevelUpUIInfo(const int32 InIndependentGadgetIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetIndependentGadgetLevelUpUIInfo");

	Params::EnhancementMenuUIObject_GetIndependentGadgetLevelUpUIInfo Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetIndependentGadgetNextLevelUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetIndependentGadgetNextLevelUIInfo(const int32 InIndependentGadgetIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetIndependentGadgetNextLevelUIInfo");

	Params::EnhancementMenuUIObject_GetIndependentGadgetNextLevelUIInfo Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetIndependentGadgetNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetIndependentGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetIndependentGadgetNumber");

	Params::EnhancementMenuUIObject_GetIndependentGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetIndependentGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetIndependentGadgetUIInfo(const int32 InIndependentGadgetIndex, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetIndependentGadgetUIInfo");

	Params::EnhancementMenuUIObject_GetIndependentGadgetUIInfo Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetJailLevelUpUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetJailLevelUpUIInfo(const int32 InJailIndex, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetJailLevelUpUIInfo");

	Params::EnhancementMenuUIObject_GetJailLevelUpUIInfo Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetJailNextLevelUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetJailNextLevelUIInfo(const int32 InJailIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetJailNextLevelUIInfo");

	Params::EnhancementMenuUIObject_GetJailNextLevelUIInfo Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetJailNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetJailNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetJailNumber");

	Params::EnhancementMenuUIObject_GetJailNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetJailUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetJailUIInfo(const int32 InJailIndex, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetJailUIInfo");

	Params::EnhancementMenuUIObject_GetJailUIInfo Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetPlayerStatusSummaryInfo");

	Params::EnhancementMenuUIObject_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithDefenceGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithDefenceGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithDefenceGadget");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithDefenceGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithEnchantDefenceGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithEnchantDefenceGadget(const int32 InIndex, const int32 InEnchantIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithEnchantDefenceGadget");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithEnchantDefenceGadget Parms{};

	Parms.InIndex = InIndex;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithEnchantWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQueryInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithEnchantWeapon(const EUIWeaponSlot InWeaponSlot, const struct FUIWeaponQueryInfo& InWeaponQueryInfo, const int32 InEnchantIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithEnchantWeapon");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithEnchantWeapon Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponQueryInfo = std::move(InWeaponQueryInfo);
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithIndependentGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithIndependentGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithIndependentGadget");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithIndependentGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithJail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithJail(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithJail");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithJail Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetSpecialBuffListWithWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQueryInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetSpecialBuffListWithWeapon(const EUIWeaponSlot InWeaponSlot, const struct FUIWeaponQueryInfo& InWeaponQueryInfo, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetSpecialBuffListWithWeapon");

	Params::EnhancementMenuUIObject_GetSpecialBuffListWithWeapon Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponQueryInfo = std::move(InWeaponQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponEnchantNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEnhancementMenuUIObject::GetWeaponEnchantNumber(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponEnchantNumber");

	Params::EnhancementMenuUIObject_GetWeaponEnchantNumber Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponEnchantUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIEnhantInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetWeaponEnchantUIInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, const int32 InEnchantIndex, struct FUIEnhantInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponEnchantUIInfo");

	Params::EnhancementMenuUIObject_GetWeaponEnchantUIInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponLevelUpUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIEquipmentLevelUpInfo*         OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetWeaponLevelUpUIInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIEquipmentLevelUpInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponLevelUpUIInfo");

	Params::EnhancementMenuUIObject_GetWeaponLevelUpUIInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponNextLevelUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetWeaponNextLevelUIInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponNextLevelUIInfo");

	Params::EnhancementMenuUIObject_GetWeaponNextLevelUIInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIWeaponCategory                       InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UEnhancementMenuUIObject::GetWeaponNumber(EUIWeaponCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponNumber");

	Params::EnhancementMenuUIObject_GetWeaponNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.GetWeaponUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::GetWeaponUIInfo(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "GetWeaponUIInfo");

	Params::EnhancementMenuUIObject_GetWeaponUIInfo Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.EnhancementMenuUIObject.LevelUpIndependentGadgetRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnhancementMenuUIObject::LevelUpIndependentGadgetRequest(const int32 InIndependentGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "LevelUpIndependentGadgetRequest");

	Params::EnhancementMenuUIObject_LevelUpIndependentGadgetRequest Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.LevelUpJailRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnhancementMenuUIObject::LevelUpJailRequest(const int32 InJailIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "LevelUpJailRequest");

	Params::EnhancementMenuUIObject_LevelUpJailRequest Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.LevelUpWeaponRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnhancementMenuUIObject::LevelUpWeaponRequest(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "LevelUpWeaponRequest");

	Params::EnhancementMenuUIObject_LevelUpWeaponRequest Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.OpenDefenceGadgetEnchantMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UEnhancementMenuUIObject::OpenDefenceGadgetEnchantMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "OpenDefenceGadgetEnchantMenu");

	Params::EnhancementMenuUIObject_OpenDefenceGadgetEnchantMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.OpenJailLevelUpMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UEnhancementMenuUIObject::OpenJailLevelUpMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "OpenJailLevelUpMenu");

	Params::EnhancementMenuUIObject_OpenJailLevelUpMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.OpenStandAloneLevelUpMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UEnhancementMenuUIObject::OpenStandAloneLevelUpMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "OpenStandAloneLevelUpMenu");

	Params::EnhancementMenuUIObject_OpenStandAloneLevelUpMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.OpenWeaponEnchantMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UEnhancementMenuUIObject::OpenWeaponEnchantMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "OpenWeaponEnchantMenu");

	Params::EnhancementMenuUIObject_OpenWeaponEnchantMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.OpenWeaponLevelUpMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UEnhancementMenuUIObject::OpenWeaponLevelUpMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "OpenWeaponLevelUpMenu");

	Params::EnhancementMenuUIObject_OpenWeaponLevelUpMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.RequestDefenceGadgetEnchant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InDefenceGadgetInfo                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnhancementMenuUIObject::RequestDefenceGadgetEnchant(const int32 InDefenceGadgetInfo, const int32 InEnchantIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "RequestDefenceGadgetEnchant");

	Params::EnhancementMenuUIObject_RequestDefenceGadgetEnchant Parms{};

	Parms.InDefenceGadgetInfo = InDefenceGadgetInfo;
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.RequestWeaponEnchant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InEnchantIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnhancementMenuUIObject::RequestWeaponEnchant(const struct FUIWeaponQueryInfo& InWeaponQuery, const int32 InEnchantIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "RequestWeaponEnchant");

	Params::EnhancementMenuUIObject_RequestWeaponEnchant Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InEnchantIndex = InEnchantIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnhancementMenuUIObject.TradeSuccessNotifyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FScenarioNPCEventInfo&     InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEnhancementMenuUIObject::TradeSuccessNotifyEvent(const struct FScenarioNPCEventInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnhancementMenuUIObject", "TradeSuccessNotifyEvent");

	Params::EnhancementMenuUIObject_TradeSuccessNotifyEvent Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentOnlineComponent.ClientReceiveCurrentWeather
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FWeatherTypeTag&           InWeatherType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWeatherTypeTag&           InNextWeatherType                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsImmediate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentOnlineComponent::ClientReceiveCurrentWeather(const struct FWeatherTypeTag& InWeatherType, const struct FWeatherTypeTag& InNextWeatherType, bool IsImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentOnlineComponent", "ClientReceiveCurrentWeather");

	Params::EnvironmentOnlineComponent_ClientReceiveCurrentWeather Parms{};

	Parms.InWeatherType = std::move(InWeatherType);
	Parms.InNextWeatherType = std::move(InNextWeatherType);
	Parms.IsImmediate = IsImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentOnlineComponent.ClientSetEnvironmentInfo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWeatherTypeTag&           InWeatherType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWeatherTypeTag&           InNextWeatherType                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentOnlineComponent::ClientSetEnvironmentInfo(float InTime, const struct FWeatherTypeTag& InWeatherType, const struct FWeatherTypeTag& InNextWeatherType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentOnlineComponent", "ClientSetEnvironmentInfo");

	Params::EnvironmentOnlineComponent_ClientSetEnvironmentInfo Parms{};

	Parms.InTime = InTime;
	Parms.InWeatherType = std::move(InWeatherType);
	Parms.InNextWeatherType = std::move(InNextWeatherType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentOnlineComponent.ClientSetInGameClock
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentOnlineComponent::ClientSetInGameClock(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentOnlineComponent", "ClientSetInGameClock");

	Params::EnvironmentOnlineComponent_ClientSetInGameClock Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentOnlineComponent.ClientSetWeather
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FWeatherTypeTag&           InWeatherType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsImmediate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentOnlineComponent::ClientSetWeather(const struct FWeatherTypeTag& InWeatherType, bool IsImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentOnlineComponent", "ClientSetWeather");

	Params::EnvironmentOnlineComponent_ClientSetWeather Parms{};

	Parms.InWeatherType = std::move(InWeatherType);
	Parms.IsImmediate = IsImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EnvironmentOnlineComponent.ServerNotifyReady
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UEnvironmentOnlineComponent::ServerNotifyReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentOnlineComponent", "ServerNotifyReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipControlComponent.NotifyUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AItemProxy*                       InItemProxy                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipControlComponent::NotifyUseItem(class AItemProxy* InItemProxy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipControlComponent", "NotifyUseItem");

	Params::EquipControlComponent_NotifyUseItem Parms{};

	Parms.InItemProxy = InItemProxy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipControlComponent.OnGadgetHandles1
// (Final, Native, Private)

void UEquipControlComponent::OnGadgetHandles1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipControlComponent", "OnGadgetHandles1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipControlComponent.OnGadgetHandles2
// (Final, Native, Private)

void UEquipControlComponent::OnGadgetHandles2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipControlComponent", "OnGadgetHandles2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipControlComponent.RequestSync
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UEquipControlComponent::RequestSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipControlComponent", "RequestSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.EquipControlComponent.ServerRequestActionDisable
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const EEquipActionType                  InActionType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipControlComponent::ServerRequestActionDisable(const EEquipActionType InActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipControlComponent", "ServerRequestActionDisable");

	Params::EquipControlComponent_ServerRequestActionDisable Parms{};

	Parms.InActionType = InActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ActionOptional.GetActionStateTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FActionStateDicKeyTag&     InKeyTag                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag AActionOptional::GetActionStateTag(const struct FActionStateDicKeyTag& InKeyTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionOptional", "GetActionStateTag");

	Params::ActionOptional_GetActionStateTag Parms{};

	Parms.InKeyTag = std::move(InKeyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ActionOptional.GetWeaponAddOnGadgetCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAddOnGadgetCategory              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponAddOnGadgetCategory AActionOptional::GetWeaponAddOnGadgetCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionOptional", "GetWeaponAddOnGadgetCategory");

	Params::ActionOptional_GetWeaponAddOnGadgetCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ExplorationDialogUIObject.HideExplorationDialog
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExplorationDialogUIObject::HideExplorationDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplorationDialogUIObject", "HideExplorationDialog");

	Params::ExplorationDialogUIObject_HideExplorationDialog Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ExplorationDialogUIObject.ShowExplorationDialog
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InSpeaker                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InStatement                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             InDuration                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExplorationDialogUIObject::ShowExplorationDialog(const class FText& InSpeaker, const class FText& InStatement, const float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplorationDialogUIObject", "ShowExplorationDialog");

	Params::ExplorationDialogUIObject_ShowExplorationDialog Parms{};

	Parms.InSpeaker = std::move(InSpeaker);
	Parms.InStatement = std::move(InStatement);
	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ExtensionsQuestSystemScript.OnGameModeLogoutEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtensionsQuestSystemScript::OnGameModeLogoutEvent(class AGameModeBase* InGameMode, class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsQuestSystemScript", "OnGameModeLogoutEvent");

	Params::ExtensionsQuestSystemScript_OnGameModeLogoutEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsQuestSystemScript.OnGameModePostLoginEvent
// (Final, Native, Private)
// Parameters:
// class AGameModeBase*                    InGameMode                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtensionsQuestSystemScript::OnGameModePostLoginEvent(class AGameModeBase* InGameMode, class APlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsQuestSystemScript", "OnGameModePostLoginEvent");

	Params::ExtensionsQuestSystemScript_OnGameModePostLoginEvent Parms{};

	Parms.InGameMode = InGameMode;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsQuestSystemScript.OnPlayerHotSpringAbilityEnded
// (Final, Native, Public)

void UExtensionsQuestSystemScript::OnPlayerHotSpringAbilityEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsQuestSystemScript", "OnPlayerHotSpringAbilityEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnChangeStoryFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UExtensionsStoryFlagScript::OnChangeStoryFlag(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnChangeStoryFlag");

	Params::ExtensionsStoryFlagScript_OnChangeStoryFlag Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnFinishFastTravel
// (Final, Native, Private)

void UExtensionsStoryFlagScript::OnFinishFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnFinishFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnGameStateEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameStateEvent&           InEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UExtensionsStoryFlagScript::OnGameStateEvent(const struct FGameStateEvent& InEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnGameStateEvent");

	Params::ExtensionsStoryFlagScript_OnGameStateEvent Parms{};

	Parms.InEvent = std::move(InEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnMigrationStoryFlag
// (Final, Native, Private)

void UExtensionsStoryFlagScript::OnMigrationStoryFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnMigrationStoryFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnPlayerEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FPlayerEvent&              InEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UExtensionsStoryFlagScript::OnPlayerEvent(const struct FPlayerEvent& InEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnPlayerEvent");

	Params::ExtensionsStoryFlagScript_OnPlayerEvent Parms{};

	Parms.InEvent = std::move(InEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnPreChangeStoryFlag
// (Final, Native, Private)

void UExtensionsStoryFlagScript::OnPreChangeStoryFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnPreChangeStoryFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ExtensionsStoryFlagScript.OnSetGameStateEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   NewGameState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtensionsStoryFlagScript::OnSetGameStateEvent(class AGameStateBase* NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtensionsStoryFlagScript", "OnSetGameStateEvent");

	Params::ExtensionsStoryFlagScript_OnSetGameStateEvent Parms{};

	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldFunctionLibrary.SetNoCollision
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UPrimitiveComponent*>&InComponents                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bExecute                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldFunctionLibrary::SetNoCollision(const TArray<class UPrimitiveComponent*>& InComponents, bool bExecute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldFunctionLibrary", "SetNoCollision");

	Params::FieldFunctionLibrary_SetNoCollision Parms{};

	Parms.InComponents = std::move(InComponents);
	Parms.bExecute = bExecute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldFunctionLibrary.SetNoCollisionAllPrimitives
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExecute                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldFunctionLibrary::SetNoCollisionAllPrimitives(const class UObject* WorldContextObject, bool bExecute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldFunctionLibrary", "SetNoCollisionAllPrimitives");

	Params::FieldFunctionLibrary_SetNoCollisionAllPrimitives Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bExecute = bExecute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldIndicatorUIObject.NotifyAddCompassTarget
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFieldTargetInfo&          InFieldTargetInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyAddCompassTarget(const struct FCompassTargetHandle& InHandle, const struct FFieldTargetInfo& InFieldTargetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyAddCompassTarget");

	Params::FieldIndicatorUIObject_NotifyAddCompassTarget Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InFieldTargetInfo = std::move(InFieldTargetInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.NotifyEnterSearchArea
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyEnterSearchArea(const struct FCompassTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyEnterSearchArea");

	Params::FieldIndicatorUIObject_NotifyEnterSearchArea Parms{};

	Parms.InHandle = std::move(InHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.NotifyLeaveSearchArea
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyLeaveSearchArea(const struct FCompassTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyLeaveSearchArea");

	Params::FieldIndicatorUIObject_NotifyLeaveSearchArea Parms{};

	Parms.InHandle = std::move(InHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.NotifyRemoveCompassTarget
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyRemoveCompassTarget(const struct FCompassTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyRemoveCompassTarget");

	Params::FieldIndicatorUIObject_NotifyRemoveCompassTarget Parms{};

	Parms.InHandle = std::move(InHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.NotifyUpdateCompassIcon
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyUpdateCompassIcon(const struct FCompassTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyUpdateCompassIcon");

	Params::FieldIndicatorUIObject_NotifyUpdateCompassIcon Parms{};

	Parms.InHandle = std::move(InHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.NotifyUpdateCompassMode
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::NotifyUpdateCompassMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "NotifyUpdateCompassMode");

	Params::FieldIndicatorUIObject_NotifyUpdateCompassMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.ShowPlaceName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InPlaceName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::ShowPlaceName(const class FText& InPlaceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "ShowPlaceName");

	Params::FieldIndicatorUIObject_ShowPlaceName Parms{};

	Parms.InPlaceName = std::move(InPlaceName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldIndicatorUIObject.IsEnableCompass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldIndicatorUIObject::IsEnableCompass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldIndicatorUIObject", "IsEnableCompass");

	Params::FieldIndicatorUIObject_IsEnableCompass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnBloodCodeNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnBloodCodeNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnBloodCodeNumberGetRequest");

	Params::FieldMenuTestActor_New_OnBloodCodeNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnBoosterNumberGetByCategoryRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterCategory                InBoosterCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnBoosterNumberGetByCategoryRequest(const EUIBoosterCategory InBoosterCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnBoosterNumberGetByCategoryRequest");

	Params::FieldMenuTestActor_New_OnBoosterNumberGetByCategoryRequest Parms{};

	Parms.InBoosterCategory = InBoosterCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnBoosterNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnBoosterNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnBoosterNumberGetRequest");

	Params::FieldMenuTestActor_New_OnBoosterNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnDefensiveGadgetNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnDefensiveGadgetNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnDefensiveGadgetNumberGetRequest");

	Params::FieldMenuTestActor_New_OnDefensiveGadgetNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipBloodCodeRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipBloodCodeRequest(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipBloodCodeRequest");

	Params::FieldMenuTestActor_New_OnEquipBloodCodeRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipBoosterByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutIsDuplicationEquip                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipBoosterByQueryRequest(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, bool* bOutIsDuplicationEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipBoosterByQueryRequest");

	Params::FieldMenuTestActor_New_OnEquipBoosterByQueryRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsDuplicationEquip != nullptr)
		*bOutIsDuplicationEquip = Parms.bOutIsDuplicationEquip;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipBoosterRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InBoosterIindex                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipBoosterRequest(const EUIBoosterSlot InSlot, const int32 InBoosterIindex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipBoosterRequest");

	Params::FieldMenuTestActor_New_OnEquipBoosterRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterIindex = InBoosterIindex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipDefensiveGadgetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipDefensiveGadgetRequest(const int32 InDefensiveGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipDefensiveGadgetRequest");

	Params::FieldMenuTestActor_New_OnEquipDefensiveGadgetRequest Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipIndependentGadgetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipIndependentGadgetRequest(const int32 InIndependentGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipIndependentGadgetRequest");

	Params::FieldMenuTestActor_New_OnEquipIndependentGadgetRequest Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipShortcutItemByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipShortcutItemByQueryRequest(const EUIItemShortcutSlot InSlot, const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipShortcutItemByQueryRequest");

	Params::FieldMenuTestActor_New_OnEquipShortcutItemByQueryRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipShortcutItemRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipShortcutItemRequest(const EUIItemShortcutSlot InSlot, const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipShortcutItemRequest");

	Params::FieldMenuTestActor_New_OnEquipShortcutItemRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipSuckingBloodRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InSuckingBloodID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipSuckingBloodRequest(const int32 InSuckingBloodID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipSuckingBloodRequest");

	Params::FieldMenuTestActor_New_OnEquipSuckingBloodRequest Parms{};

	Parms.InSuckingBloodID = InSuckingBloodID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipWeaponByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipWeaponByQueryRequest(const EUIWeaponSlot InSlot, const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipWeaponByQueryRequest");

	Params::FieldMenuTestActor_New_OnEquipWeaponByQueryRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnEquipWeaponRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnEquipWeaponRequest(const EUIWeaponSlot InSlot, const int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnEquipWeaponRequest");

	Params::FieldMenuTestActor_New_OnEquipWeaponRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnGetBloodCodeIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetBloodCodeIDByIndexRequest(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBloodCodeIDByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetBloodCodeIDByIndexRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetBloodCodeInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetBloodCodeInfoByIndexRequest(const int32 InBloodCodeIndex, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBloodCodeInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetBloodCodeInfoByIndexRequest Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetBloodCodeInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InBloodCodeID                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetBloodCodeInfoRequest(const class FName InBloodCodeID, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBloodCodeInfoRequest");

	Params::FieldMenuTestActor_New_OnGetBloodCodeInfoRequest Parms{};

	Parms.InBloodCodeID = InBloodCodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetBoosterIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetBoosterIDByIndexRequest(const int32 InBoosterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBoosterIDByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetBoosterIDByIndexRequest Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetBoosterIDByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetBoosterIDByQueryRequest(const struct FUIBoosterQueryInfo& InBoosterQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBoosterIDByQueryRequest");

	Params::FieldMenuTestActor_New_OnGetBoosterIDByQueryRequest Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetBoosterInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetBoosterInfoByIndexRequest(const int32 InBoosterIndex, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBoosterInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetBoosterInfoByIndexRequest Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetBoosterInfoByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetBoosterInfoByQueryRequest(const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBoosterInfoByQueryRequest");

	Params::FieldMenuTestActor_New_OnGetBoosterInfoByQueryRequest Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetBoosterInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InBoosterID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetBoosterInfoRequest(const class FName InBoosterID, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetBoosterInfoRequest");

	Params::FieldMenuTestActor_New_OnGetBoosterInfoRequest Parms{};

	Parms.InBoosterID = InBoosterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetDefensiveGadgetInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutDefensiveGadgetInfo                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetDefensiveGadgetInfoByIndexRequest(const int32 InDefensiveGadgetIndex, struct FUIDefensiveGadgetInfo* OutDefensiveGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetDefensiveGadgetInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetDefensiveGadgetInfoByIndexRequest Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefensiveGadgetInfo != nullptr)
		*OutDefensiveGadgetInfo = std::move(Parms.OutDefensiveGadgetInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InItemIndext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetEquippableItemIDByIndexRequest(const int32 InItemIndext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemIDByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemIDByIndexRequest Parms{};

	Parms.InItemIndext = InItemIndext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemIDByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetEquippableItemIDByQueryRequest(const struct FUIEquippableItemQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemIDByQueryRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemIDByQueryRequest Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetEquippableItemInfoByIndexRequest(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemInfoByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemInfoByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetEquippableItemInfoByQueryRequest(const struct FUIEquippableItemQueryInfo& InQuery, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemInfoByQueryRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemInfoByQueryRequest Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemNumberByCategoryRequest
// (Final, Native, Protected)
// Parameters:
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippableItemNumberByCategoryRequest(const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemNumberByCategoryRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemNumberByCategoryRequest Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippableItemNumberRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippableItemNumberRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippableItemNumberRequest");

	Params::FieldMenuTestActor_New_OnGetEquippableItemNumberRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedBloodCodeIDRequest
// (Final, Native, Protected)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetEquippedBloodCodeIDRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedBloodCodeIDRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedBloodCodeIDRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedBloodCodeIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedBloodCodeIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedBloodCodeIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedBloodCodeIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedBoosterIDRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetEquippedBoosterIDRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedBoosterIDRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedBoosterIDRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedBoosterIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedBoosterIndexRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedBoosterIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedBoosterIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedDefensiveGadgetIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedDefensiveGadgetIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedDefensiveGadgetIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedDefensiveGadgetIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedIndependentGadgetIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedIndependentGadgetIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedIndependentGadgetIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedIndependentGadgetIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedSuckingBloodIDRequest
// (Final, Native, Protected)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetEquippedSuckingBloodIDRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedSuckingBloodIDRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedSuckingBloodIDRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedSuckingBloodIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedSuckingBloodIndexRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedSuckingBloodIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedSuckingBloodIndexRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetEquippedWeaponIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetEquippedWeaponIndexRequest(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetEquippedWeaponIndexRequest");

	Params::FieldMenuTestActor_New_OnGetEquippedWeaponIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetIndependentGadgetInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutIndependentGadgetInfo                               (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetIndependentGadgetInfoByIndexRequest(const int32 InIndependentGadgetIndex, struct FUIIndependentGadgetInfo* OutIndependentGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetIndependentGadgetInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetIndependentGadgetInfoByIndexRequest Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndependentGadgetInfo != nullptr)
		*OutIndependentGadgetInfo = std::move(Parms.OutIndependentGadgetInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetItemIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetItemIDByIndexRequest(const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetItemIDByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetItemIDByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetItemInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetItemInfoByIndexRequest(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetItemInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetItemInfoByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetItemInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InItemName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetItemInfoRequest(const class FName InItemName, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetItemInfoRequest");

	Params::FieldMenuTestActor_New_OnGetItemInfoRequest Parms{};

	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetPlayerStatusInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FUIPlayerStatusInfo*             OutStatusInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetPlayerStatusInfoRequest(struct FUIPlayerStatusInfo* OutStatusInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetPlayerStatusInfoRequest");

	Params::FieldMenuTestActor_New_OnGetPlayerStatusInfoRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStatusInfo != nullptr)
		*OutStatusInfo = std::move(Parms.OutStatusInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetPlayerStatusSummaryInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetPlayerStatusSummaryInfoRequest(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetPlayerStatusSummaryInfoRequest");

	Params::FieldMenuTestActor_New_OnGetPlayerStatusSummaryInfoRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetShortcutItemIDRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetShortcutItemIDRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetShortcutItemIDRequest");

	Params::FieldMenuTestActor_New_OnGetShortcutItemIDRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetShortcutItemIndexRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnGetShortcutItemIndexRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetShortcutItemIndexRequest");

	Params::FieldMenuTestActor_New_OnGetShortcutItemIndexRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetSuckingBloodIDByIndexRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AFieldMenuTestActor_New::OnGetSuckingBloodIDByIndexRequest(const int32 InSuckingBloodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetSuckingBloodIDByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetSuckingBloodIDByIndexRequest Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnGetSuckingBloodInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetSuckingBloodInfoByIndexRequest(const int32 InSuckingBloodIndex, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetSuckingBloodInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetSuckingBloodInfoByIndexRequest Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetSuckingBloodInfoRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FName                       InSuckingBloodID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetSuckingBloodInfoRequest(const class FName InSuckingBloodID, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetSuckingBloodInfoRequest");

	Params::FieldMenuTestActor_New_OnGetSuckingBloodInfoRequest Parms{};

	Parms.InSuckingBloodID = InSuckingBloodID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetWeaponInfoByIndexRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetWeaponInfoByIndexRequest(const int32 InWeaponIndex, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetWeaponInfoByIndexRequest");

	Params::FieldMenuTestActor_New_OnGetWeaponInfoByIndexRequest Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnGetWeaponInfoByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnGetWeaponInfoByQueryRequest(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnGetWeaponInfoByQueryRequest");

	Params::FieldMenuTestActor_New_OnGetWeaponInfoByQueryRequest Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnIndependentGadgetNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnIndependentGadgetNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnIndependentGadgetNumberGetRequest");

	Params::FieldMenuTestActor_New_OnIndependentGadgetNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnItemNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnItemNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnItemNumberGetRequest");

	Params::FieldMenuTestActor_New_OnItemNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnRecentlyObtainedInfoGetByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIRecentlyObtainedInfo*         OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnRecentlyObtainedInfoGetByQueryRequest(const struct FUIArticleQueryInfo& InQuery, struct FUIRecentlyObtainedInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnRecentlyObtainedInfoGetByQueryRequest");

	Params::FieldMenuTestActor_New_OnRecentlyObtainedInfoGetByQueryRequest Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnRecentlyObtainedItemInfoGetByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnRecentlyObtainedItemInfoGetByQueryRequest(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnRecentlyObtainedItemInfoGetByQueryRequest");

	Params::FieldMenuTestActor_New_OnRecentlyObtainedItemInfoGetByQueryRequest Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnRecentlyObtainedNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnRecentlyObtainedNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnRecentlyObtainedNumberGetRequest");

	Params::FieldMenuTestActor_New_OnRecentlyObtainedNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnRecentlyObtainedWeaponInfoGetByQueryRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnRecentlyObtainedWeaponInfoGetByQueryRequest(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnRecentlyObtainedWeaponInfoGetByQueryRequest");

	Params::FieldMenuTestActor_New_OnRecentlyObtainedWeaponInfoGetByQueryRequest Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuTestActor_New.OnSaveDataGetRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISaveDataInfo*                 OutSaveData                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnSaveDataGetRequest(const int32 InIndex, struct FUISaveDataInfo* OutSaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnSaveDataGetRequest");

	Params::FieldMenuTestActor_New_OnSaveDataGetRequest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSaveData != nullptr)
		*OutSaveData = std::move(Parms.OutSaveData);
}


// Function Extensions.FieldMenuTestActor_New.OnSaveDataSelectRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnSaveDataSelectRequest(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnSaveDataSelectRequest");

	Params::FieldMenuTestActor_New_OnSaveDataSelectRequest Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnSuckingBloodNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnSuckingBloodNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnSuckingBloodNumberGetRequest");

	Params::FieldMenuTestActor_New_OnSuckingBloodNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipBoosterRequest
// (Final, Native, Protected)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnUnequipBoosterRequest(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipBoosterRequest");

	Params::FieldMenuTestActor_New_OnUnequipBoosterRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipDefensiveGadgetRequest
// (Final, Native, Protected)

void AFieldMenuTestActor_New::OnUnequipDefensiveGadgetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipDefensiveGadgetRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipIndependentGadgetRequest
// (Final, Native, Protected)

void AFieldMenuTestActor_New::OnUnequipIndependentGadgetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipIndependentGadgetRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipShortcutItemRequest
// (Final, Native, Protected)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnUnequipShortcutItemRequest(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipShortcutItemRequest");

	Params::FieldMenuTestActor_New_OnUnequipShortcutItemRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipSuckingBloodRequest
// (Final, Native, Protected)

void AFieldMenuTestActor_New::OnUnequipSuckingBloodRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipSuckingBloodRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnUnequipWeaponRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldMenuTestActor_New::OnUnequipWeaponRequest(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnUnequipWeaponRequest");

	Params::FieldMenuTestActor_New_OnUnequipWeaponRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuTestActor_New.OnWeaponNumberGetByCategoryRequest
// (Final, Native, Protected)
// Parameters:
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnWeaponNumberGetByCategoryRequest(const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnWeaponNumberGetByCategoryRequest");

	Params::FieldMenuTestActor_New_OnWeaponNumberGetByCategoryRequest Parms{};

	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuTestActor_New.OnWeaponNumberGetRequest
// (Final, Native, Protected)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AFieldMenuTestActor_New::OnWeaponNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuTestActor_New", "OnWeaponNumberGetRequest");

	Params::FieldMenuTestActor_New_OnWeaponNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.ChangeDefensiveGadgetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EDefensiveGadgetType              InDefensiveGadgetType                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::ChangeDefensiveGadgetType(const EDefensiveGadgetType InDefensiveGadgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "ChangeDefensiveGadgetType");

	Params::FieldMenuUIObject_ChangeDefensiveGadgetType Parms{};

	Parms.InDefensiveGadgetType = InDefensiveGadgetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.ChangeSuckingBloodType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ESuckingBloodType                 InSuckingBloodType                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::ChangeSuckingBloodType(const ESuckingBloodType InSuckingBloodType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "ChangeSuckingBloodType");

	Params::FieldMenuUIObject_ChangeSuckingBloodType Parms{};

	Parms.InSuckingBloodType = InSuckingBloodType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.ChangeWeaponType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EPlayerWeaponType                 InPlayerWeaponType                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::ChangeWeaponType(const EPlayerWeaponType InPlayerWeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "ChangeWeaponType");

	Params::FieldMenuUIObject_ChangeWeaponType Parms{};

	Parms.InPlayerWeaponType = InPlayerWeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.CreatePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UFieldMenuUIObject::CreatePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "CreatePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.DeletePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UFieldMenuUIObject::DeletePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DeletePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.DiscardBooster
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardBooster(const struct FUIBoosterQueryInfo& InBoosterQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardBooster");

	Params::FieldMenuUIObject_DiscardBooster Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardDefensiveGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardDefensiveGadget(const int32 InDefensiveGadgetIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardDefensiveGadget");

	Params::FieldMenuUIObject_DiscardDefensiveGadget Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardIndependentGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardIndependentGadget(const int32 InIndependentGadgetIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardIndependentGadget");

	Params::FieldMenuUIObject_DiscardIndependentGadget Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardItemByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIItemQueryInfo&          InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardItemByQuery(const struct FUIItemQueryInfo& InItemQuery, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardItemByQuery");

	Params::FieldMenuUIObject_DiscardItemByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.DiscardJail
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardJail(const int32 InJailIndex, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardJail");

	Params::FieldMenuUIObject_DiscardJail Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedBooster
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedBooster(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedBooster");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedBooster Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedDefensiveGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedDefensiveGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedDefensiveGadget");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedDefensiveGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedIndependentGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedIndependentGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedIndependentGadget");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedIndependentGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedItem");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedJail
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutUnequipped                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedJail(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutUnequipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedJail");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedJail Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUnequipped != nullptr)
		*bOutUnequipped = Parms.bOutUnequipped;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutRemovedFromEquip                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedWeapon(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutRemovedFromEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedWeapon");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedWeapon Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutRemovedFromEquip != nullptr)
		*bOutRemovedFromEquip = Parms.bOutRemovedFromEquip;
}


// Function Extensions.FieldMenuUIObject.DiscardRecentlyObtainedWeaponGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutRemovedFromEquip                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardRecentlyObtainedWeaponGadget(const struct FUIRecentlyObtainedQueryInfo& InQuery, bool* bOutRemovedFromEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardRecentlyObtainedWeaponGadget");

	Params::FieldMenuUIObject_DiscardRecentlyObtainedWeaponGadget Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutRemovedFromEquip != nullptr)
		*bOutRemovedFromEquip = Parms.bOutRemovedFromEquip;
}


// Function Extensions.FieldMenuUIObject.DiscardWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutRemovedFromEquip                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardWeapon(const struct FUIWeaponQueryInfo& InWeaponQuery, bool* bOutRemovedFromEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardWeapon");

	Params::FieldMenuUIObject_DiscardWeapon Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutRemovedFromEquip != nullptr)
		*bOutRemovedFromEquip = Parms.bOutRemovedFromEquip;
}


// Function Extensions.FieldMenuUIObject.DiscardWeaponGadgetByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutRemovedFromEquip                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::DiscardWeaponGadgetByQuery(const struct FUIWeaponGadgetQueryInfo& InQuery, bool* bOutRemovedFromEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "DiscardWeaponGadgetByQuery");

	Params::FieldMenuUIObject_DiscardWeaponGadgetByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutRemovedFromEquip != nullptr)
		*bOutRemovedFromEquip = Parms.bOutRemovedFromEquip;
}


// Function Extensions.FieldMenuUIObject.EquipBloodCode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipBloodCode(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipBloodCode");

	Params::FieldMenuUIObject_EquipBloodCode Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipBooster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipBooster(const EUIBoosterSlot InSlot, const int32 InBoosterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipBooster");

	Params::FieldMenuUIObject_EquipBooster Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipBoosterByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutIsDuplicationEquip                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipBoosterByQuery(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, bool* bOutIsDuplicationEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipBoosterByQuery");

	Params::FieldMenuUIObject_EquipBoosterByQuery Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsDuplicationEquip != nullptr)
		*bOutIsDuplicationEquip = Parms.bOutIsDuplicationEquip;
}


// Function Extensions.FieldMenuUIObject.EquipDefensiveGadget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipDefensiveGadget(const int32 InDefensiveGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipDefensiveGadget");

	Params::FieldMenuUIObject_EquipDefensiveGadget Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipIndependentGadget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipIndependentGadget(const int32 InIndependentGadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipIndependentGadget");

	Params::FieldMenuUIObject_EquipIndependentGadget Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipJail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipJail(const int32 InJailIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipJail");

	Params::FieldMenuUIObject_EquipJail Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipShortcutItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipShortcutItem(const EUIItemShortcutSlot InSlot, const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipShortcutItem");

	Params::FieldMenuUIObject_EquipShortcutItem Parms{};

	Parms.InSlot = InSlot;
	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipShortcutItemByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipShortcutItemByQuery(const EUIItemShortcutSlot InSlot, const struct FUIEquippableItemQueryInfo& InItemQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipShortcutItemByQuery");

	Params::FieldMenuUIObject_EquipShortcutItemByQuery Parms{};

	Parms.InSlot = InSlot;
	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipSuckingBlood
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipSuckingBlood(const int32 InSuckingBloodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipSuckingBlood");

	Params::FieldMenuUIObject_EquipSuckingBlood Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipWeapon(const EUIWeaponSlot InSlot, const int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipWeapon");

	Params::FieldMenuUIObject_EquipWeapon Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.EquipWeaponByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::EquipWeaponByQuery(const EUIWeaponSlot InSlot, const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "EquipWeaponByQuery");

	Params::FieldMenuUIObject_EquipWeaponByQuery Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.GetBloodCodeIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetBloodCodeIDByIndex(const int32 InBloodCodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBloodCodeIDByIndex");

	Params::FieldMenuUIObject_GetBloodCodeIDByIndex Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetBloodCodeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InBloodCodeID                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetBloodCodeInfo(const class FName InBloodCodeID, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBloodCodeInfo");

	Params::FieldMenuUIObject_GetBloodCodeInfo Parms{};

	Parms.InBloodCodeID = InBloodCodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuUIObject.GetBloodCodeInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutBloodCodeInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetBloodCodeInfoByIndex(const int32 InBloodCodeIndex, struct FUIBloodCodeInfo* OutBloodCodeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBloodCodeInfoByIndex");

	Params::FieldMenuUIObject_GetBloodCodeInfoByIndex Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBloodCodeInfo != nullptr)
		*OutBloodCodeInfo = std::move(Parms.OutBloodCodeInfo);
}


// Function Extensions.FieldMenuUIObject.GetBloodCodeNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetBloodCodeNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBloodCodeNumber");

	Params::FieldMenuUIObject_GetBloodCodeNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetBoosterIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetBoosterIDByIndex(const int32 InBoosterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterIDByIndex");

	Params::FieldMenuUIObject_GetBoosterIDByIndex Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetBoosterIDByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetBoosterIDByQuery(const struct FUIBoosterQueryInfo& InBoosterQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterIDByQuery");

	Params::FieldMenuUIObject_GetBoosterIDByQuery Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetBoosterInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InBoosterID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetBoosterInfo(const class FName InBoosterID, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterInfo");

	Params::FieldMenuUIObject_GetBoosterInfo Parms{};

	Parms.InBoosterID = InBoosterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuUIObject.GetBoosterInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InBoosterIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetBoosterInfoByIndex(const int32 InBoosterIndex, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterInfoByIndex");

	Params::FieldMenuUIObject_GetBoosterInfoByIndex Parms{};

	Parms.InBoosterIndex = InBoosterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuUIObject.GetBoosterInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutBoosterInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetBoosterInfoByQuery(const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUIBoosterInfo* OutBoosterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterInfoByQuery");

	Params::FieldMenuUIObject_GetBoosterInfoByQuery Parms{};

	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoosterInfo != nullptr)
		*OutBoosterInfo = std::move(Parms.OutBoosterInfo);
}


// Function Extensions.FieldMenuUIObject.GetBoosterNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetBoosterNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterNumber");

	Params::FieldMenuUIObject_GetBoosterNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetBoosterNumberByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterCategory                InBoosterCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetBoosterNumberByCategory(const EUIBoosterCategory InBoosterCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetBoosterNumberByCategory");

	Params::FieldMenuUIObject_GetBoosterNumberByCategory Parms{};

	Parms.InBoosterCategory = InBoosterCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetDefensiveGadgetInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InDefensiveGadgetIndex                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutDefensiveGadgetInfo                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetDefensiveGadgetInfoByIndex(const int32 InDefensiveGadgetIndex, struct FUIDefensiveGadgetInfo* OutDefensiveGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetDefensiveGadgetInfoByIndex");

	Params::FieldMenuUIObject_GetDefensiveGadgetInfoByIndex Parms{};

	Parms.InDefensiveGadgetIndex = InDefensiveGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefensiveGadgetInfo != nullptr)
		*OutDefensiveGadgetInfo = std::move(Parms.OutDefensiveGadgetInfo);
}


// Function Extensions.FieldMenuUIObject.GetDefensiveGadgetNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetDefensiveGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetDefensiveGadgetNumber");

	Params::FieldMenuUIObject_GetDefensiveGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippableItemIDByIndex(const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemIDByIndex");

	Params::FieldMenuUIObject_GetEquippableItemIDByIndex Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemIDByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippableItemIDByQuery(const struct FUIEquippableItemQueryInfo& InItemQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemIDByQuery");

	Params::FieldMenuUIObject_GetEquippableItemIDByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetEquippableItemInfoByIndex(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemInfoByIndex");

	Params::FieldMenuUIObject_GetEquippableItemInfoByIndex Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetEquippableItemInfoByQuery(const struct FUIEquippableItemQueryInfo& InItemQuery, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemInfoByQuery");

	Params::FieldMenuUIObject_GetEquippableItemInfoByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippableItemNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemNumber");

	Params::FieldMenuUIObject_GetEquippableItemNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippableItemNumberByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIExpendableItemCategory         InExpendableCategory                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippableItemNumberByCategory(const EUIExpendableItemCategory InExpendableCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippableItemNumberByCategory");

	Params::FieldMenuUIObject_GetEquippableItemNumberByCategory Parms{};

	Parms.InExpendableCategory = InExpendableCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedBloodCodeID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippedBloodCodeID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedBloodCodeID");

	Params::FieldMenuUIObject_GetEquippedBloodCodeID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedBloodCodeIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedBloodCodeIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedBloodCodeIndex");

	Params::FieldMenuUIObject_GetEquippedBloodCodeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedBoosterID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippedBoosterID(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedBoosterID");

	Params::FieldMenuUIObject_GetEquippedBoosterID Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedBoosterIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedBoosterIndex(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedBoosterIndex");

	Params::FieldMenuUIObject_GetEquippedBoosterIndex Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedBoosterIndexByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIBoosterCategory                InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedBoosterIndexByCategory(const EUIBoosterSlot InSlot, const EUIBoosterCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedBoosterIndexByCategory");

	Params::FieldMenuUIObject_GetEquippedBoosterIndexByCategory Parms{};

	Parms.InSlot = InSlot;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedDefensiveGadgetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedDefensiveGadgetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedDefensiveGadgetIndex");

	Params::FieldMenuUIObject_GetEquippedDefensiveGadgetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedIndependentGadgetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedIndependentGadgetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedIndependentGadgetIndex");

	Params::FieldMenuUIObject_GetEquippedIndependentGadgetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedJailID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippedJailID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedJailID");

	Params::FieldMenuUIObject_GetEquippedJailID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedJailIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedJailIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedJailIndex");

	Params::FieldMenuUIObject_GetEquippedJailIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedShortcutItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippedShortcutItemID(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedShortcutItemID");

	Params::FieldMenuUIObject_GetEquippedShortcutItemID Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedShortcutItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedShortcutItemIndex(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedShortcutItemIndex");

	Params::FieldMenuUIObject_GetEquippedShortcutItemIndex Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedShortcutItemIndexByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIExpendableItemCategory         InExpendableCategory                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedShortcutItemIndexByCategory(const EUIItemShortcutSlot InSlot, const EUIExpendableItemCategory InExpendableCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedShortcutItemIndexByCategory");

	Params::FieldMenuUIObject_GetEquippedShortcutItemIndexByCategory Parms{};

	Parms.InSlot = InSlot;
	Parms.InExpendableCategory = InExpendableCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedSuckingBloodID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetEquippedSuckingBloodID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedSuckingBloodID");

	Params::FieldMenuUIObject_GetEquippedSuckingBloodID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedSuckingBloodIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedSuckingBloodIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedSuckingBloodIndex");

	Params::FieldMenuUIObject_GetEquippedSuckingBloodIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedWeaponIndex(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedWeaponIndex");

	Params::FieldMenuUIObject_GetEquippedWeaponIndex Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetEquippedWeaponIndexByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetEquippedWeaponIndexByCategory(const EUIWeaponSlot InSlot, const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetEquippedWeaponIndexByCategory");

	Params::FieldMenuUIObject_GetEquippedWeaponIndexByCategory Parms{};

	Parms.InSlot = InSlot;
	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetIndependentGadgetInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndependentGadgetIndex                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutIndependentGadgetInfo                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetIndependentGadgetInfoByIndex(const int32 InIndependentGadgetIndex, struct FUIIndependentGadgetInfo* OutIndependentGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetIndependentGadgetInfoByIndex");

	Params::FieldMenuUIObject_GetIndependentGadgetInfoByIndex Parms{};

	Parms.InIndependentGadgetIndex = InIndependentGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndependentGadgetInfo != nullptr)
		*OutIndependentGadgetInfo = std::move(Parms.OutIndependentGadgetInfo);
}


// Function Extensions.FieldMenuUIObject.GetIndependentGadgetNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetIndependentGadgetNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetIndependentGadgetNumber");

	Params::FieldMenuUIObject_GetIndependentGadgetNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetItemIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetItemIDByIndex(const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemIDByIndex");

	Params::FieldMenuUIObject_GetItemIDByIndex Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetItemIDByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIItemQueryInfo&          InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetItemIDByQuery(const struct FUIItemQueryInfo& InItemQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemIDByQuery");

	Params::FieldMenuUIObject_GetItemIDByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetItemInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InItemID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetItemInfo(const class FName InItemID, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemInfo");

	Params::FieldMenuUIObject_GetItemInfo Parms{};

	Parms.InItemID = InItemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuUIObject.GetItemInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetItemInfoByIndex(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemInfoByIndex");

	Params::FieldMenuUIObject_GetItemInfoByIndex Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuUIObject.GetItemInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIItemQueryInfo&          InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetItemInfoByQuery(const struct FUIItemQueryInfo& InItemQuery, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemInfoByQuery");

	Params::FieldMenuUIObject_GetItemInfoByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.FieldMenuUIObject.GetItemNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetItemNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemNumber");

	Params::FieldMenuUIObject_GetItemNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetItemNumberByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIItemCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetItemNumberByCategory(const EUIItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetItemNumberByCategory");

	Params::FieldMenuUIObject_GetItemNumberByCategory Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetJailIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetJailIDByIndex(const int32 InJailIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetJailIDByIndex");

	Params::FieldMenuUIObject_GetJailIDByIndex Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetJailInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InJailID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutJailInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetJailInfo(const class FName InJailID, struct FUIJailInfo* OutJailInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetJailInfo");

	Params::FieldMenuUIObject_GetJailInfo Parms{};

	Parms.InJailID = InJailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJailInfo != nullptr)
		*OutJailInfo = std::move(Parms.OutJailInfo);
}


// Function Extensions.FieldMenuUIObject.GetJailInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutJailInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetJailInfoByIndex(const int32 InJailIndex, struct FUIJailInfo* OutJailInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetJailInfoByIndex");

	Params::FieldMenuUIObject_GetJailInfoByIndex Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJailInfo != nullptr)
		*OutJailInfo = std::move(Parms.OutJailInfo);
}


// Function Extensions.FieldMenuUIObject.GetJailNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetJailNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetJailNumber");

	Params::FieldMenuUIObject_GetJailNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusFieldMenuInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusFieldMenuInfo*    OutStatusInfo                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusFieldMenuInfo(struct FUIPlayerStatusFieldMenuInfo* OutStatusInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusFieldMenuInfo");

	Params::FieldMenuUIObject_GetPlayerStatusFieldMenuInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStatusInfo != nullptr)
		*OutStatusInfo = std::move(Parms.OutStatusInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusInfo*             OutStatusInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusInfo(struct FUIPlayerStatusInfo* OutStatusInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusInfo");

	Params::FieldMenuUIObject_GetPlayerStatusInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStatusInfo != nullptr)
		*OutStatusInfo = std::move(Parms.OutStatusInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfo");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithBloodCode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InBloodCodeIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithBloodCode(const int32 InBloodCodeIndex, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithBloodCode");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithBloodCode Parms{};

	Parms.InBloodCodeIndex = InBloodCodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithBooster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InBoosterSlot                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithBooster(const EUIBoosterSlot InBoosterSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithBooster");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithBooster Parms{};

	Parms.InBoosterSlot = InBoosterSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithDefensiveGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InGadgetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithDefensiveGadget(const int32 InGadgetIndex, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithDefensiveGadget");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithDefensiveGadget Parms{};

	Parms.InGadgetIndex = InGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithIndependentGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InGadgetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithIndependentGadget(const int32 InGadgetIndex, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithIndependentGadget");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithIndependentGadget Parms{};

	Parms.InGadgetIndex = InGadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithJail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InJailIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithJail(const int32 InJailIndex, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithJail");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithJail Parms{};

	Parms.InJailIndex = InJailIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetPlayerStatusSummaryInfoWithWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetPlayerStatusSummaryInfoWithWeapon(const EUIWeaponSlot InWeaponSlot, const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetPlayerStatusSummaryInfoWithWeapon");

	Params::FieldMenuUIObject_GetPlayerStatusSummaryInfoWithWeapon Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedBloodCodeInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedBloodCodeInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIBloodCodeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedBloodCodeInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedBloodCodeInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedBoosterInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedBoosterInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedBoosterInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedBoosterInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedDefensiveGadgetInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedDefensiveGadgetInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedDefensiveGadgetInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedDefensiveGadgetInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedIndependentGadgetInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedIndependentGadgetInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedIndependentGadgetInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedIndependentGadgetInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIRecentlyObtainedInfo*         OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedInfoByQuery(const struct FUIArticleQueryInfo& InQuery, struct FUIRecentlyObtainedInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedItemInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedItemInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedItemInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedItemInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedJailInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedJailInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedJailInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedJailInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetRecentlyObtainedNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedNumber");

	Params::FieldMenuUIObject_GetRecentlyObtainedNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedWeaponGadgetInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedWeaponGadgetInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedWeaponGadgetInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedWeaponGadgetInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetRecentlyObtainedWeaponInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetRecentlyObtainedWeaponInfoByQuery(const struct FUIRecentlyObtainedQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetRecentlyObtainedWeaponInfoByQuery");

	Params::FieldMenuUIObject_GetRecentlyObtainedWeaponInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffList(struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffList");

	Params::FieldMenuUIObject_GetSpecialBuffList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithBloodCode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithBloodCode(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithBloodCode");

	Params::FieldMenuUIObject_GetSpecialBuffListWithBloodCode Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithBooster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithBooster(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithBooster");

	Params::FieldMenuUIObject_GetSpecialBuffListWithBooster Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithDefensiveGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithDefensiveGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithDefensiveGadget");

	Params::FieldMenuUIObject_GetSpecialBuffListWithDefensiveGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithIndependentGadget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithIndependentGadget(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithIndependentGadget");

	Params::FieldMenuUIObject_GetSpecialBuffListWithIndependentGadget Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithJail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithJail(const int32 InIndex, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithJail");

	Params::FieldMenuUIObject_GetSpecialBuffListWithJail Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSpecialBuffListWithWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InWeaponQueryInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSpecialBuffListWithWeapon(const EUIWeaponSlot InWeaponSlot, const struct FUIWeaponQueryInfo& InWeaponQueryInfo, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSpecialBuffListWithWeapon");

	Params::FieldMenuUIObject_GetSpecialBuffListWithWeapon Parms{};

	Parms.InWeaponSlot = InWeaponSlot;
	Parms.InWeaponQueryInfo = std::move(InWeaponQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.FieldMenuUIObject.GetSuckingBloodIDByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldMenuUIObject::GetSuckingBloodIDByIndex(const int32 InSuckingBloodIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSuckingBloodIDByIndex");

	Params::FieldMenuUIObject_GetSuckingBloodIDByIndex Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetSuckingBloodInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InSuckingBloodID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSuckingBloodInfo(const class FName InSuckingBloodID, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSuckingBloodInfo");

	Params::FieldMenuUIObject_GetSuckingBloodInfo Parms{};

	Parms.InSuckingBloodID = InSuckingBloodID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuUIObject.GetSuckingBloodInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InSuckingBloodIndex                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISuckingBloodInfo*             OutSuckingBloodInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetSuckingBloodInfoByIndex(const int32 InSuckingBloodIndex, struct FUISuckingBloodInfo* OutSuckingBloodInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSuckingBloodInfoByIndex");

	Params::FieldMenuUIObject_GetSuckingBloodInfoByIndex Parms{};

	Parms.InSuckingBloodIndex = InSuckingBloodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuckingBloodInfo != nullptr)
		*OutSuckingBloodInfo = std::move(Parms.OutSuckingBloodInfo);
}


// Function Extensions.FieldMenuUIObject.GetSuckingBloodNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetSuckingBloodNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSuckingBloodNumber");

	Params::FieldMenuUIObject_GetSuckingBloodNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetWeaponGadgetInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponGadgetQueryInfo&  InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutWeaponGadgetInfo                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetWeaponGadgetInfoByQuery(const struct FUIWeaponGadgetQueryInfo& InQuery, struct FUIWeaponGadgetInfo* OutWeaponGadgetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponGadgetInfoByQuery");

	Params::FieldMenuUIObject_GetWeaponGadgetInfoByQuery Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponGadgetInfo != nullptr)
		*OutWeaponGadgetInfo = std::move(Parms.OutWeaponGadgetInfo);
}


// Function Extensions.FieldMenuUIObject.GetWeaponGadgetNumberByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetCategory           InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetWeaponGadgetNumberByQuery(const struct FUIWeaponQueryInfo& InQuery, const EUIWeaponGadgetCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponGadgetNumberByQuery");

	Params::FieldMenuUIObject_GetWeaponGadgetNumberByQuery Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetWeaponInfoByIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InWeaponIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetWeaponInfoByIndex(const int32 InWeaponIndex, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponInfoByIndex");

	Params::FieldMenuUIObject_GetWeaponInfoByIndex Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.FieldMenuUIObject.GetWeaponInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutWeaponInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::GetWeaponInfoByQuery(const struct FUIWeaponQueryInfo& InWeaponQuery, struct FUIWeaponInfo* OutWeaponInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponInfoByQuery");

	Params::FieldMenuUIObject_GetWeaponInfoByQuery Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWeaponInfo != nullptr)
		*OutWeaponInfo = std::move(Parms.OutWeaponInfo);
}


// Function Extensions.FieldMenuUIObject.GetWeaponNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetWeaponNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponNumber");

	Params::FieldMenuUIObject_GetWeaponNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetWeaponNumberByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIWeaponCategory                 InWeaponCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UFieldMenuUIObject::GetWeaponNumberByCategory(const EUIWeaponCategory InWeaponCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponNumberByCategory");

	Params::FieldMenuUIObject_GetWeaponNumberByCategory Parms{};

	Parms.InWeaponCategory = InWeaponCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.HasDelegatesProperlyBound
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::HasDelegatesProperlyBound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "HasDelegatesProperlyBound");

	Params::FieldMenuUIObject_HasDelegatesProperlyBound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsEquipmentEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsEquipmentEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsEquipmentEnabled");

	Params::FieldMenuUIObject_IsEquipmentEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsUnlockBooster5Slot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsUnlockBooster5Slot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsUnlockBooster5Slot");

	Params::FieldMenuUIObject_IsUnlockBooster5Slot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsUnlockBooster6Slot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsUnlockBooster6Slot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsUnlockBooster6Slot");

	Params::FieldMenuUIObject_IsUnlockBooster6Slot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsUnlockWeapon2Slot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsUnlockWeapon2Slot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsUnlockWeapon2Slot");

	Params::FieldMenuUIObject_IsUnlockWeapon2Slot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsUsableItemByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIItemQueryInfo&          InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsUsableItemByQuery(const struct FUIItemQueryInfo& InItemQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsUsableItemByQuery");

	Params::FieldMenuUIObject_IsUsableItemByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.IsUsableRecentlyObtainedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::IsUsableRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "IsUsableRecentlyObtainedItem");

	Params::FieldMenuUIObject_IsUsableRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.NotifyEquipmentEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::NotifyEquipmentEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyEquipmentEnabled");

	Params::FieldMenuUIObject_NotifyEquipmentEnabled Parms{};

	Parms.InEnabled = InEnabled;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.NotifyItemShortcutUIClose
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::NotifyItemShortcutUIClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyItemShortcutUIClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.NotifyItemShortcutUIOpen
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::NotifyItemShortcutUIOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyItemShortcutUIOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.NotifyPlayerHealthUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// const float                             InCurrentHealth                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::NotifyPlayerHealthUpdated(const float InCurrentHealth, const float InMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyPlayerHealthUpdated");

	Params::FieldMenuUIObject_NotifyPlayerHealthUpdated Parms{};

	Parms.InCurrentHealth = InCurrentHealth;
	Parms.InMaxHealth = InMaxHealth;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.NotifyPlayerStaminaUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             InCurrentStamina                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InMaxStamina                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::NotifyPlayerStaminaUpdated(const int32 InCurrentStamina, const int32 InMaxStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyPlayerStaminaUpdated");

	Params::FieldMenuUIObject_NotifyPlayerStaminaUpdated Parms{};

	Parms.InCurrentStamina = InCurrentStamina;
	Parms.InMaxStamina = InMaxStamina;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.NotifyPlayerStatusUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::NotifyPlayerStatusUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "NotifyPlayerStatusUpdated");

	Params::FieldMenuUIObject_NotifyPlayerStatusUpdated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.RequestStartPhotoMode
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::RequestStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "RequestStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipBooster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::UnequipBooster(const EUIBoosterSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipBooster");

	Params::FieldMenuUIObject_UnequipBooster Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipDefensiveGadget
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::UnequipDefensiveGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipDefensiveGadget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipIndependentGadget
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::UnequipIndependentGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipIndependentGadget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipJail
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::UnequipJail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipJail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipShortcutItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIItemShortcutSlot               InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::UnequipShortcutItem(const EUIItemShortcutSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipShortcutItem");

	Params::FieldMenuUIObject_UnequipShortcutItem Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipSuckingBlood
// (Final, Native, Public, BlueprintCallable)

void UFieldMenuUIObject::UnequipSuckingBlood()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipSuckingBlood");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UnequipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldMenuUIObject::UnequipWeapon(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UnequipWeapon");

	Params::FieldMenuUIObject_UnequipWeapon Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldMenuUIObject.UseItemByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::UseItemByIndex(const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UseItemByIndex");

	Params::FieldMenuUIObject_UseItemByIndex Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.UseItemByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIItemQueryInfo&          InItemQuery                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::UseItemByQuery(const struct FUIItemQueryInfo& InItemQuery, int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UseItemByQuery");

	Params::FieldMenuUIObject_UseItemByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.UseRecentlyObtainedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUIRecentlyObtainedQueryInfo&InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldMenuUIObject::UseRecentlyObtainedItem(const struct FUIRecentlyObtainedQueryInfo& InQuery, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "UseRecentlyObtainedItem");

	Params::FieldMenuUIObject_UseRecentlyObtainedItem Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetDefensiveGadgetType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EDefensiveGadgetType              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EDefensiveGadgetType UFieldMenuUIObject::GetDefensiveGadgetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetDefensiveGadgetType");

	Params::FieldMenuUIObject_GetDefensiveGadgetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetSuckingBloodType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESuckingBloodType                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ESuckingBloodType UFieldMenuUIObject::GetSuckingBloodType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetSuckingBloodType");

	Params::FieldMenuUIObject_GetSuckingBloodType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldMenuUIObject.GetWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EPlayerWeaponType                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EPlayerWeaponType UFieldMenuUIObject::GetWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldMenuUIObject", "GetWeaponType");

	Params::FieldMenuUIObject_GetWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FieldNPCCharacter.OnChangeActive
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldNPCCharacter::OnChangeActive(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldNPCCharacter", "OnChangeActive");

	Params::FieldNPCCharacter_OnChangeActive Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldNPCCharacter.OnChangeBattleState
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldNPCCharacter::OnChangeBattleState(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldNPCCharacter", "OnChangeBattleState");

	Params::FieldNPCCharacter_OnChangeBattleState Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FieldNPCCharacter.SetCharacterLabel
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             CharacterLabelName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFieldNPCCharacter::SetCharacterLabel(class FName CharacterLabelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldNPCCharacter", "SetCharacterLabel");

	Params::FieldNPCCharacter_SetCharacterLabel Parms{};

	Parms.CharacterLabelName = CharacterLabelName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.FieldNPCCharacter.SetFieldNPCParameterID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldNPCCharacter::SetFieldNPCParameterID(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldNPCCharacter", "SetFieldNPCParameterID");

	Params::FieldNPCCharacter_SetFieldNPCParameterID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FloatingSkeletalMeshComponent.OnWeaponHitGround
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFloatingSkeletalMeshComponent::OnWeaponHitGround(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloatingSkeletalMeshComponent", "OnWeaponHitGround");

	Params::FloatingSkeletalMeshComponent_OnWeaponHitGround Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FurnitureInterface.GetInteractionIKAlphaInterpSpeed
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IFurnitureInterface::GetInteractionIKAlphaInterpSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FurnitureInterface", "GetInteractionIKAlphaInterpSpeed");

	Params::FurnitureInterface_GetInteractionIKAlphaInterpSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FurnitureUIObject.GetFurnitureLeaveType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIFurnitureLeaveType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIFurnitureLeaveType UFurnitureUIObject::GetFurnitureLeaveType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FurnitureUIObject", "GetFurnitureLeaveType");

	Params::FurnitureUIObject_GetFurnitureLeaveType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.FurnitureUIObject.TriggerChangePerspective
// (Final, Native, Public, BlueprintCallable)

void UFurnitureUIObject::TriggerChangePerspective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FurnitureUIObject", "TriggerChangePerspective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.FurnitureUIObject.TriggerLeaveFurniture
// (Final, Native, Public, BlueprintCallable)

void UFurnitureUIObject::TriggerLeaveFurniture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FurnitureUIObject", "TriggerLeaveFurniture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.EndDisapperEffectThisMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGadgetBase::EndDisapperEffectThisMesh(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "EndDisapperEffectThisMesh");

	Params::GadgetBase_EndDisapperEffectThisMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.EndPhysicsSimulation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGadgetBase::EndPhysicsSimulation(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "EndPhysicsSimulation");

	Params::GadgetBase_EndPhysicsSimulation Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.GadgetCancel
// (Native, Protected, BlueprintCallable)

void AGadgetBase::GadgetCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "GadgetCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.GetGadgetSubMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AGadgetBase::GetGadgetSubMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "GetGadgetSubMesh");

	Params::GadgetBase_GetGadgetSubMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.HasDisapperEffectThisMesh
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::HasDisapperEffectThisMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "HasDisapperEffectThisMesh");

	Params::GadgetBase_HasDisapperEffectThisMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnGadgetEffectBegin
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnGadgetEffectBegin(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnGadgetEffectBegin");

	Params::GadgetBase_OnGadgetEffectBegin Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnGadgetEffectEnd
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnGadgetEffectEnd(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnGadgetEffectEnd");

	Params::GadgetBase_OnGadgetEffectEnd Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnGadgetEffectTick
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGadgetEffect_Parameter&   InParameter                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnGadgetEffectTick(class USkeletalMeshComponent* InMesh, const struct FGadgetEffect_Parameter& InParameter, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnGadgetEffectTick");

	Params::GadgetBase_OnGadgetEffectTick Parms{};

	Parms.InMesh = InMesh;
	Parms.InParameter = std::move(InParameter);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnGetGadgetTrailMesh
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AGadgetBase::OnGetGadgetTrailMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnGetGadgetTrailMesh");

	Params::GadgetBase_OnGetGadgetTrailMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnRep_GadgetMeshState
// (Final, Native, Protected)

void AGadgetBase::OnRep_GadgetMeshState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnRep_GadgetMeshState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.OnRep_GadgetState
// (Final, Native, Protected)

void AGadgetBase::OnRep_GadgetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnRep_GadgetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GadgetBase.OnSimpleAnimNotify_Begin
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnSimpleAnimNotify_Begin(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InTotalDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnSimpleAnimNotify_Begin");

	Params::GadgetBase_OnSimpleAnimNotify_Begin Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InTotalDuration = InTotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnSimpleAnimNotify_End
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnSimpleAnimNotify_End(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnSimpleAnimNotify_End");

	Params::GadgetBase_OnSimpleAnimNotify_End Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.OnSimpleAnimNotify_Tick
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UObject*                          InAnimNotifyObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGadgetBase::OnSimpleAnimNotify_Tick(class UObject* InAnimNotifyObject, class UAnimSequenceBase* InAnimSequence, const class FName& InMessage, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "OnSimpleAnimNotify_Tick");

	Params::GadgetBase_OnSimpleAnimNotify_Tick Parms{};

	Parms.InAnimNotifyObject = InAnimNotifyObject;
	Parms.InAnimSequence = InAnimSequence;
	Parms.InMessage = InMessage;
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.ReceiveAppear
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGadgetBase::ReceiveAppear(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "ReceiveAppear");

	Params::GadgetBase_ReceiveAppear Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.GadgetBase.ReceiveDetach
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           ImMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGadgetBase::ReceiveDetach(class USkeletalMeshComponent* ImMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "ReceiveDetach");

	Params::GadgetBase_ReceiveDetach Parms{};

	Parms.ImMesh = ImMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.GadgetBase.ReceiveDisapper
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGadgetBase::ReceiveDisapper(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "ReceiveDisapper");

	Params::GadgetBase_ReceiveDisapper Parms{};

	Parms.InMesh = InMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.GadgetBase.ReceiveSetUp
// (Event, Protected, BlueprintEvent)

void AGadgetBase::ReceiveSetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "ReceiveSetUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.GadgetBase.GetGadgetMainMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AGadgetBase::GetGadgetMainMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "GetGadgetMainMesh");

	Params::GadgetBase_GetGadgetMainMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.GetGadgetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGadgetStateType                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EGadgetStateType AGadgetBase::GetGadgetState(class USkeletalMeshComponent* InMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "GetGadgetState");

	Params::GadgetBase_GetGadgetState Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GadgetBase.GetOwnerParentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AGadgetBase::GetOwnerParentComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GadgetBase", "GetOwnerParentComponent");

	Params::GadgetBase_GetOwnerParentComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemFunctionLibrary.GetStreamingLevelNameFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameSystemFunctionLibrary::GetStreamingLevelNameFromActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSystemFunctionLibrary", "GetStreamingLevelNameFromActor");

	Params::GameSystemFunctionLibrary_GetStreamingLevelNameFromActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemFunctionLibrary.GetTimePassedByPauseType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InGameTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPauseType                              InPauseType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSystemFunctionLibrary::GetTimePassedByPauseType(const class UObject* InWorldContext, float InGameTime, EPauseType InPauseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSystemFunctionLibrary", "GetTimePassedByPauseType");

	Params::GameSystemFunctionLibrary_GetTimePassedByPauseType Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InGameTime = InGameTime;
	Parms.InPauseType = InPauseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GameSystemFunctionLibrary.GetTimeSecondsByPauseType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPauseType                              InPauseType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSystemFunctionLibrary::GetTimeSecondsByPauseType(const class UObject* InWorldContext, EPauseType InPauseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSystemFunctionLibrary", "GetTimeSecondsByPauseType");

	Params::GameSystemFunctionLibrary_GetTimeSecondsByPauseType Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InPauseType = InPauseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GA_Land.IsStandingByEdge
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_Land::IsStandingByEdge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Land", "IsStandingByEdge");

	Params::GA_Land_IsStandingByEdge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.GCN_StatusEffect_Burst.MakeRotationIndependent_Application
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FGameplayCueNotify_SpawnResult&  InSpawnResult                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGCN_StatusEffect_Burst::MakeRotationIndependent_Application(struct FGameplayCueNotify_SpawnResult& InSpawnResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GCN_StatusEffect_Burst", "MakeRotationIndependent_Application");

	Params::GCN_StatusEffect_Burst_MakeRotationIndependent_Application Parms{};

	Parms.InSpawnResult = std::move(InSpawnResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InSpawnResult = std::move(Parms.InSpawnResult);
}


// Function Extensions.GCN_StatusEffect_Burst.PostAudioEvents_Application
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGCN_StatusEffect_Burst::PostAudioEvents_Application(class AActor* InTarget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GCN_StatusEffect_Burst", "PostAudioEvents_Application");

	Params::GCN_StatusEffect_Burst_PostAudioEvents_Application Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GrabbedComponent.OnMovementModeChanged
// (Native, Protected)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMovementMode                     InPrevMovementMode                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             InPrevCustomMovementMode                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGrabbedComponent::OnMovementModeChanged(class ACharacter* InCharacter, const EMovementMode InPrevMovementMode, const uint8 InPrevCustomMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrabbedComponent", "OnMovementModeChanged");

	Params::GrabbedComponent_OnMovementModeChanged Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InPrevMovementMode = InPrevMovementMode;
	Parms.InPrevCustomMovementMode = InPrevCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GrabbedComponent.SetGrabbedRelativeTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                InTransform                                            (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTimeAfter                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGrabbedComponent::SetGrabbedRelativeTransform(const struct FTransform& InTransform, const float InTimeAfter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrabbedComponent", "SetGrabbedRelativeTransform");

	Params::GrabbedComponent_SetGrabbedRelativeTransform Parms{};

	Parms.InTransform = std::move(InTransform);
	Parms.InTimeAfter = InTimeAfter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.GuardianSpirit.UpdateAppearance_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EGuardianSpiritState              InOldState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGuardianSpiritState              InNewState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGuardianSpirit::UpdateAppearance_BP(const EGuardianSpiritState InOldState, const EGuardianSpiritState InNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GuardianSpirit", "UpdateAppearance_BP");

	Params::GuardianSpirit_UpdateAppearance_BP Parms{};

	Parms.InOldState = InOldState;
	Parms.InNewState = InNewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.HTNOperator_StatePriority.Setting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHTNOperator_StatePriority::Setting(const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HTNOperator_StatePriority", "Setting");

	Params::HTNOperator_StatePriority_Setting Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MovableGaugeInterface.SetPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InWorldPosition                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMovableGaugeInterface::SetPosition(const struct FVector& InWorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MovableGaugeInterface", "SetPosition");

	Params::MovableGaugeInterface_SetPosition Parms{};

	Parms.InWorldPosition = std::move(InWorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MovableGaugeInterface.SetTargetActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTargetSocket                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMovableGaugeInterface::SetTargetActor(class AActor* InTargetActor, class FName InTargetSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MovableGaugeInterface", "SetTargetActor");

	Params::MovableGaugeInterface_SetTargetActor Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InTargetSocket = InTargetSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.EnemyDirectionIndicatorInterface.SetDiscoverRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InDiscoverRate                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEnemyDirectionIndicatorInterface::SetDiscoverRate(const float InDiscoverRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("EnemyDirectionIndicatorInterface", "SetDiscoverRate");

	Params::EnemyDirectionIndicatorInterface_SetDiscoverRate Parms{};

	Parms.InDiscoverRate = InDiscoverRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.CinematicIndicatorInterface.SetLeaveMultiplayIndicatorPercent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICinematicIndicatorInterface::SetLeaveMultiplayIndicatorPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CinematicIndicatorInterface", "SetLeaveMultiplayIndicatorPercent");

	Params::CinematicIndicatorInterface_SetLeaveMultiplayIndicatorPercent Parms{};

	Parms.NewPercent = NewPercent;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.CinematicIndicatorInterface.SetShowLeaveMultiplayIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShowWidget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICinematicIndicatorInterface::SetShowLeaveMultiplayIndicator(bool bShowWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CinematicIndicatorInterface", "SetShowLeaveMultiplayIndicator");

	Params::CinematicIndicatorInterface_SetShowLeaveMultiplayIndicator Parms{};

	Parms.bShowWidget = bShowWidget;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.CinematicIndicatorInterface.SetShowSkipIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShowWidget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICinematicIndicatorInterface::SetShowSkipIndicator(bool bShowWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CinematicIndicatorInterface", "SetShowSkipIndicator");

	Params::CinematicIndicatorInterface_SetShowSkipIndicator Parms{};

	Parms.bShowWidget = bShowWidget;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.CinematicIndicatorInterface.SetSkipIndicatorPercent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICinematicIndicatorInterface::SetSkipIndicatorPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CinematicIndicatorInterface", "SetSkipIndicatorPercent");

	Params::CinematicIndicatorInterface_SetSkipIndicatorPercent Parms{};

	Parms.NewPercent = NewPercent;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.NameHudInterface.SetName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void INameHudInterface::SetName(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NameHudInterface", "SetName");

	Params::NameHudInterface_SetName Parms{};

	Parms.InName = std::move(InName);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.HudPieceBase.GetUserCustomPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D UHudPieceBase::GetUserCustomPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudPieceBase", "GetUserCustomPosition");

	Params::HudPieceBase_GetUserCustomPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.HudPieceBase.GetUserCustomScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float UHudPieceBase::GetUserCustomScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudPieceBase", "GetUserCustomScale");

	Params::HudPieceBase_GetUserCustomScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.HudPieceBase.SetUserCustomPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudPieceBase::SetUserCustomPosition(const struct FVector2D& InVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudPieceBase", "SetUserCustomPosition");

	Params::HudPieceBase_SetUserCustomPosition Parms{};

	Parms.InVector = std::move(InVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.HudPieceBase.SetUserCustomScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudPieceBase::SetUserCustomScale(const float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudPieceBase", "SetUserCustomScale");

	Params::HudPieceBase_SetUserCustomScale Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.ClearInstructionID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstructionIndicatorUIObject::ClearInstructionID(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InstructionIndicatorUIObject", "ClearInstructionID");

	Params::InstructionIndicatorUIObject_ClearInstructionID Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.HideInstruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InInstructionID                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstructionIndicatorUIObject::HideInstruction(const class UObject* InWorldContext, const struct FGameplayTag& InInstructionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InstructionIndicatorUIObject", "HideInstruction");

	Params::InstructionIndicatorUIObject_HideInstruction Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InInstructionID = std::move(InInstructionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.IsSettingInstructionID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::IsSettingInstructionID(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InstructionIndicatorUIObject", "IsSettingInstructionID");

	Params::InstructionIndicatorUIObject_IsSettingInstructionID Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.IsVisibleInstruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::IsVisibleInstruction(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InstructionIndicatorUIObject", "IsVisibleInstruction");

	Params::InstructionIndicatorUIObject_IsVisibleInstruction Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.ShowInstruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InInstructionID                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstructionIndicatorUIObject::ShowInstruction(const class UObject* InWorldContext, const struct FGameplayTag& InInstructionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InstructionIndicatorUIObject", "ShowInstruction");

	Params::InstructionIndicatorUIObject_ShowInstruction Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InInstructionID = std::move(InInstructionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.BindOnUpdateKeyAssignEventDelegate
// (Final, Native, Protected, BlueprintCallable)

void UInstructionIndicatorUIObject::BindOnUpdateKeyAssignEventDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "BindOnUpdateKeyAssignEventDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.GetInstructionNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InInstructionID                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNewFlag                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::GetInstructionNewFlag(const class FName& InInstructionID, bool* OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "GetInstructionNewFlag");

	Params::InstructionIndicatorUIObject_GetInstructionNewFlag Parms{};

	Parms.InInstructionID = InInstructionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewFlag != nullptr)
		*OutNewFlag = Parms.OutNewFlag;

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.IsInstructionVisible
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::IsInstructionVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "IsInstructionVisible");

	Params::InstructionIndicatorUIObject_IsInstructionVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.OnUpdateKeyAssign
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UInstructionIndicatorUIObject::OnUpdateKeyAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "OnUpdateKeyAssign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.InstructionIndicatorUIObject.SetInstructionInfoTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       InDescriptionData                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstructionIndicatorUIObject::SetInstructionInfoTable(class UDataTable* InDescriptionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "SetInstructionInfoTable");

	Params::InstructionIndicatorUIObject_SetInstructionInfoTable Parms{};

	Parms.InDescriptionData = InDescriptionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.SetInstructionNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InInstructionID                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutNewFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::SetInstructionNewFlag(const class FName& InInstructionID, bool OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "SetInstructionNewFlag");

	Params::InstructionIndicatorUIObject_SetInstructionNewFlag Parms{};

	Parms.InInstructionID = InInstructionID;
	Parms.OutNewFlag = OutNewFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.SetInstructionVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstructionIndicatorUIObject::SetInstructionVisibility(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "SetInstructionVisibility");

	Params::InstructionIndicatorUIObject_SetInstructionVisibility Parms{};

	Parms.InEnable = InEnable;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.UnbindOnUpdateKeyAssignEventDelegate
// (Final, Native, Protected, BlueprintCallable)

void UInstructionIndicatorUIObject::UnbindOnUpdateKeyAssignEventDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "UnbindOnUpdateKeyAssignEventDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.WriteInstructionSaveData
// (Final, Native, Public, BlueprintCallable)

void UInstructionIndicatorUIObject::WriteInstructionSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "WriteInstructionSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InstructionIndicatorUIObject.GetInstructionInfoTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UInstructionIndicatorUIObject::GetInstructionInfoTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "GetInstructionInfoTable");

	Params::InstructionIndicatorUIObject_GetInstructionInfoTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InstructionIndicatorUIObject.GetInstructionText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInstructionIndicatorUIObject::GetInstructionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InstructionIndicatorUIObject", "GetInstructionText");

	Params::InstructionIndicatorUIObject_GetInstructionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InteractionFunctionLibrary.ActInteraction
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AInteractiveActor*                InInteractiveActor                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActorWhoInteractWith                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InInteractionTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutSynchroNotifyTime                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInUseSpecifiedBaseTransform                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InSpecifiedBaseTransform                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionFunctionLibrary::ActInteraction(class AInteractiveActor* InInteractiveActor, class AActor* InActorWhoInteractWith, const struct FGameplayTag& InInteractionTag, float* OutSynchroNotifyTime, const bool bInUseSpecifiedBaseTransform, const struct FTransform& InSpecifiedBaseTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFunctionLibrary", "ActInteraction");

	Params::InteractionFunctionLibrary_ActInteraction Parms{};

	Parms.InInteractiveActor = InInteractiveActor;
	Parms.InActorWhoInteractWith = InActorWhoInteractWith;
	Parms.InInteractionTag = std::move(InInteractionTag);
	Parms.bInUseSpecifiedBaseTransform = bInUseSpecifiedBaseTransform;
	Parms.InSpecifiedBaseTransform = std::move(InSpecifiedBaseTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSynchroNotifyTime != nullptr)
		*OutSynchroNotifyTime = Parms.OutSynchroNotifyTime;

	return Parms.ReturnValue;
}


// Function Extensions.InteractionFunctionLibrary.SkeletalMeshComponent_PlayAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InPlayRate                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFunctionLibrary::SkeletalMeshComponent_PlayAnimation(class USkeletalMeshComponent* InComponent, class UAnimationAsset* InAnimation, const float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFunctionLibrary", "SkeletalMeshComponent_PlayAnimation");

	Params::InteractionFunctionLibrary_SkeletalMeshComponent_PlayAnimation Parms{};

	Parms.InComponent = InComponent;
	Parms.InAnimation = InAnimation;
	Parms.InPlayRate = InPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractionFunctionLibrary.SkeletalMeshComponent_PlayAnimationReverse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InPlayRate                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFunctionLibrary::SkeletalMeshComponent_PlayAnimationReverse(class USkeletalMeshComponent* InComponent, class UAnimationAsset* InAnimation, const float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFunctionLibrary", "SkeletalMeshComponent_PlayAnimationReverse");

	Params::InteractionFunctionLibrary_SkeletalMeshComponent_PlayAnimationReverse Parms{};

	Parms.InComponent = InComponent;
	Parms.InAnimation = InAnimation;
	Parms.InPlayRate = InPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractionFunctionLibrary.SkeletalMeshComponent_PoseFirstFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFunctionLibrary::SkeletalMeshComponent_PoseFirstFrame(class USkeletalMeshComponent* InComponent, class UAnimationAsset* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFunctionLibrary", "SkeletalMeshComponent_PoseFirstFrame");

	Params::InteractionFunctionLibrary_SkeletalMeshComponent_PoseFirstFrame Parms{};

	Parms.InComponent = InComponent;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InteractionFunctionLibrary.SkeletalMeshComponent_PoseLastFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFunctionLibrary::SkeletalMeshComponent_PoseLastFrame(class USkeletalMeshComponent* InComponent, class UAnimationAsset* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFunctionLibrary", "SkeletalMeshComponent_PoseLastFrame");

	Params::InteractionFunctionLibrary_SkeletalMeshComponent_PoseLastFrame Parms{};

	Parms.InComponent = InComponent;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryManager.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryManager* UInventoryManager::Get(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryManager", "Get");

	Params::InventoryManager_Get Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryManager.AddArticleToPlayer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FArticleBulkInfo&          InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryManager::AddArticleToPlayer(const struct FArticleBulkInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryManager", "AddArticleToPlayer");

	Params::InventoryManager_AddArticleToPlayer Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.InventoryManager.ConvertedArticleData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UArticleData*               InData                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArticleData**                    OutData                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCount                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryManager::ConvertedArticleData(const class UArticleData* InData, int32 InCount, class UArticleData** OutData, int32* OutCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryManager", "ConvertedArticleData");

	Params::InventoryManager_ConvertedArticleData Parms{};

	Parms.InData = InData;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = Parms.OutData;

	if (OutCount != nullptr)
		*OutCount = Parms.OutCount;
}


// Function Extensions.InventoryManager.HasArticleByPlayer
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FArticleBulkInfo&          InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryManager::HasArticleByPlayer(const struct FArticleBulkInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryManager", "HasArticleByPlayer");

	Params::InventoryManager_HasArticleByPlayer Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.InventoryManager.UpdateArticleFlagForPlayer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FArticleBulkInfo&          InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryManager::UpdateArticleFlagForPlayer(const struct FArticleBulkInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryManager", "UpdateArticleFlagForPlayer");

	Params::InventoryManager_UpdateArticleFlagForPlayer Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditAssignMenu.AllItemPaletteClose
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditAssignMenu::AllItemPaletteClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "AllItemPaletteClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditAssignMenu.GetEquippableItemInfoByQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemPaletteEditAssignMenu::GetEquippableItemInfoByQuery(const struct FUIEquippableItemQueryInfo& InItemQuery, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "GetEquippableItemInfoByQuery");

	Params::ItemPaletteEditAssignMenu_GetEquippableItemInfoByQuery Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.ItemPaletteEditAssignMenu.GetEquippableItemNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIExpendableItemCategory         InItemCategory                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemPaletteEditAssignMenu::GetEquippableItemNumber(const EUIExpendableItemCategory InItemCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "GetEquippableItemNumber");

	Params::ItemPaletteEditAssignMenu_GetEquippableItemNumber Parms{};

	Parms.InItemCategory = InItemCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditAssignMenu.GetItemIndexByCurrentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemPaletteEditAssignMenu::GetItemIndexByCurrentSlot(const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "GetItemIndexByCurrentSlot");

	Params::ItemPaletteEditAssignMenu_GetItemIndexByCurrentSlot Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditAssignMenu.GetItemIndexByOtherCurrentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<int32> UItemPaletteEditAssignMenu::GetItemIndexByOtherCurrentSlot(const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "GetItemIndexByOtherCurrentSlot");

	Params::ItemPaletteEditAssignMenu_GetItemIndexByOtherCurrentSlot Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditAssignMenu.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UItemPaletteEditAssignMenu::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "GetPlayerStatusSummaryInfo");

	Params::ItemPaletteEditAssignMenu_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ItemPaletteEditAssignMenu.ItemAssingeEnd
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditAssignMenu::ItemAssingeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "ItemAssingeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditAssignMenu.SetItemPalette
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InItemQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteEditAssignMenu::SetItemPalette(const struct FUIEquippableItemQueryInfo& InItemQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "SetItemPalette");

	Params::ItemPaletteEditAssignMenu_SetItemPalette Parms{};

	Parms.InItemQuery = std::move(InItemQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditAssignMenu.SeUpGridScroller
// (Event, Public, BlueprintEvent)

void UItemPaletteEditAssignMenu::SeUpGridScroller()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditAssignMenu", "SeUpGridScroller");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ItemPaletteEditMenu.ClearItemCurrentPalette
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditMenu::ClearItemCurrentPalette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "ClearItemCurrentPalette");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditMenu.EditEnd
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditMenu::EditEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "EditEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditMenu.GetEditSlot
// (Event, Public, BlueprintEvent)
// Parameters:
// EUIItemPaletteSlot                      InItemSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemPalettePieceWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemPalettePieceWidget* UItemPaletteEditMenu::GetEditSlot(EUIItemPaletteSlot InItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "GetEditSlot");

	Params::ItemPaletteEditMenu_GetEditSlot Parms{};

	Parms.InItemSlot = InItemSlot;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditMenu.GetItemNameViewer
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTextBlock*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextBlock* UItemPaletteEditMenu::GetItemNameViewer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "GetItemNameViewer");

	Params::ItemPaletteEditMenu_GetItemNameViewer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditMenu.ItemPaletteEnd
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditMenu::ItemPaletteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "ItemPaletteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditMenu.MoveSelectIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemPaletteEditMenu::MoveSelectIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "MoveSelectIndex");

	Params::ItemPaletteEditMenu_MoveSelectIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditMenu.RequestItemPaletteSlotEdit
// (Final, Native, Public, BlueprintCallable)

void UItemPaletteEditMenu::RequestItemPaletteSlotEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "RequestItemPaletteSlotEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteEditMenu.SelectLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanWarp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteEditMenu::SelectLeft(bool bInCanWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "SelectLeft");

	Params::ItemPaletteEditMenu_SelectLeft Parms{};

	Parms.bInCanWarp = bInCanWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteEditMenu.SelectRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanWarp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemPaletteEditMenu::SelectRight(bool bInCanWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteEditMenu", "SelectRight");

	Params::ItemPaletteEditMenu_SelectRight Parms{};

	Parms.bInCanWarp = bInCanWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_ReturnToTitle.OnReturnToTitle
// (Final, Native, Protected)

void UQSTask_ReturnToTitle::OnReturnToTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ReturnToTitle", "OnReturnToTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenuTextActor.GetIsUsingTestData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemPaletteMenuTextActor::GetIsUsingTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "GetIsUsingTestData");

	Params::ItemPaletteMenuTextActor_GetIsUsingTestData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenuTextActor.OnEquipItemPaletteRequest
// (Final, Native, Public)
// Parameters:
// const EUIItemPaletteSlot                InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemPaletteMenuTextActor::OnEquipItemPaletteRequest(const EUIItemPaletteSlot InSlot, const int32 InItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnEquipItemPaletteRequest");

	Params::ItemPaletteMenuTextActor_OnEquipItemPaletteRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenuTextActor.OnGetItemIndexRequest
// (Final, Native, Public)
// Parameters:
// const EUIItemPaletteSlot                InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIExpendableItemCategory         InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AItemPaletteMenuTextActor::OnGetItemIndexRequest(const EUIItemPaletteSlot InSlot, const EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnGetItemIndexRequest");

	Params::ItemPaletteMenuTextActor_OnGetItemIndexRequest Parms{};

	Parms.InSlot = InSlot;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenuTextActor.OnGetItemInfoByIndexRequest
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InItemIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AItemPaletteMenuTextActor::OnGetItemInfoByIndexRequest(const int32 InItemIndex, struct FUIItemInfo* OutItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnGetItemInfoByIndexRequest");

	Params::ItemPaletteMenuTextActor_OnGetItemInfoByIndexRequest Parms{};

	Parms.InItemIndex = InItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);
}


// Function Extensions.ItemPaletteMenuTextActor.OnGetPlayerStatusSummaryInfoRequest
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AItemPaletteMenuTextActor::OnGetPlayerStatusSummaryInfoRequest(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnGetPlayerStatusSummaryInfoRequest");

	Params::ItemPaletteMenuTextActor_OnGetPlayerStatusSummaryInfoRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ItemPaletteMenuTextActor.OnItemNumberGetRequest
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AItemPaletteMenuTextActor::OnItemNumberGetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnItemNumberGetRequest");

	Params::ItemPaletteMenuTextActor_OnItemNumberGetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemPaletteMenuTextActor.OnUnequipItemPaletteRequest
// (Final, Native, Public)
// Parameters:
// const EUIItemPaletteSlot                InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemPaletteMenuTextActor::OnUnequipItemPaletteRequest(const EUIItemPaletteSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "OnUnequipItemPaletteRequest");

	Params::ItemPaletteMenuTextActor_OnUnequipItemPaletteRequest Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPaletteMenuTextActor.RequestUseTestData
// (Final, Native, Public, BlueprintCallable)

void AItemPaletteMenuTextActor::RequestUseTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPaletteMenuTextActor", "RequestUseTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemPalettePieceWidget.GetCantUseImage
// (Event, Public, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UItemPalettePieceWidget::GetCantUseImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPalettePieceWidget", "GetCantUseImage");

	Params::ItemPalettePieceWidget_GetCantUseImage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPalettePieceWidget.GetItemIconImageBase
// (Event, Public, BlueprintEvent)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UItemPalettePieceWidget::GetItemIconImageBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPalettePieceWidget", "GetItemIconImageBase");

	Params::ItemPalettePieceWidget_GetItemIconImageBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPalettePieceWidget.GetNumControlOverlay
// (Event, Public, BlueprintEvent)
// Parameters:
// class UOverlay*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOverlay* UItemPalettePieceWidget::GetNumControlOverlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPalettePieceWidget", "GetNumControlOverlay");

	Params::ItemPalettePieceWidget_GetNumControlOverlay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPalettePieceWidget.GetNumTextBlock
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTextBlock*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextBlock* UItemPalettePieceWidget::GetNumTextBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPalettePieceWidget", "GetNumTextBlock");

	Params::ItemPalettePieceWidget_GetNumTextBlock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ItemPalettePieceWidget.SetIsRestrictItemUse
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInRestrict                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemPalettePieceWidget::SetIsRestrictItemUse(bool bInRestrict)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPalettePieceWidget", "SetIsRestrictItemUse");

	Params::ItemPalettePieceWidget_SetIsRestrictItemUse Parms{};

	Parms.bInRestrict = bInRestrict;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ItemSyntheticMenuUIObject.ArticleExchangeRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticMenuUIObject::ArticleExchangeRequest(const struct FUIArticleQueryInfo& InQuery, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "ArticleExchangeRequest");

	Params::ItemSyntheticMenuUIObject_ArticleExchangeRequest Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.BoosterSyntheticRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticMenuUIObject::BoosterSyntheticRequest(const struct FUIBoosterQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "BoosterSyntheticRequest");

	Params::ItemSyntheticMenuUIObject_BoosterSyntheticRequest Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.CreatePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UItemSyntheticMenuUIObject::CreatePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "CreatePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemSyntheticMenuUIObject.DeletePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UItemSyntheticMenuUIObject::DeletePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "DeletePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetArticleSyntheticType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EArticleSyntheticType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EArticleSyntheticType UItemSyntheticMenuUIObject::GetArticleSyntheticType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetArticleSyntheticType");

	Params::ItemSyntheticMenuUIObject_GetArticleSyntheticType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetBoosterSyntheticNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIBoosterCategory                      InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticMenuUIObject::GetBoosterSyntheticNumber(EUIBoosterCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetBoosterSyntheticNumber");

	Params::ItemSyntheticMenuUIObject_GetBoosterSyntheticNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetBoosterSyntheticRecipeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetBoosterSyntheticRecipeInfo(const struct FUIBoosterQueryInfo& InQuery, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetBoosterSyntheticRecipeInfo");

	Params::ItemSyntheticMenuUIObject_GetBoosterSyntheticRecipeInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetCurrentBuffList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetCurrentBuffList(struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetCurrentBuffList");

	Params::ItemSyntheticMenuUIObject_GetCurrentBuffList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetExchangeArticleNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIMainCategory                         InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemSyntheticMenuUIObject::GetExchangeArticleNumber(EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetExchangeArticleNumber");

	Params::ItemSyntheticMenuUIObject_GetExchangeArticleNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetExchangeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemExchangeUIInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetExchangeInfo(const struct FUIArticleQueryInfo& InQuery, struct FItemExchangeUIInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetExchangeInfo");

	Params::ItemSyntheticMenuUIObject_GetExchangeInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetExchangeMenuTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemSyntheticMenuUIObject::GetExchangeMenuTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetExchangeMenuTitle");

	Params::ItemSyntheticMenuUIObject_GetExchangeMenuTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticMenuUIObject::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetExp");

	Params::ItemSyntheticMenuUIObject_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetItemSyntheticNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIExpendableItemCategory               InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UItemSyntheticMenuUIObject::GetItemSyntheticNumber(EUIExpendableItemCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetItemSyntheticNumber");

	Params::ItemSyntheticMenuUIObject_GetItemSyntheticNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.GetItemSyntheticRecipeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FItemSyntheticRecipeUIInfo*      OutRecipeInfo                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetItemSyntheticRecipeInfo(const struct FUIEquippableItemQueryInfo& InQuery, struct FItemSyntheticRecipeUIInfo* OutRecipeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetItemSyntheticRecipeInfo");

	Params::ItemSyntheticMenuUIObject_GetItemSyntheticRecipeInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipeInfo != nullptr)
		*OutRecipeInfo = std::move(Parms.OutRecipeInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetPlayerStatusSummaryInfo");

	Params::ItemSyntheticMenuUIObject_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetReceiveBoosterUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetReceiveBoosterUIInfo(const struct FUIBoosterQueryInfo& InQueryInfo, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetReceiveBoosterUIInfo");

	Params::ItemSyntheticMenuUIObject_GetReceiveBoosterUIInfo Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetReceiveExchangeItemUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetReceiveExchangeItemUIInfo(const struct FUIArticleQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetReceiveExchangeItemUIInfo");

	Params::ItemSyntheticMenuUIObject_GetReceiveExchangeItemUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetReceiveExchangeWeaponGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetReceiveExchangeWeaponGadgetUIInfo(const struct FUIArticleQueryInfo& InQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetReceiveExchangeWeaponGadgetUIInfo");

	Params::ItemSyntheticMenuUIObject_GetReceiveExchangeWeaponGadgetUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetReceiveExchangeWeaponUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIArticleQueryInfo&       InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetReceiveExchangeWeaponUIInfo(const struct FUIArticleQueryInfo& InQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetReceiveExchangeWeaponUIInfo");

	Params::ItemSyntheticMenuUIObject_GetReceiveExchangeWeaponUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetReceiveItemUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQuery                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetReceiveItemUIInfo(const struct FUIEquippableItemQueryInfo& InQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetReceiveItemUIInfo");

	Params::ItemSyntheticMenuUIObject_GetReceiveItemUIInfo Parms{};

	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.GetSpecialBuffListWithBooster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIBoosterSlot                    InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InBoosterQuery                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::GetSpecialBuffListWithBooster(const EUIBoosterSlot InSlot, const struct FUIBoosterQueryInfo& InBoosterQuery, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "GetSpecialBuffListWithBooster");

	Params::ItemSyntheticMenuUIObject_GetSpecialBuffListWithBooster Parms{};

	Parms.InSlot = InSlot;
	Parms.InBoosterQuery = std::move(InBoosterQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ItemSyntheticMenuUIObject.IsBoosterSyntheticMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticMenuUIObject::IsBoosterSyntheticMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "IsBoosterSyntheticMenu");

	Params::ItemSyntheticMenuUIObject_IsBoosterSyntheticMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.IsOwnedSyntheticBooster
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIBoosterQueryInfo&       InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticMenuUIObject::IsOwnedSyntheticBooster(const struct FUIBoosterQueryInfo& InQueryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "IsOwnedSyntheticBooster");

	Params::ItemSyntheticMenuUIObject_IsOwnedSyntheticBooster Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.ItemSyntheticRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIEquippableItemQueryInfo&InQueryInfo                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSyntheticMenuUIObject::ItemSyntheticRequest(const struct FUIEquippableItemQueryInfo& InQueryInfo, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "ItemSyntheticRequest");

	Params::ItemSyntheticMenuUIObject_ItemSyntheticRequest Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.OpenBoosterSyntheticMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UItemSyntheticMenuUIObject::OpenBoosterSyntheticMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "OpenBoosterSyntheticMenu");

	Params::ItemSyntheticMenuUIObject_OpenBoosterSyntheticMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.OpenExchangeMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArticleSyntheticType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UItemSyntheticMenuUIObject::OpenExchangeMenu(EArticleSyntheticType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "OpenExchangeMenu");

	Params::ItemSyntheticMenuUIObject_OpenExchangeMenu Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.OpenItemSyntheticMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UItemSyntheticMenuUIObject::OpenItemSyntheticMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "OpenItemSyntheticMenu");

	Params::ItemSyntheticMenuUIObject_OpenItemSyntheticMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ItemSyntheticMenuUIObject.TradeSuccessNotifyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FScenarioNPCEventInfo&     InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UItemSyntheticMenuUIObject::TradeSuccessNotifyEvent(const struct FScenarioNPCEventInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSyntheticMenuUIObject", "TradeSuccessNotifyEvent");

	Params::ItemSyntheticMenuUIObject_TradeSuccessNotifyEvent Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.IvySuckingBloodMarker.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActionHumanCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanCharacter* AIvySuckingBloodMarker::GetOwnerCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "GetOwnerCharacter");

	Params::IvySuckingBloodMarker_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.IvySuckingBloodMarker.OnRep_RequestedMarkerState
// (Final, Native, Protected)

void AIvySuckingBloodMarker::OnRep_RequestedMarkerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "OnRep_RequestedMarkerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.IvySuckingBloodMarker.ReceiveAppear
// (Event, Protected, BlueprintEvent)

void AIvySuckingBloodMarker::ReceiveAppear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "ReceiveAppear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.IvySuckingBloodMarker.ReceiveCancel
// (Event, Protected, BlueprintEvent)

void AIvySuckingBloodMarker::ReceiveCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "ReceiveCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.IvySuckingBloodMarker.ReceiveExecute
// (Event, Protected, BlueprintEvent)
// Parameters:
// const int32                             InBulletIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIvySuckingBloodMarker::ReceiveExecute(const int32 InBulletIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "ReceiveExecute");

	Params::IvySuckingBloodMarker_ReceiveExecute Parms{};

	Parms.InBulletIndex = InBulletIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.IvySuckingBloodMarker.ReceiveSetUp
// (Event, Protected, BlueprintEvent)

void AIvySuckingBloodMarker::ReceiveSetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "ReceiveSetUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.IvySuckingBloodMarker.ReceiveToMoving
// (Event, Protected, BlueprintEvent)

void AIvySuckingBloodMarker::ReceiveToMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "ReceiveToMoving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.IvySuckingBloodMarker.SetMarkerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIvyMarkerStateType                     InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIvySuckingBloodMarker::SetMarkerState(EIvyMarkerStateType InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "SetMarkerState");

	Params::IvySuckingBloodMarker_SetMarkerState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.IvySuckingBloodMarker.GetMarkerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EIvyMarkerStateType               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EIvyMarkerStateType AIvySuckingBloodMarker::GetMarkerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IvySuckingBloodMarker", "GetMarkerState");

	Params::IvySuckingBloodMarker_GetMarkerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.JukeBox.OnRep_Context
// (Final, Native, Protected)

void AJukeBox::OnRep_Context()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JukeBox", "OnRep_Context");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.JumpToHostGameplayAbility.IsDuringJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJumpToHostGameplayAbility::IsDuringJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "IsDuringJump");

	Params::JumpToHostGameplayAbility_IsDuringJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.JumpToHostGameplayAbility.IsValidJump2HostInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJumpToHostGameplayAbility::IsValidJump2HostInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "IsValidJump2HostInfo");

	Params::JumpToHostGameplayAbility_IsValidJump2HostInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.JumpToHostGameplayAbility.K2_OnFastTravelCopleted
// (Event, Public, BlueprintEvent)

void UJumpToHostGameplayAbility::K2_OnFastTravelCopleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "K2_OnFastTravelCopleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.JumpToHostGameplayAbility.OnFastTravelCompleted
// (Final, Native, Public)

void UJumpToHostGameplayAbility::OnFastTravelCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "OnFastTravelCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.JumpToHostGameplayAbility.RequestBeginFastTravel
// (Final, Native, Public, BlueprintCallable)

void UJumpToHostGameplayAbility::RequestBeginFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "RequestBeginFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.JumpToHostGameplayAbility.RequestEQS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEQSOwner                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJumpToHostGameplayAbility::RequestEQS(class AActor* InEQSOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpToHostGameplayAbility", "RequestEQS");

	Params::JumpToHostGameplayAbility_RequestEQS Parms{};

	Parms.InEQSOwner = InEQSOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.KeywordIndicatorUIObject.NotifyKeywordMemorized
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      InKeywordID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKeywordIndicatorUIObject::NotifyKeywordMemorized(const class FName& InKeywordID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeywordIndicatorUIObject", "NotifyKeywordMemorized");

	Params::KeywordIndicatorUIObject_NotifyKeywordMemorized Parms{};

	Parms.InKeywordID = InKeywordID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.KpiDataAnalyticsSubsystem.OnAgreeChange
// (Final, Native, Private)

void UKpiDataAnalyticsSubsystem::OnAgreeChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KpiDataAnalyticsSubsystem", "OnAgreeChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LandmarkTriggerComponent.OnStoryFlagChanged
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagEvaluationFormula&EvaluationFormula                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmarkTriggerComponent::OnStoryFlagChanged(const struct FStoryFlagEvaluationFormula& EvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmarkTriggerComponent", "OnStoryFlagChanged");

	Params::LandmarkTriggerComponent_OnStoryFlagChanged Parms{};

	Parms.EvaluationFormula = std::move(EvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LandmarkTriggerComponent.OnTimeSeriesChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmarkTriggerComponent::OnTimeSeriesChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmarkTriggerComponent", "OnTimeSeriesChanged");

	Params::LandmarkTriggerComponent_OnTimeSeriesChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerVolume.K2_CreateMessage
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          InContextObject                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULocationTriggerMessage>InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocationTriggerMessage*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocationTriggerMessage* ALocationTriggerVolume::K2_CreateMessage(class UObject* InContextObject, TSubclassOf<class ULocationTriggerMessage> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocationTriggerVolume", "K2_CreateMessage");

	Params::LocationTriggerVolume_K2_CreateMessage Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.ConvertLandmarkToFieldRegionTag
// (Final, Native, Public, BlueprintCallable)

void ALocationTriggerVolume::ConvertLandmarkToFieldRegionTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "ConvertLandmarkToFieldRegionTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerVolume.IsUseActivateAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseActivateAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseActivateAction");

	Params::LocationTriggerVolume_IsUseActivateAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseAdventureTalkLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseAdventureTalkLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseAdventureTalkLocation");

	Params::LocationTriggerVolume_IsUseAdventureTalkLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseBattleReady
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseBattleReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseBattleReady");

	Params::LocationTriggerVolume_IsUseBattleReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseBossArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseBossArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseBossArea");

	Params::LocationTriggerVolume_IsUseBossArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseCameraOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseCameraOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseCameraOverride");

	Params::LocationTriggerVolume_IsUseCameraOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseFakeRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseFakeRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseFakeRegion");

	Params::LocationTriggerVolume_IsUseFakeRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseFieldBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseFieldBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseFieldBGM");

	Params::LocationTriggerVolume_IsUseFieldBGM Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseGameFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseGameFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseGameFlag");

	Params::LocationTriggerVolume_IsUseGameFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseImpactEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseImpactEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseImpactEffect");

	Params::LocationTriggerVolume_IsUseImpactEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseLandmark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseLandmark()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseLandmark");

	Params::LocationTriggerVolume_IsUseLandmark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseLocationParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseLocationParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseLocationParam");

	Params::LocationTriggerVolume_IsUseLocationParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseLocationType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseLocationType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseLocationType");

	Params::LocationTriggerVolume_IsUseLocationType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseNoMountArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseNoMountArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseNoMountArea");

	Params::LocationTriggerVolume_IsUseNoMountArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseStoryFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseStoryFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseStoryFlag");

	Params::LocationTriggerVolume_IsUseStoryFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.IsUseStreamingSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocationTriggerVolume::IsUseStreamingSource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "IsUseStreamingSource");

	Params::LocationTriggerVolume_IsUseStreamingSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LocationTriggerVolume.OnComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALocationTriggerVolume::OnComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "OnComponentBeginOverlap");

	Params::LocationTriggerVolume_OnComponentBeginOverlap Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerVolume.OnComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocationTriggerVolume::OnComponentEndOverlap(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "OnComponentEndOverlap");

	Params::LocationTriggerVolume_OnComponentEndOverlap Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LocationTriggerVolume.SetFieldRegionTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocationTriggerVolume::SetFieldRegionTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTriggerVolume", "SetFieldRegionTag");

	Params::LocationTriggerVolume_SetFieldRegionTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoMenuBase.RequestScreenFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogoMenuBase::RequestScreenFadeIn(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "RequestScreenFadeIn");

	Params::LogoMenuBase_RequestScreenFadeIn Parms{};

	Parms.InFadeTime = InFadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoMenuBase.RequestScreenFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogoMenuBase::RequestScreenFadeOut(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "RequestScreenFadeOut");

	Params::LogoMenuBase_RequestScreenFadeOut Parms{};

	Parms.InFadeTime = InFadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoMenuBase.RequestSkipLogoShow
// (Final, Native, Public, BlueprintCallable)

void ULogoMenuBase::RequestSkipLogoShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "RequestSkipLogoShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogoMenuBase.ScreenFadeInBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoMenuBase::ScreenFadeInBP(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "ScreenFadeInBP");

	Params::LogoMenuBase_ScreenFadeInBP Parms{};

	Parms.InFadeTime = InFadeTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.LogoMenuBase.ScreenFadeOutBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             InFadeTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoMenuBase::ScreenFadeOutBP(const float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "ScreenFadeOutBP");

	Params::LogoMenuBase_ScreenFadeOutBP Parms{};

	Parms.InFadeTime = InFadeTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.LogoMenuBase.SkipLogoShowBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogoMenuBase::SkipLogoShowBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogoMenuBase", "SkipLogoShowBP");

	Params::LogoMenuBase_SkipLogoShowBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.WeaponSkeletalMeshComponent.OnWeaponHitGround
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWeaponSkeletalMeshComponent::OnWeaponHitGround(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSkeletalMeshComponent", "OnWeaponHitGround");

	Params::WeaponSkeletalMeshComponent_OnWeaponHitGround Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogSendFunctionLibarary.ExecuteCrash
// (Final, Native, Static, Public, BlueprintCallable)

void ULogSendFunctionLibarary::ExecuteCrash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LogSendFunctionLibarary", "ExecuteCrash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LogSendFunctionLibarary.ExecuteEnsureMsgf
// (Final, Native, Static, Public, BlueprintCallable)

void ULogSendFunctionLibarary::ExecuteEnsureMsgf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LogSendFunctionLibarary", "ExecuteEnsureMsgf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LouDiaryManager.FinishedLouDiary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULouDiaryManager::FinishedLouDiary(const class UObject* InWorldContext, const class FName& InLouDiaryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LouDiaryManager", "FinishedLouDiary");

	Params::LouDiaryManager_FinishedLouDiary Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LouDiaryManager.MemorizeLouDiary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULouDiaryManager::MemorizeLouDiary(const class UObject* InWorldContext, const class FName& InLouDiaryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LouDiaryManager", "MemorizeLouDiary");

	Params::LouDiaryManager_MemorizeLouDiary Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LouDiaryManager.GetIsSpecialFinishedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULouDiaryManager::GetIsSpecialFinishedItem(const class FName& InLouDiaryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetIsSpecialFinishedItem");

	Params::LouDiaryManager_GetIsSpecialFinishedItem Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.GetLouDiaryDataByID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLouDiaryDataTableRow*           OutLouDiaryData                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULouDiaryManager::GetLouDiaryDataByID(const class FName& InLouDiaryID, struct FLouDiaryDataTableRow* OutLouDiaryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetLouDiaryDataByID");

	Params::LouDiaryManager_GetLouDiaryDataByID Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLouDiaryData != nullptr)
		*OutLouDiaryData = std::move(Parms.OutLouDiaryData);

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.GetLouDiaryNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNewFlag                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULouDiaryManager::GetLouDiaryNewFlag(const class FName& InLouDiaryID, bool* OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetLouDiaryNewFlag");

	Params::LouDiaryManager_GetLouDiaryNewFlag Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewFlag != nullptr)
		*OutNewFlag = Parms.OutNewFlag;

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.GetNewItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULouDiaryManager::GetNewItemID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetNewItemID");

	Params::LouDiaryManager_GetNewItemID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.GetSpecialFinishedText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText*                            OutText                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULouDiaryManager::GetSpecialFinishedText(const class FName& InLouDiaryID, class FText* OutText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetSpecialFinishedText");

	Params::LouDiaryManager_GetSpecialFinishedText Parms{};

	Parms.InLouDiaryID = InLouDiaryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.SetLouDiaryNewFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InLouDiaryID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutNewFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULouDiaryManager::SetLouDiaryNewFlag(const class FName& InLouDiaryID, bool OutNewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "SetLouDiaryNewFlag");

	Params::LouDiaryManager_SetLouDiaryNewFlag Parms{};

	Parms.InLouDiaryID = InLouDiaryID;
	Parms.OutNewFlag = OutNewFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.WriteLouDiarySaveData
// (Final, Native, Public, BlueprintCallable)

void ULouDiaryManager::WriteLouDiarySaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "WriteLouDiarySaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.LouDiaryManager.GetLouDiaryCategoryTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ULouDiaryManager::GetLouDiaryCategoryTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetLouDiaryCategoryTable");

	Params::LouDiaryManager_GetLouDiaryCategoryTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.LouDiaryManager.GetLouDiaryTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ULouDiaryManager::GetLouDiaryTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LouDiaryManager", "GetLouDiaryTable");

	Params::LouDiaryManager_GetLouDiaryTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapFeatureComponent.IsMapFeatureReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFeatureComponent::IsMapFeatureReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapFeatureComponent", "IsMapFeatureReleased");

	Params::MapFeatureComponent_IsMapFeatureReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapFeatureComponent.ReleaseMapFeature
// (Final, Native, Public, BlueprintCallable)

void UMapFeatureComponent::ReleaseMapFeature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapFeatureComponent", "ReleaseMapFeature");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.AddCompassTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCompassTargetInfo&        InTargetInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FFieldTargetInfo&          InFieldTargetInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCompassTargetHandle             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FCompassTargetHandle AMapSystem::AddCompassTarget(class UObject* InWorldContext, const struct FCompassTargetInfo& InTargetInfo, const struct FFieldTargetInfo& InFieldTargetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "AddCompassTarget");

	Params::MapSystem_AddCompassTarget Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTargetInfo = std::move(InTargetInfo);
	Parms.InFieldTargetInfo = std::move(InFieldTargetInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.AddFieldTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFieldTargetInfo&          InTargetInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FFieldTargetHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFieldTargetHandle AMapSystem::AddFieldTarget(class UObject* InWorldContext, const struct FFieldTargetInfo& InTargetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "AddFieldTarget");

	Params::MapSystem_AddFieldTarget Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTargetInfo = std::move(InTargetInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CheckCircleContainsCoordinate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InLocationA                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadiusA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocationB                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CheckCircleContainsCoordinate(const struct FVector& InLocationA, float InRadiusA, const struct FVector& InLocationB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "CheckCircleContainsCoordinate");

	Params::MapSystem_CheckCircleContainsCoordinate Parms{};

	Parms.InLocationA = std::move(InLocationA);
	Parms.InRadiusA = InRadiusA;
	Parms.InLocationB = std::move(InLocationB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CheckCircleIntersection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InLocationA                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadiusA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocationB                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadiusB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CheckCircleIntersection(const struct FVector& InLocationA, float InRadiusA, const struct FVector& InLocationB, float InRadiusB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "CheckCircleIntersection");

	Params::MapSystem_CheckCircleIntersection Parms{};

	Parms.InLocationA = std::move(InLocationA);
	Parms.InRadiusA = InRadiusA;
	Parms.InLocationB = std::move(InLocationB);
	Parms.InRadiusB = InRadiusB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCompassTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompassTargetDataSet*           OutTargetInfo                                          (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetCompassTargetData(class UObject* InWorldContext, const struct FCompassTargetHandle& InHandle, struct FCompassTargetDataSet* OutTargetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetCompassTargetData");

	Params::MapSystem_GetCompassTargetData Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetInfo != nullptr)
		*OutTargetInfo = std::move(Parms.OutTargetInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFieldTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFieldTargetHandle&        InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFieldTargetManageData*          OutTargetInfo                                          (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetFieldTargetData(class UObject* InWorldContext, const struct FFieldTargetHandle& InHandle, struct FFieldTargetManageData* OutTargetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetFieldTargetData");

	Params::MapSystem_GetFieldTargetData Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetInfo != nullptr)
		*OutTargetInfo = std::move(Parms.OutTargetInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFieldTargetHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFieldTargetHandle*              OutHandle                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetFieldTargetHandle(class UObject* InWorldContext, const struct FGameplayTag& InFeatureId, struct FFieldTargetHandle* OutHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetFieldTargetHandle");

	Params::MapSystem_GetFieldTargetHandle Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandle != nullptr)
		*OutHandle = std::move(Parms.OutHandle);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFieldTargetHandleByCompassTargetHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFieldTargetHandle*              OutHandle                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetFieldTargetHandleByCompassTargetHandle(class UObject* InWorldContext, const struct FCompassTargetHandle& InHandle, struct FFieldTargetHandle* OutHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetFieldTargetHandleByCompassTargetHandle");

	Params::MapSystem_GetFieldTargetHandleByCompassTargetHandle Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandle != nullptr)
		*OutHandle = std::move(Parms.OutHandle);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetGameplayTagFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InTagString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag AMapSystem::GetGameplayTagFromString(const class FString& InTagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetGameplayTagFromString");

	Params::MapSystem_GetGameplayTagFromString Parms{};

	Parms.InTagString = std::move(InTagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapFeatureIdFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag AMapSystem::GetMapFeatureIdFromActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "GetMapFeatureIdFromActor");

	Params::MapSystem_GetMapFeatureIdFromActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.RemoveCompassTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::RemoveCompassTarget(class UObject* InWorldContext, const struct FCompassTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "RemoveCompassTarget");

	Params::MapSystem_RemoveCompassTarget Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.RemoveFieldTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFieldTargetHandle&        InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::RemoveFieldTarget(class UObject* InWorldContext, const struct FFieldTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapSystem", "RemoveFieldTarget");

	Params::MapSystem_RemoveFieldTarget Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.AddCompassTargetItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APickupItem*                      InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompassTargetHandle             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FCompassTargetHandle AMapSystem::AddCompassTargetItem(class APickupItem* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "AddCompassTargetItem");

	Params::MapSystem_AddCompassTargetItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.AddFeatureFilterMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InFeatureId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsOn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::AddFeatureFilterMap(class FName InFeatureId, bool bInIsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "AddFeatureFilterMap");

	Params::MapSystem_AddFeatureFilterMap Parms{};

	Parms.InFeatureId = InFeatureId;
	Parms.bInIsOn = bInIsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.AssignCompassTargetWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      InTargetWidget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::AssignCompassTargetWidget(const struct FCompassTargetHandle& InHandle, class UUserWidget* InTargetWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "AssignCompassTargetWidget");

	Params::MapSystem_AssignCompassTargetWidget Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InTargetWidget = InTargetWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.BindFeatureStateChangeDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const int32 StateIndex)> InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::BindFeatureStateChangeDelegate(const struct FGameplayTag& InFeatureId, TDelegate<void(const int32 StateIndex)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "BindFeatureStateChangeDelegate");

	Params::MapSystem_BindFeatureStateChangeDelegate Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CanCorsorStickyDetectedFeature
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CanCorsorStickyDetectedFeature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "CanCorsorStickyDetectedFeature");

	Params::MapSystem_CanCorsorStickyDetectedFeature Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CanCorsorStickyDetectingFeature
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CanCorsorStickyDetectingFeature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "CanCorsorStickyDetectingFeature");

	Params::MapSystem_CanCorsorStickyDetectingFeature Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CanDisplayFeature
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTargetTimeSeries                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CanDisplayFeature(const struct FGameplayTag& InTargetTimeSeries, const struct FGameplayTag& InFeatureId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "CanDisplayFeature");

	Params::MapSystem_CanDisplayFeature Parms{};

	Parms.InTargetTimeSeries = std::move(InTargetTimeSeries);
	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.CanFastTravelToFeature
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTargetTimeSeries                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::CanFastTravelToFeature(const struct FGameplayTag& InTargetTimeSeries, const struct FGameplayTag& InFeatureId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "CanFastTravelToFeature");

	Params::MapSystem_CanFastTravelToFeature Parms{};

	Parms.InTargetTimeSeries = std::move(InTargetTimeSeries);
	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.DebugSetUp
// (Final, Native, Private, BlueprintCallable)

void AMapSystem::DebugSetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "DebugSetUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.DiscoverFeatures
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::DiscoverFeatures(const struct FVector& InLocation, float InSearchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "DiscoverFeatures");

	Params::MapSystem_DiscoverFeatures Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InSearchRadius = InSearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.DrawSavedMapRevealArea
// (Event, Protected, BlueprintEvent)

void AMapSystem::DrawSavedMapRevealArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "DrawSavedMapRevealArea");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.MapSystem.FastTravelPlayerToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InPlayerRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  InCameraRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class FString&                    InTimeTravelFlagString                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::FastTravelPlayerToLocation(const struct FGameplayTag& InFeatureId, const struct FVector& InLocation, const struct FRotator& InPlayerRotation, const struct FRotator& InCameraRotation, const class FString& InTimeTravelFlagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "FastTravelPlayerToLocation");

	Params::MapSystem_FastTravelPlayerToLocation Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.InLocation = std::move(InLocation);
	Parms.InPlayerRotation = std::move(InPlayerRotation);
	Parms.InCameraRotation = std::move(InCameraRotation);
	Parms.InTimeTravelFlagString = std::move(InTimeTravelFlagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.FindFeatureFilter
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InFeatureId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsOn                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::FindFeatureFilter(const class FName& InFeatureId, bool* bOutIsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "FindFeatureFilter");

	Params::MapSystem_FindFeatureFilter Parms{};

	Parms.InFeatureId = InFeatureId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsOn != nullptr)
		*bOutIsOn = Parms.bOutIsOn;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetAllFeatureIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetAllFeatureIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetAllFeatureIDs");

	Params::MapSystem_GetAllFeatureIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetAllTimeSeriesRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AMapSystem::GetAllTimeSeriesRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetAllTimeSeriesRowNames");

	Params::MapSystem_GetAllTimeSeriesRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCompassZOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCompassTargetHandle&      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutZOrder                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetCompassZOrder(const struct FCompassTargetHandle& InHandle, int32* OutZOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCompassZOrder");

	Params::MapSystem_GetCompassZOrder Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutZOrder != nullptr)
		*OutZOrder = Parms.OutZOrder;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentFakeRegionTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag*                    OutRegionTag                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetCurrentFakeRegionTag(struct FGameplayTag* OutRegionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentFakeRegionTag");

	Params::MapSystem_GetCurrentFakeRegionTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRegionTag != nullptr)
		*OutRegionTag = std::move(Parms.OutRegionTag);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentRegionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMapRegionInfo*                  OutMapRegionInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetCurrentRegionInfo(struct FMapRegionInfo* OutMapRegionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentRegionInfo");

	Params::MapSystem_GetCurrentRegionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapRegionInfo != nullptr)
		*OutMapRegionInfo = std::move(Parms.OutMapRegionInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentTimeSeries
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag AMapSystem::GetCurrentTimeSeries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentTimeSeries");

	Params::MapSystem_GetCurrentTimeSeries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentTimeSeriesText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText AMapSystem::GetCurrentTimeSeriesText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentTimeSeriesText");

	Params::MapSystem_GetCurrentTimeSeriesText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetDiscoveredFeatureIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetDiscoveredFeatureIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetDiscoveredFeatureIDs");

	Params::MapSystem_GetDiscoveredFeatureIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFakeRegionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InRegionTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFakeRegionCoordinate*           OutRegionInfo                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetFakeRegionInfo(const struct FGameplayTag& InRegionTag, struct FFakeRegionCoordinate* OutRegionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFakeRegionInfo");

	Params::MapSystem_GetFakeRegionInfo Parms{};

	Parms.InRegionTag = std::move(InRegionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRegionInfo != nullptr)
		*OutRegionInfo = std::move(Parms.OutRegionInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFastTravelProhibitMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText*                            OutMessageTitle                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText*                            OutMessageMain                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// float*                                  OutMessageDuration                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::GetFastTravelProhibitMessage(class FText* OutMessageTitle, class FText* OutMessageMain, float* OutMessageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFastTravelProhibitMessage");

	Params::MapSystem_GetFastTravelProhibitMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMessageTitle != nullptr)
		*OutMessageTitle = std::move(Parms.OutMessageTitle);

	if (OutMessageMain != nullptr)
		*OutMessageMain = std::move(Parms.OutMessageMain);

	if (OutMessageDuration != nullptr)
		*OutMessageDuration = Parms.OutMessageDuration;
}


// Function Extensions.MapSystem.GetFeatureIDsByFeatureType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InFeatureTypeName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsStableOrder                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetFeatureIDsByFeatureType(const class FName& InFeatureTypeName, bool bIsStableOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFeatureIDsByFeatureType");

	Params::MapSystem_GetFeatureIDsByFeatureType Parms{};

	Parms.InFeatureTypeName = InFeatureTypeName;
	Parms.bIsStableOrder = bIsStableOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFeatureIDsByTimeSeries
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTimeSeriesTag                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetFeatureIDsByTimeSeries(const struct FGameplayTag& InTimeSeriesTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFeatureIDsByTimeSeries");

	Params::MapSystem_GetFeatureIDsByTimeSeries Parms{};

	Parms.InTimeSeriesTag = std::move(InTimeSeriesTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFeatureState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutStateIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetFeatureState(const struct FGameplayTag& InFeatureId, int32* OutStateIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFeatureState");

	Params::MapSystem_GetFeatureState Parms{};

	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStateIndex != nullptr)
		*OutStateIndex = Parms.OutStateIndex;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetFieldTargetManageData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FFieldTargetManageData>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FFieldTargetManageData> AMapSystem::GetFieldTargetManageData(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetFieldTargetManageData");

	Params::MapSystem_GetFieldTargetManageData Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetGuardianSpiritUIInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InUniqueSaveID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuardianSpiritUIInfo            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGuardianSpiritUIInfo AMapSystem::GetGuardianSpiritUIInfo(const class FName InUniqueSaveID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetGuardianSpiritUIInfo");

	Params::MapSystem_GetGuardianSpiritUIInfo Parms{};

	Parms.InUniqueSaveID = InUniqueSaveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetInnerCoordinateForRegion
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector2D&                 InOuterCoordinate                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InRegionTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       OutInnerCoordinate                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetInnerCoordinateForRegion(const struct FVector2D& InOuterCoordinate, const struct FGameplayTag& InRegionTag, struct FVector2D* OutInnerCoordinate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetInnerCoordinateForRegion");

	Params::MapSystem_GetInnerCoordinateForRegion Parms{};

	Parms.InOuterCoordinate = std::move(InOuterCoordinate);
	Parms.InRegionTag = std::move(InRegionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInnerCoordinate != nullptr)
		*OutInnerCoordinate = std::move(Parms.OutInnerCoordinate);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetLandmarksToAddToCompass
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetLandmarksToAddToCompass(const struct FVector& InLocation, float InSearchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetLandmarksToAddToCompass");

	Params::MapSystem_GetLandmarksToAddToCompass Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InSearchRadius = InSearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetLandmarksToRemoveFromCompass
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetLandmarksToRemoveFromCompass(const struct FVector& InLocation, float InSearchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetLandmarksToRemoveFromCompass");

	Params::MapSystem_GetLandmarksToRemoveFromCompass Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InSearchRadius = InSearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetLouDiaryIDByFeatureID
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AMapSystem::GetLouDiaryIDByFeatureID(const struct FGameplayTag& InFeatureId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetLouDiaryIDByFeatureID");

	Params::MapSystem_GetLouDiaryIDByFeatureID Parms{};

	Parms.InFeatureId = std::move(InFeatureId);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapCurrentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AMapSystem::GetMapCurrentScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapCurrentScale");

	Params::MapSystem_GetMapCurrentScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapFeatureInfoFromMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapFeatureInfo*                 OutFeatureInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetMapFeatureInfoFromMap(const struct FGameplayTag& InFeatureId, struct FMapFeatureInfo* OutFeatureInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapFeatureInfoFromMap");

	Params::MapSystem_GetMapFeatureInfoFromMap Parms{};

	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFeatureInfo != nullptr)
		*OutFeatureInfo = std::move(Parms.OutFeatureInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapFeatureTypeFromMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapFeatureType*                 OutFeatureType                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetMapFeatureTypeFromMap(const struct FGameplayTag& InFeatureId, struct FMapFeatureType* OutFeatureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapFeatureTypeFromMap");

	Params::MapSystem_GetMapFeatureTypeFromMap Parms{};

	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFeatureType != nullptr)
		*OutFeatureType = std::move(Parms.OutFeatureType);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapReleaseAreaInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InAreaId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMapReleaseAreaInfo        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMapReleaseAreaInfo AMapSystem::GetMapReleaseAreaInfo(const class FName& InAreaId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapReleaseAreaInfo");

	Params::MapSystem_GetMapReleaseAreaInfo Parms{};

	Parms.InAreaId = InAreaId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetOuterCoordinateForRegion
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector2D&                 InInnerCoordinate                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InRegionTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       OutOuterCoordinate                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetOuterCoordinateForRegion(const struct FVector2D& InInnerCoordinate, const struct FGameplayTag& InRegionTag, struct FVector2D* OutOuterCoordinate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetOuterCoordinateForRegion");

	Params::MapSystem_GetOuterCoordinateForRegion Parms{};

	Parms.InInnerCoordinate = std::move(InInnerCoordinate);
	Parms.InRegionTag = std::move(InRegionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOuterCoordinate != nullptr)
		*OutOuterCoordinate = std::move(Parms.OutOuterCoordinate);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetPlayerMapPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AMapSystem::GetPlayerMapPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetPlayerMapPosition");

	Params::MapSystem_GetPlayerMapPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetReleasedFeatureIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> AMapSystem::GetReleasedFeatureIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetReleasedFeatureIDs");

	Params::MapSystem_GetReleasedFeatureIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetTimeSeriesInfoByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimeSeriesInfo                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTimeSeriesInfo AMapSystem::GetTimeSeriesInfoByName(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetTimeSeriesInfoByName");

	Params::MapSystem_GetTimeSeriesInfoByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetUseMarkerLimitMassege
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText*                            OutMessageTitle                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText*                            OutMessageMain                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// float*                                  OutMessageDuration                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::GetUseMarkerLimitMassege(class FText* OutMessageTitle, class FText* OutMessageMain, float* OutMessageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetUseMarkerLimitMassege");

	Params::MapSystem_GetUseMarkerLimitMassege Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMessageTitle != nullptr)
		*OutMessageTitle = std::move(Parms.OutMessageTitle);

	if (OutMessageMain != nullptr)
		*OutMessageMain = std::move(Parms.OutMessageMain);

	if (OutMessageDuration != nullptr)
		*OutMessageDuration = Parms.OutMessageDuration;
}


// Function Extensions.MapSystem.IsFastTravelProhibited
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsFastTravelProhibited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsFastTravelProhibited");

	Params::MapSystem_IsFastTravelProhibited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.IsFeatureReleased
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsFeatureReleased(const struct FGameplayTag& InFeatureId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsFeatureReleased");

	Params::MapSystem_IsFeatureReleased Parms{};

	Parms.InFeatureId = std::move(InFeatureId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.IsMapAreaReleased
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InAreaId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsMapAreaReleased(const class FName& InAreaId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsMapAreaReleased");

	Params::MapSystem_IsMapAreaReleased Parms{};

	Parms.InAreaId = InAreaId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.IsMapMove
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsMapMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsMapMove");

	Params::MapSystem_IsMapMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.IsMapRelease
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsMapRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsMapRelease");

	Params::MapSystem_IsMapRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.IsMouseDefaultControlType
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::IsMouseDefaultControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "IsMouseDefaultControlType");

	Params::MapSystem_IsMouseDefaultControlType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.MakeMapFeatureMap
// (Final, Native, Public, BlueprintCallable)

void AMapSystem::MakeMapFeatureMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "MakeMapFeatureMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.MapFeatureAllRelease
// (Final, Native, Private, BlueprintCallable)

void AMapSystem::MapFeatureAllRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "MapFeatureAllRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.OnFinishFastTravel
// (Final, Native, Private)

void AMapSystem::OnFinishFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "OnFinishFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.SetFeatureDiscovered
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowIndication                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::SetFeatureDiscovered(const struct FGameplayTag& InFeatureId, bool bShowIndication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "SetFeatureDiscovered");

	Params::MapSystem_SetFeatureDiscovered Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.bShowIndication = bShowIndication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.SetFeatureState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InStateIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::SetFeatureState(const struct FGameplayTag& InFeatureId, const int32 InStateIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "SetFeatureState");

	Params::MapSystem_SetFeatureState Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.InStateIndex = InStateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.SetGuardianSpiritState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       InUniqueSaveID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGuardianSpiritState              InState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::SetGuardianSpiritState(const class FName InUniqueSaveID, const EGuardianSpiritState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "SetGuardianSpiritState");

	Params::MapSystem_SetGuardianSpiritState Parms{};

	Parms.InUniqueSaveID = InUniqueSaveID;
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.SetMapAreaReleased
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InAreaId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InReleased                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::SetMapAreaReleased(const class FName& InAreaId, bool InReleased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "SetMapAreaReleased");

	Params::MapSystem_SetMapAreaReleased Parms{};

	Parms.InAreaId = InAreaId;
	Parms.InReleased = InReleased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.SetMapCurrentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapSystem::SetMapCurrentScale(const struct FVector2D& InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "SetMapCurrentScale");

	Params::MapSystem_SetMapCurrentScale Parms{};

	Parms.InScale = std::move(InScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.UnbindFeatureStateChangeDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const int32 StateIndex)> InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::UnbindFeatureStateChangeDelegate(const struct FGameplayTag& InFeatureId, TDelegate<void(const int32 StateIndex)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "UnbindFeatureStateChangeDelegate");

	Params::MapSystem_UnbindFeatureStateChangeDelegate Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.UpdateCompassTargetZOrder
// (Final, Native, Public, BlueprintCallable)

void AMapSystem::UpdateCompassTargetZOrder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "UpdateCompassTargetZOrder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MapSystem.GetCompassDisplayDistance
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InFeatureId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMapSystem::GetCompassDisplayDistance(const struct FGameplayTag& InFeatureId, const struct FVector& InLocation, float InSearchRadius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCompassDisplayDistance");

	Params::MapSystem_GetCompassDisplayDistance Parms{};

	Parms.InFeatureId = std::move(InFeatureId);
	Parms.InLocation = std::move(InLocation);
	Parms.InSearchRadius = InSearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCompassDistanceRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMapSystem::GetCompassDistanceRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCompassDistanceRange");

	Params::MapSystem_GetCompassDistanceRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCompassFadeDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMapSystem::GetCompassFadeDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCompassFadeDistance");

	Params::MapSystem_GetCompassFadeDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCompassTargetHandles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCompassTargetHandle>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCompassTargetHandle> AMapSystem::GetCompassTargetHandles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCompassTargetHandles");

	Params::MapSystem_GetCompassTargetHandles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurosrGuide_GuardianSpirit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       InUniqueSaveID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AMapSystem::GetCurosrGuide_GuardianSpirit(const class FName InUniqueSaveID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurosrGuide_GuardianSpirit");

	Params::MapSystem_GetCurosrGuide_GuardianSpirit Parms{};

	Parms.InUniqueSaveID = InUniqueSaveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentMapInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMapInfo*                        OutMapInfo                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetCurrentMapInfo(struct FMapInfo* OutMapInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentMapInfo");

	Params::MapSystem_GetCurrentMapInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapInfo != nullptr)
		*OutMapInfo = std::move(Parms.OutMapInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentMapName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AMapSystem::GetCurrentMapName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentMapName");

	Params::MapSystem_GetCurrentMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetCurrentRegionGuardianSpiritUniqueSaveIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AMapSystem::GetCurrentRegionGuardianSpiritUniqueSaveIDs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetCurrentRegionGuardianSpiritUniqueSaveIDs");

	Params::MapSystem_GetCurrentRegionGuardianSpiritUniqueSaveIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetDataTableMapFeatureInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      InMapName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AMapSystem::GetDataTableMapFeatureInfo(const class FName& InMapName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetDataTableMapFeatureInfo");

	Params::MapSystem_GetDataTableMapFeatureInfo Parms{};

	Parms.InMapName = InMapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetDataTableMapFeatureType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AMapSystem::GetDataTableMapFeatureType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetDataTableMapFeatureType");

	Params::MapSystem_GetDataTableMapFeatureType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetDataTableMapRegionInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AMapSystem::GetDataTableMapRegionInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetDataTableMapRegionInfo");

	Params::MapSystem_GetDataTableMapRegionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetGuardianSpiritState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       InUniqueSaveID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuardianSpiritState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGuardianSpiritState AMapSystem::GetGuardianSpiritState(const class FName InUniqueSaveID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetGuardianSpiritState");

	Params::MapSystem_GetGuardianSpiritState Parms{};

	Parms.InUniqueSaveID = InUniqueSaveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetHasEnterTheSearchArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetHasEnterTheSearchArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetHasEnterTheSearchArea");

	Params::MapSystem_GetHasEnterTheSearchArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      InMapName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapInfo*                        OutMapInfo                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetMapInfo(const class FName& InMapName, struct FMapInfo* OutMapInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapInfo");

	Params::MapSystem_GetMapInfo Parms{};

	Parms.InMapName = InMapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapInfo != nullptr)
		*OutMapInfo = std::move(Parms.OutMapInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapRegionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       InRegionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapRegionInfo*                  OutMapRegionInfo                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMapSystem::GetMapRegionInfo(const class FName InRegionName, struct FMapRegionInfo* OutMapRegionInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapRegionInfo");

	Params::MapSystem_GetMapRegionInfo Parms{};

	Parms.InRegionName = InRegionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapRegionInfo != nullptr)
		*OutMapRegionInfo = std::move(Parms.OutMapRegionInfo);

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetMapTargetIconType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapTargetIconType*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapTargetIconType* AMapSystem::GetMapTargetIconType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetMapTargetIconType");

	Params::MapSystem_GetMapTargetIconType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MapSystem.GetSelectCompassMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESelectCompassMode                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESelectCompassMode AMapSystem::GetSelectCompassMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSystem", "GetSelectCompassMode");

	Params::MapSystem_GetSelectCompassMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughComponent.FindSeeThroughMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* USeeThroughComponent::FindSeeThroughMaterial(class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeeThroughComponent", "FindSeeThroughMaterial");

	Params::SeeThroughComponent_FindSeeThroughMaterial Parms{};

	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughComponent.FindSeeThroughMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* USeeThroughComponent::FindSeeThroughMesh(class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeeThroughComponent", "FindSeeThroughMesh");

	Params::SeeThroughComponent_FindSeeThroughMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughComponent.UseSeeThroughMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeeThroughComponent::UseSeeThroughMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeeThroughComponent", "UseSeeThroughMesh");

	Params::SeeThroughComponent_UseSeeThroughMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.ActiveQuestVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AQuestVolumeBase*                 InVolume                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::ActiveQuestVolume(class AQuestVolumeBase* InVolume, bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "ActiveQuestVolume");

	Params::ToolFunctionLibrary_ActiveQuestVolume Parms{};

	Parms.InVolume = InVolume;
	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.ActorComponent_SetAllowAnyoneToDestroyMe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::ActorComponent_SetAllowAnyoneToDestroyMe(class UActorComponent* InComponent, bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "ActorComponent_SetAllowAnyoneToDestroyMe");

	Params::ToolFunctionLibrary_ActorComponent_SetAllowAnyoneToDestroyMe Parms{};

	Parms.InComponent = InComponent;
	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.CalcPitchYawFrom2Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InBase                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InTarget                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutPitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutYaw                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::CalcPitchYawFrom2Vector(const struct FVector& InBase, const struct FVector& InTarget, float* OutPitch, float* OutYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "CalcPitchYawFrom2Vector");

	Params::ToolFunctionLibrary_CalcPitchYawFrom2Vector Parms{};

	Parms.InBase = std::move(InBase);
	Parms.InTarget = std::move(InTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPitch != nullptr)
		*OutPitch = Parms.OutPitch;

	if (OutYaw != nullptr)
		*OutYaw = Parms.OutYaw;
}


// Function Extensions.ToolFunctionLibrary.CreateQuaternionFrom2Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InSrc                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDst                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat*                           OutQuat                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::CreateQuaternionFrom2Vector(const struct FVector& InSrc, const struct FVector& InDst, struct FQuat* OutQuat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "CreateQuaternionFrom2Vector");

	Params::ToolFunctionLibrary_CreateQuaternionFrom2Vector Parms{};

	Parms.InSrc = std::move(InSrc);
	Parms.InDst = std::move(InDst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutQuat != nullptr)
		*OutQuat = std::move(Parms.OutQuat);
}


// Function Extensions.ToolFunctionLibrary.CreateQuaternionFromAxisAndAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InAxis                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            InAngle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat*                           OutQuat                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::CreateQuaternionFromAxisAndAngle(const struct FVector& InAxis, const float& InAngle, struct FQuat* OutQuat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "CreateQuaternionFromAxisAndAngle");

	Params::ToolFunctionLibrary_CreateQuaternionFromAxisAndAngle Parms{};

	Parms.InAxis = std::move(InAxis);
	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutQuat != nullptr)
		*OutQuat = std::move(Parms.OutQuat);
}


// Function Extensions.ToolFunctionLibrary.CreateStaticMeshFromVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVolume*                          InVolume                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UToolFunctionLibrary::CreateStaticMeshFromVolume(class AVolume* InVolume, class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "CreateStaticMeshFromVolume");

	Params::ToolFunctionLibrary_CreateStaticMeshFromVolume Parms{};

	Parms.InVolume = InVolume;
	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.EnemyManager_GetCurrentEnemyInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UToolFunctionLibrary::EnemyManager_GetCurrentEnemyInstance(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "EnemyManager_GetCurrentEnemyInstance");

	Params::ToolFunctionLibrary_EnemyManager_GetCurrentEnemyInstance Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetAxisAndAngleFrom2Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InSrc                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDst                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutAxis                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutAngle                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::GetAxisAndAngleFrom2Vector(const struct FVector& InSrc, const struct FVector& InDst, struct FVector* OutAxis, float* OutAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetAxisAndAngleFrom2Vector");

	Params::ToolFunctionLibrary_GetAxisAndAngleFrom2Vector Parms{};

	Parms.InSrc = std::move(InSrc);
	Parms.InDst = std::move(InDst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAxis != nullptr)
		*OutAxis = std::move(Parms.OutAxis);

	if (OutAngle != nullptr)
		*OutAngle = Parms.OutAngle;
}


// Function Extensions.ToolFunctionLibrary.GetAxisAndAngleFromQuaternion
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FQuat&                     InQuat                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutAxis                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutAngle                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::GetAxisAndAngleFromQuaternion(const struct FQuat& InQuat, struct FVector* OutAxis, float* OutAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetAxisAndAngleFromQuaternion");

	Params::ToolFunctionLibrary_GetAxisAndAngleFromQuaternion Parms{};

	Parms.InQuat = std::move(InQuat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAxis != nullptr)
		*OutAxis = std::move(Parms.OutAxis);

	if (OutAngle != nullptr)
		*OutAngle = Parms.OutAngle;
}


// Function Extensions.ToolFunctionLibrary.GetColorFromPhysicalMaterialSurfaceTypeIndex
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InSurfaceTypeIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UToolFunctionLibrary::GetColorFromPhysicalMaterialSurfaceTypeIndex(int32 InSurfaceTypeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetColorFromPhysicalMaterialSurfaceTypeIndex");

	Params::ToolFunctionLibrary_GetColorFromPhysicalMaterialSurfaceTypeIndex Parms{};

	Parms.InSurfaceTypeIndex = InSurfaceTypeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetDebugWindScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UToolFunctionLibrary::GetDebugWindScale(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetDebugWindScale");

	Params::ToolFunctionLibrary_GetDebugWindScale Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetDestructibleActorDebug_EnableDestructAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::GetDestructibleActorDebug_EnableDestructAll(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetDestructibleActorDebug_EnableDestructAll");

	Params::ToolFunctionLibrary_GetDestructibleActorDebug_EnableDestructAll Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetDestructibleActorDebugMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::GetDestructibleActorDebugMenu(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetDestructibleActorDebugMenu");

	Params::ToolFunctionLibrary_GetDestructibleActorDebugMenu Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetEnemyDebugMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutDoNothingState                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNoDeath                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::GetEnemyDebugMenu(const class UObject* InContextObject, bool* OutDoNothingState, bool* OutNoDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetEnemyDebugMenu");

	Params::ToolFunctionLibrary_GetEnemyDebugMenu Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDoNothingState != nullptr)
		*OutDoNothingState = Parms.OutDoNothingState;

	if (OutNoDeath != nullptr)
		*OutNoDeath = Parms.OutNoDeath;
}


// Function Extensions.ToolFunctionLibrary.GetPhysicalMaterialFromPrimitiveComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UToolFunctionLibrary::GetPhysicalMaterialFromPrimitiveComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPhysicalMaterialFromPrimitiveComponent");

	Params::ToolFunctionLibrary_GetPhysicalMaterialFromPrimitiveComponent Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetPhysicalMaterialSurfaceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*                InPhysicalMaterial                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UToolFunctionLibrary::GetPhysicalMaterialSurfaceType(class UPhysicalMaterial* InPhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPhysicalMaterialSurfaceType");

	Params::ToolFunctionLibrary_GetPhysicalMaterialSurfaceType Parms{};

	Parms.InPhysicalMaterial = InPhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetPhysicalSurfaceTypeNameArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>*                          OutTypeArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNameArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::GetPhysicalSurfaceTypeNameArray(TArray<int32>* OutTypeArray, TArray<class FName>* OutNameArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPhysicalSurfaceTypeNameArray");

	Params::ToolFunctionLibrary_GetPhysicalSurfaceTypeNameArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTypeArray != nullptr)
		*OutTypeArray = std::move(Parms.OutTypeArray);

	if (OutNameArray != nullptr)
		*OutNameArray = std::move(Parms.OutNameArray);

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetPlayerDebugGender
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCustomizeGender*              OutGender                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::GetPlayerDebugGender(class ACharacter* InCharacter, ECharacterCustomizeGender* OutGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPlayerDebugGender");

	Params::ToolFunctionLibrary_GetPlayerDebugGender Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGender != nullptr)
		*OutGender = Parms.OutGender;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetPlayerDebugMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNoDeath                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNotConsumeStamina                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutNotConsumeIchor                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutAlwaysAllowSpecialBloodSuck                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::GetPlayerDebugMenu(const class UObject* InContextObject, bool* OutNoDeath, bool* OutNotConsumeStamina, bool* OutNotConsumeIchor, bool* OutAlwaysAllowSpecialBloodSuck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPlayerDebugMenu");

	Params::ToolFunctionLibrary_GetPlayerDebugMenu Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNoDeath != nullptr)
		*OutNoDeath = Parms.OutNoDeath;

	if (OutNotConsumeStamina != nullptr)
		*OutNotConsumeStamina = Parms.OutNotConsumeStamina;

	if (OutNotConsumeIchor != nullptr)
		*OutNotConsumeIchor = Parms.OutNotConsumeIchor;

	if (OutAlwaysAllowSpecialBloodSuck != nullptr)
		*OutAlwaysAllowSpecialBloodSuck = Parms.OutAlwaysAllowSpecialBloodSuck;
}


// Function Extensions.ToolFunctionLibrary.GetPlayerWeaponMeshComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerCharacter*                 InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UToolFunctionLibrary::GetPlayerWeaponMeshComponent(class APlayerCharacter* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetPlayerWeaponMeshComponent");

	Params::ToolFunctionLibrary_GetPlayerWeaponMeshComponent Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetSimplePhysicalMaterialFromPrimitiveComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UToolFunctionLibrary::GetSimplePhysicalMaterialFromPrimitiveComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetSimplePhysicalMaterialFromPrimitiveComponent");

	Params::ToolFunctionLibrary_GetSimplePhysicalMaterialFromPrimitiveComponent Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetSurfaceTypeNameFromSurfaceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InSurfaceType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UToolFunctionLibrary::GetSurfaceTypeNameFromSurfaceType(int32 InSurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetSurfaceTypeNameFromSurfaceType");

	Params::ToolFunctionLibrary_GetSurfaceTypeNameFromSurfaceType Parms{};

	Parms.InSurfaceType = InSurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.GetWindVelocity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InOwner                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InWindScale                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UToolFunctionLibrary::GetWindVelocity(const class UObject* InOwner, const float InWindScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "GetWindVelocity");

	Params::ToolFunctionLibrary_GetWindVelocity Parms{};

	Parms.InOwner = InOwner;
	Parms.InWindScale = InWindScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.Material_HasScalarParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InParameterName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::Material_HasScalarParameter(class UMaterialInterface* InMaterialInterface, class FName InParameterName, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Material_HasScalarParameter");

	Params::ToolFunctionLibrary_Material_HasScalarParameter Parms{};

	Parms.InMaterialInterface = InMaterialInterface;
	Parms.InParameterName = InParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.Material_HasStaticSwitchParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InParameterName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::Material_HasStaticSwitchParameter(class UMaterialInterface* InMaterialInterface, class FName InParameterName, bool* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Material_HasStaticSwitchParameter");

	Params::ToolFunctionLibrary_Material_HasStaticSwitchParameter Parms{};

	Parms.InMaterialInterface = InMaterialInterface;
	Parms.InParameterName = InParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.Material_HasTextureParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InParameterName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture**                        OutValue                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::Material_HasTextureParameter(class UMaterialInterface* InMaterialInterface, class FName InParameterName, class UTexture** OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Material_HasTextureParameter");

	Params::ToolFunctionLibrary_Material_HasTextureParameter Parms{};

	Parms.InMaterialInterface = InMaterialInterface;
	Parms.InParameterName = InParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.Material_HasVectorParameter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InParameterName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::Material_HasVectorParameter(class UMaterialInterface* InMaterialInterface, class FName InParameterName, struct FLinearColor* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Material_HasVectorParameter");

	Params::ToolFunctionLibrary_Material_HasVectorParameter Parms{};

	Parms.InMaterialInterface = InMaterialInterface;
	Parms.InParameterName = InParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.Material_IsDependent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InTestMaterial                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::Material_IsDependent(class UMaterialInterface* InMaterial, class UMaterialInterface* InTestMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Material_IsDependent");

	Params::ToolFunctionLibrary_Material_IsDependent Parms{};

	Parms.InMaterial = InMaterial;
	Parms.InTestMaterial = InTestMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_GetScalarParameterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNameArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          OutValueArray                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_GetScalarParameterArray(class UMaterialParameterCollection* InMaterialParameterCollection, TArray<class FName>* OutNameArray, TArray<float>* OutValueArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_GetScalarParameterArray");

	Params::ToolFunctionLibrary_MaterialParameterCollection_GetScalarParameterArray Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNameArray != nullptr)
		*OutNameArray = std::move(Parms.OutNameArray);

	if (OutValueArray != nullptr)
		*OutValueArray = std::move(Parms.OutValueArray);

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_GetVectorParameterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNameArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>*            OutValueArray                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_GetVectorParameterArray(class UMaterialParameterCollection* InMaterialParameterCollection, TArray<class FName>* OutNameArray, TArray<struct FLinearColor>* OutValueArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_GetVectorParameterArray");

	Params::ToolFunctionLibrary_MaterialParameterCollection_GetVectorParameterArray Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNameArray != nullptr)
		*OutNameArray = std::move(Parms.OutNameArray);

	if (OutValueArray != nullptr)
		*OutValueArray = std::move(Parms.OutValueArray);

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_IsExistsScalarParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_IsExistsScalarParameter(class UMaterialParameterCollection* InMaterialParameterCollection, class FName InName, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_IsExistsScalarParameter");

	Params::ToolFunctionLibrary_MaterialParameterCollection_IsExistsScalarParameter Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_IsExistsVectorParameter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_IsExistsVectorParameter(class UMaterialParameterCollection* InMaterialParameterCollection, class FName InName, struct FLinearColor* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_IsExistsVectorParameter");

	Params::ToolFunctionLibrary_MaterialParameterCollection_IsExistsVectorParameter Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_SetScalarParameter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_SetScalarParameter(class UMaterialParameterCollection* InMaterialParameterCollection, class FName InName, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_SetScalarParameter");

	Params::ToolFunctionLibrary_MaterialParameterCollection_SetScalarParameter Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InName = InName;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_SetScalarParameterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InNameArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<float>&                    InValueArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_SetScalarParameterArray(class UMaterialParameterCollection* InMaterialParameterCollection, const TArray<class FName>& InNameArray, const TArray<float>& InValueArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_SetScalarParameterArray");

	Params::ToolFunctionLibrary_MaterialParameterCollection_SetScalarParameterArray Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InNameArray = std::move(InNameArray);
	Parms.InValueArray = std::move(InValueArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_SetVectorParameter
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_SetVectorParameter(class UMaterialParameterCollection* InMaterialParameterCollection, class FName InName, const struct FLinearColor& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_SetVectorParameter");

	Params::ToolFunctionLibrary_MaterialParameterCollection_SetVectorParameter Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InName = InName;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.MaterialParameterCollection_SetVectorParameterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMaterialParameterCollection                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InNameArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      InValueArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::MaterialParameterCollection_SetVectorParameterArray(class UMaterialParameterCollection* InMaterialParameterCollection, const TArray<class FName>& InNameArray, const TArray<struct FLinearColor>& InValueArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "MaterialParameterCollection_SetVectorParameterArray");

	Params::ToolFunctionLibrary_MaterialParameterCollection_SetVectorParameterArray Parms{};

	Parms.InMaterialParameterCollection = InMaterialParameterCollection;
	Parms.InNameArray = std::move(InNameArray);
	Parms.InValueArray = std::move(InValueArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.PrimitiveComponent_CopyCollisionChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InSrcComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InDstComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolFunctionLibrary::PrimitiveComponent_CopyCollisionChannel(class UPrimitiveComponent* InSrcComponent, class UPrimitiveComponent* InDstComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "PrimitiveComponent_CopyCollisionChannel");

	Params::ToolFunctionLibrary_PrimitiveComponent_CopyCollisionChannel Parms{};

	Parms.InSrcComponent = InSrcComponent;
	Parms.InDstComponent = InDstComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ToolFunctionLibrary.RemapValueRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSrcMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSrcMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDstMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDstMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::RemapValueRange(float InValue, float InSrcMin, float InSrcMax, float InDstMin, float InDstMax, float* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "RemapValueRange");

	Params::ToolFunctionLibrary_RemapValueRange Parms{};

	Parms.InValue = InValue;
	Parms.InSrcMin = InSrcMin;
	Parms.InSrcMax = InSrcMax;
	Parms.InDstMin = InDstMin;
	Parms.InDstMax = InDstMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function Extensions.ToolFunctionLibrary.SetComponentRenderPass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetComponentRenderPass(class UPrimitiveComponent* InComponent, bool bInValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetComponentRenderPass");

	Params::ToolFunctionLibrary_SetComponentRenderPass Parms{};

	Parms.InComponent = InComponent;
	Parms.bInValue = bInValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetDestructibleActorDebug_EnableDestructAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDrawDebug                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetDestructibleActorDebug_EnableDestructAll(const class UObject* InContextObject, bool InDrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetDestructibleActorDebug_EnableDestructAll");

	Params::ToolFunctionLibrary_SetDestructibleActorDebug_EnableDestructAll Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InDrawDebug = InDrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetDestructibleActorDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDrawDebug                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetDestructibleActorDebugMenu(const class UObject* InContextObject, bool InDrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetDestructibleActorDebugMenu");

	Params::ToolFunctionLibrary_SetDestructibleActorDebugMenu Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InDrawDebug = InDrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetEnemyDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDoNothingState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNoDeath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetEnemyDebugMenu(const class UObject* InContextObject, bool InDoNothingState, bool InNoDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetEnemyDebugMenu");

	Params::ToolFunctionLibrary_SetEnemyDebugMenu Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InDoNothingState = InDoNothingState;
	Parms.InNoDeath = InNoDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetPhysicalMaterialSurfaceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*                InPhysicalMaterial                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSurfaceType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetPhysicalMaterialSurfaceType(class UPhysicalMaterial* InPhysicalMaterial, int32 InSurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetPhysicalMaterialSurfaceType");

	Params::ToolFunctionLibrary_SetPhysicalMaterialSurfaceType Parms{};

	Parms.InPhysicalMaterial = InPhysicalMaterial;
	Parms.InSurfaceType = InSurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetPlayerDebug_GetAllArticles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetPlayerDebug_GetAllArticles(const class UObject* InContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetPlayerDebug_GetAllArticles");

	Params::ToolFunctionLibrary_SetPlayerDebug_GetAllArticles Parms{};

	Parms.InContextObject = InContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetPlayerDebugEnableWeaponSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bEnable                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetPlayerDebugEnableWeaponSlot(const class UObject* InContextObject, const bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetPlayerDebugEnableWeaponSlot");

	Params::ToolFunctionLibrary_SetPlayerDebugEnableWeaponSlot Parms{};

	Parms.InContextObject = InContextObject;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetPlayerDebugGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECharacterCustomizeGender         InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetPlayerDebugGender(class ACharacter* InCharacter, const ECharacterCustomizeGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetPlayerDebugGender");

	Params::ToolFunctionLibrary_SetPlayerDebugGender Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetPlayerDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InContextObject                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNoDeath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNoDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNotConsumeStamina                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNotConsumeIchor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAlwaysAllowSpecialBloodSuck                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetPlayerDebugMenu(const class UObject* InContextObject, bool InNoDeath, bool InNoDamage, bool InNotConsumeStamina, bool InNotConsumeIchor, bool InAlwaysAllowSpecialBloodSuck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetPlayerDebugMenu");

	Params::ToolFunctionLibrary_SetPlayerDebugMenu Parms{};

	Parms.InContextObject = InContextObject;
	Parms.InNoDeath = InNoDeath;
	Parms.InNoDamage = InNoDamage;
	Parms.InNotConsumeStamina = InNotConsumeStamina;
	Parms.InNotConsumeIchor = InNotConsumeIchor;
	Parms.InAlwaysAllowSpecialBloodSuck = InAlwaysAllowSpecialBloodSuck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetSceneCaptureSettingForScar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         InSceneCapture                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetSceneCaptureSettingForScar(class USceneCaptureComponent2D* InSceneCapture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetSceneCaptureSettingForScar");

	Params::ToolFunctionLibrary_SetSceneCaptureSettingForScar Parms{};

	Parms.InSceneCapture = InSceneCapture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.SetStaticMeshMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InStaticMesh                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InElementIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::SetStaticMeshMaterial(class UStaticMesh* InStaticMesh, int32 InElementIndex, class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "SetStaticMeshMaterial");

	Params::ToolFunctionLibrary_SetStaticMeshMaterial Parms{};

	Parms.InStaticMesh = InStaticMesh;
	Parms.InElementIndex = InElementIndex;
	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.Text3D_GetGlyphComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UText3DComponent*                 Text3DComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMeshComponent*>*    OutResult                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::Text3D_GetGlyphComponents(class UText3DComponent* Text3DComponent, TArray<class UStaticMeshComponent*>* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Text3D_GetGlyphComponents");

	Params::ToolFunctionLibrary_Text3D_GetGlyphComponents Parms{};

	Parms.Text3DComponent = Text3DComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function Extensions.ToolFunctionLibrary.Text3D_SetAllowCPUAccess
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UText3DComponent*                 Text3DComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::Text3D_SetAllowCPUAccess(class UText3DComponent* Text3DComponent, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Text3D_SetAllowCPUAccess");

	Params::ToolFunctionLibrary_Text3D_SetAllowCPUAccess Parms{};

	Parms.Text3DComponent = Text3DComponent;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.Text3D_TransformToCircle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UText3DComponent*                 Text3DComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InCenter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTextAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolFunctionLibrary::Text3D_TransformToCircle(class UText3DComponent* Text3DComponent, const struct FVector& InCenter, float InRadius, float InTextAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "Text3D_TransformToCircle");

	Params::ToolFunctionLibrary_Text3D_TransformToCircle Parms{};

	Parms.Text3DComponent = Text3DComponent;
	Parms.InCenter = std::move(InCenter);
	Parms.InRadius = InRadius;
	Parms.InTextAngle = InTextAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ToolFunctionLibrary.WaitRenderingThread
// (Final, Native, Static, Public, BlueprintCallable)

void UToolFunctionLibrary::WaitRenderingThread()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ToolFunctionLibrary", "WaitRenderingThread");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TimeScaleInterface.UnsetDeltaTimeScale
// (Native, Public)
// Parameters:
// const ESlowType                         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITimeScaleInterface::UnsetDeltaTimeScale(const ESlowType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "UnsetDeltaTimeScale");

	Params::TimeScaleInterface_UnsetDeltaTimeScale Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TimeScaleInterface.GetDeltaTimeScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ITimeScaleInterface::GetDeltaTimeScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "GetDeltaTimeScale");

	Params::TimeScaleInterface_GetDeltaTimeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TimeScaleInterface.GetDeltaTimeScaleByExcludeType
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<ESlowType>&                InExcludeTypes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ITimeScaleInterface::GetDeltaTimeScaleByExcludeType(const TArray<ESlowType>& InExcludeTypes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "GetDeltaTimeScaleByExcludeType");

	Params::TimeScaleInterface_GetDeltaTimeScaleByExcludeType Parms{};

	Parms.InExcludeTypes = std::move(InExcludeTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TimeScaleInterface.GetDeltaTimeScaleByType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESlowType                         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ITimeScaleInterface::GetDeltaTimeScaleByType(const ESlowType InType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "GetDeltaTimeScaleByType");

	Params::TimeScaleInterface_GetDeltaTimeScaleByType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TimeScaleInterface.GetEndNoticeTimeDeltaTimeScaleByType
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESlowType                         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITimeScaleInterface::GetEndNoticeTimeDeltaTimeScaleByType(const ESlowType InType, float* OutTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "GetEndNoticeTimeDeltaTimeScaleByType");

	Params::TimeScaleInterface_GetEndNoticeTimeDeltaTimeScaleByType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

	return Parms.ReturnValue;
}


// Function Extensions.TimeScaleInterface.GetRemainingTimeDeltaTimeScaleByType
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESlowType                         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITimeScaleInterface::GetRemainingTimeDeltaTimeScaleByType(const ESlowType InType, float* OutTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TimeScaleInterface", "GetRemainingTimeDeltaTimeScaleByType");

	Params::TimeScaleInterface_GetRemainingTimeDeltaTimeScaleByType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

	return Parms.ReturnValue;
}


// Function Extensions.MarkingObjectManager.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMarkingObjectManager*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMarkingObjectManager* UMarkingObjectManager::Get(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MarkingObjectManager", "Get");

	Params::MarkingObjectManager_Get Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MarkingObjectManager.Place
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AController*                InController                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarkingObjectManager::Place(const class AController* InController, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarkingObjectManager", "Place");

	Params::MarkingObjectManager_Place Parms{};

	Parms.InController = InController;
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor.CanUseSwitch
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASensor::CanUseSwitch(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor", "CanUseSwitch");

	Params::Sensor_CanUseSwitch Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Sensor.OnRep_ReplicatedState
// (Final, Native, Protected)

void ASensor::OnRep_ReplicatedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor", "OnRep_ReplicatedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor.OnSwitchActivated
// (Native, Protected)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor::OnSwitchActivated(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor", "OnSwitchActivated");

	Params::Sensor_OnSwitchActivated Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_Activate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::K2_Activate(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_Activate");

	Params::Sensor_Laser_K2_Activate Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_AddCommunicationFollower
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ASensor_Laser*                    InSensor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::K2_AddCommunicationFollower(class ASensor_Laser* InSensor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_AddCommunicationFollower");

	Params::Sensor_Laser_K2_AddCommunicationFollower Parms{};

	Parms.InSensor = InSensor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_ClearCommunicationFollower
// (Final, Native, Protected, BlueprintCallable)

void ASensor_Laser::K2_ClearCommunicationFollower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_ClearCommunicationFollower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_EndAlert
// (Final, Native, Protected, BlueprintCallable)

void ASensor_Laser::K2_EndAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_EndAlert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_OnSwitchActivated
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActorWhoInteract                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::K2_OnSwitchActivated(class AActor* InActorWhoInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_OnSwitchActivated");

	Params::Sensor_Laser_K2_OnSwitchActivated Parms{};

	Parms.InActorWhoInteract = InActorWhoInteract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_SetCommunicationFollower
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::K2_SetCommunicationFollower(bool bInValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_SetCommunicationFollower");

	Params::Sensor_Laser_K2_SetCommunicationFollower Parms{};

	Parms.bInValue = bInValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_StartAlert
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::K2_StartAlert(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_StartAlert");

	Params::Sensor_Laser_K2_StartAlert Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.OnAnyActorEntersAdventureTalkTrigger_Nearby
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASensor_Laser::OnAnyActorEntersAdventureTalkTrigger_Nearby(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "OnAnyActorEntersAdventureTalkTrigger_Nearby");

	Params::Sensor_Laser_OnAnyActorEntersAdventureTalkTrigger_Nearby Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.OnAnyActorLeavesAdventureTalkTrigger_Nearby
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Laser::OnAnyActorLeavesAdventureTalkTrigger_Nearby(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "OnAnyActorLeavesAdventureTalkTrigger_Nearby");

	Params::Sensor_Laser_OnAnyActorLeavesAdventureTalkTrigger_Nearby Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Laser.K2_GetLaserLocations
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FSensor_LaserLocations>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSensor_LaserLocations> ASensor_Laser::K2_GetLaserLocations() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_GetLaserLocations");

	Params::Sensor_Laser_K2_GetLaserLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Sensor_Laser.K2_IsDetected
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FHitResult>*              OutResults                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASensor_Laser::K2_IsDetected(TArray<struct FHitResult>* OutResults) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_IsDetected");

	Params::Sensor_Laser_K2_IsDetected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResults != nullptr)
		*OutResults = std::move(Parms.OutResults);

	return Parms.ReturnValue;
}


// Function Extensions.Sensor_Laser.K2_IsOnAlert
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASensor_Laser::K2_IsOnAlert() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_IsOnAlert");

	Params::Sensor_Laser_K2_IsOnAlert Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Sensor_Laser.K2_IsSensorEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASensor_Laser::K2_IsSensorEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Laser", "K2_IsSensorEnabled");

	Params::Sensor_Laser_K2_IsSensorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingObject.OnJoinSessionComplete
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FOnlineResultInformation&  InResult                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchingObject::OnJoinSessionComplete(const struct FOnlineResultInformation& InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingObject", "OnJoinSessionComplete");

	Params::MatchingObject_OnJoinSessionComplete Parms{};

	Parms.InResult = std::move(InResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingObject.OnRep_ReplicatedReplicatedAppearance
// (Final, Native, Protected)

void AMatchingObject::OnRep_ReplicatedReplicatedAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingObject", "OnRep_ReplicatedReplicatedAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TransactionsMenuTestActor.CanReceivePresent
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransactionsMenuTestActor::CanReceivePresent(const struct FGameplayTag& InBuddyTag, const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "CanReceivePresent");

	Params::TransactionsMenuTestActor_CanReceivePresent Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetIsUsingTestData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransactionsMenuTestActor::GetIsUsingTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetIsUsingTestData");

	Params::TransactionsMenuTestActor_GetIsUsingTestData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetPlayerStatusSummaryInfo");

	Params::TransactionsMenuTestActor_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.TransactionsMenuTestActor.GetPresentItemUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::GetPresentItemUIInfo(const int32 InIndex, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetPresentItemUIInfo");

	Params::TransactionsMenuTestActor_GetPresentItemUIInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.TransactionsMenuTestActor.GetPresentNumber
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ATransactionsMenuTestActor::GetPresentNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetPresentNumber");

	Params::TransactionsMenuTestActor_GetPresentNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetTradeItemCategory
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArticleCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EArticleCategory ATransactionsMenuTestActor::GetTradeItemCategory(const struct FGameplayTag& InBuddyTag, const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetTradeItemCategory");

	Params::TransactionsMenuTestActor_GetTradeItemCategory Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetTradeItemUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::GetTradeItemUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIItemInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetTradeItemUIInfo");

	Params::TransactionsMenuTestActor_GetTradeItemUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuTestActor.GetTradeListNumber
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ATransactionsMenuTestActor::GetTradeListNumber(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetTradeListNumber");

	Params::TransactionsMenuTestActor_GetTradeListNumber Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetTradePoint
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ATransactionsMenuTestActor::GetTradePoint(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetTradePoint");

	Params::TransactionsMenuTestActor_GetTradePoint Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TransactionsMenuTestActor.GetTradeWeaponUIInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::GetTradeWeaponUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIWeaponInfo* OutInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "GetTradeWeaponUIInfo");

	Params::TransactionsMenuTestActor_GetTradeWeaponUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.TransactionsMenuTestActor.RequestPresent
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::RequestPresent(const struct FGameplayTag& InBuddyTag, const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "RequestPresent");

	Params::TransactionsMenuTestActor_RequestPresent Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TransactionsMenuTestActor.RequestTrade
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransactionsMenuTestActor::RequestTrade(const struct FGameplayTag& InBuddyTag, const int32 InIndex, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "RequestTrade");

	Params::TransactionsMenuTestActor_RequestTrade Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TransactionsMenuTestActor.RequestUseTestData
// (Final, Native, Public, BlueprintCallable)

void ATransactionsMenuTestActor::RequestUseTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "RequestUseTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TransactionsMenuTestActor.TradePointCheckAndConsume
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransactionsMenuTestActor::TradePointCheckAndConsume(const struct FGameplayTag& InBuddyTag, const int32 InIndex, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransactionsMenuTestActor", "TradePointCheckAndConsume");

	Params::TransactionsMenuTestActor_TradePointCheckAndConsume Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.GetResourceGaugeLengthType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EResourceGaugeLengthType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EResourceGaugeLengthType UMatchingPlayerIndicatorUIObject::GetResourceGaugeLengthType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "GetResourceGaugeLengthType");

	Params::MatchingPlayerIndicatorUIObject_GetResourceGaugeLengthType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.InitializeIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentHealth                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InCurrentBarrierPoint                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBarrierPoint                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::InitializeIndicator(const float InCurrentHealth, const float InMaxHealth, const float InCurrentBarrierPoint, const float InMaxBarrierPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "InitializeIndicator");

	Params::MatchingPlayerIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InCurrentHealth = InCurrentHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InCurrentBarrierPoint = InCurrentBarrierPoint;
	Parms.InMaxBarrierPoint = InMaxBarrierPoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.NotifyAccumulateStateValueChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMatchingPlayerIndicatorUIObject::NotifyAccumulateStateValueChange(const struct FGameplayTag& InEffectTag, const struct FAccumulateAttributeUIInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "NotifyAccumulateStateValueChange");

	Params::MatchingPlayerIndicatorUIObject_NotifyAccumulateStateValueChange Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.NotifyBarrierPointChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentBarrierPoint                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxBarrierPoint                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::NotifyBarrierPointChanged(const float InCurrentBarrierPoint, const float InMaxBarrierPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "NotifyBarrierPointChanged");

	Params::MatchingPlayerIndicatorUIObject_NotifyBarrierPointChanged Parms{};

	Parms.InCurrentBarrierPoint = InCurrentBarrierPoint;
	Parms.InMaxBarrierPoint = InMaxBarrierPoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.NotifyHealthChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentHealth                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::NotifyHealthChanged(const float InCurrentHealth, const float InMaxHealth, const EResourceChangeFactor InChangeFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "NotifyHealthChanged");

	Params::MatchingPlayerIndicatorUIObject_NotifyHealthChanged Parms{};

	Parms.InCurrentHealth = InCurrentHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InChangeFactor = InChangeFactor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.SetBarrierGaugeVisible
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::SetBarrierGaugeVisible(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "SetBarrierGaugeVisible");

	Params::MatchingPlayerIndicatorUIObject_SetBarrierGaugeVisible Parms{};

	Parms.InVisible = InVisible;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.SetName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      InNameText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::SetName(const class FText& InNameText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "SetName");

	Params::MatchingPlayerIndicatorUIObject_SetName Parms{};

	Parms.InNameText = std::move(InNameText);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.SetTargetActor
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTargetSocket                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::SetTargetActor(class AActor* InTargetActor, class FName InTargetSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "SetTargetActor");

	Params::MatchingPlayerIndicatorUIObject_SetTargetActor Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InTargetSocket = InTargetSocket;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingPlayerIndicatorUIObject.UpdateAccumulateStateValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FAccumulateGaugeInfo&      InGaugeInfo                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InAttributeInfo                                        (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingPlayerIndicatorUIObject::UpdateAccumulateStateValue(const struct FAccumulateGaugeInfo& InGaugeInfo, const struct FAccumulateAttributeUIInfo& InAttributeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingPlayerIndicatorUIObject", "UpdateAccumulateStateValue");

	Params::MatchingPlayerIndicatorUIObject_UpdateAccumulateStateValue Parms{};

	Parms.InGaugeInfo = std::move(InGaugeInfo);
	Parms.InAttributeInfo = std::move(InAttributeInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.GetGestureName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMatchingUIObject::GetGestureName(class FName InRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "GetGestureName");

	Params::MatchingUIObject_GetGestureName Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.GetMultiplayState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMultiplayState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMultiplayState UMatchingUIObject::GetMultiplayState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "GetMultiplayState");

	Params::MatchingUIObject_GetMultiplayState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.InvitePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::InvitePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "InvitePlayer");

	Params::MatchingUIObject_InvitePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.IsEnableInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::IsEnableInvite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "IsEnableInvite");

	Params::MatchingUIObject_IsEnableInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.IsInStandbyPreparation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::IsInStandbyPreparation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "IsInStandbyPreparation");

	Params::MatchingUIObject_IsInStandbyPreparation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.IsInStandbyReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::IsInStandbyReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "IsInStandbyReady");

	Params::MatchingUIObject_IsInStandbyReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.IsSearching
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::IsSearching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "IsSearching");

	Params::MatchingUIObject_IsSearching Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.LeaveMultiplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::LeaveMultiplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "LeaveMultiplay");

	Params::MatchingUIObject_LeaveMultiplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.SearchHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::SearchHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "SearchHelper");

	Params::MatchingUIObject_SearchHelper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MatchingUIObject.SetEnabledSearchHelperMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchingUIObject::SetEnabledSearchHelperMenu(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "SetEnabledSearchHelperMenu");

	Params::MatchingUIObject_SetEnabledSearchHelperMenu Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MatchingUIObject.StandbyAsHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESearchObjectType                       InSearchType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingUIObject::StandbyAsHelper(ESearchObjectType InSearchType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchingUIObject", "StandbyAsHelper");

	Params::MatchingUIObject_StandbyAsHelper Parms{};

	Parms.InSearchType = InSearchType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MaterialFunctionLibrary.BreakCustomStencilValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InStencil                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutBit1                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutBit2                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutBit3                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutIntValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialFunctionLibrary::BreakCustomStencilValue(const int32 InStencil, bool* OutBit1, bool* OutBit2, bool* OutBit3, int32* OutIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "BreakCustomStencilValue");

	Params::MaterialFunctionLibrary_BreakCustomStencilValue Parms{};

	Parms.InStencil = InStencil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBit1 != nullptr)
		*OutBit1 = Parms.OutBit1;

	if (OutBit2 != nullptr)
		*OutBit2 = Parms.OutBit2;

	if (OutBit3 != nullptr)
		*OutBit3 = Parms.OutBit3;

	if (OutIntValue != nullptr)
		*OutIntValue = Parms.OutIntValue;
}


// Function Extensions.MaterialFunctionLibrary.CreateDynamicMaterialInstanceBySlotName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSlotName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               SourceMaterial                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UMaterialFunctionLibrary::CreateDynamicMaterialInstanceBySlotName(class UMeshComponent* InMeshComponent, class FName InSlotName, class UMaterialInterface* SourceMaterial, class FName OptionalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "CreateDynamicMaterialInstanceBySlotName");

	Params::MaterialFunctionLibrary_CreateDynamicMaterialInstanceBySlotName Parms{};

	Parms.InMeshComponent = InMeshComponent;
	Parms.InSlotName = InSlotName;
	Parms.SourceMaterial = SourceMaterial;
	Parms.OptionalName = OptionalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MaterialFunctionLibrary.MakeCustomStencilValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBit1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InBit2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InBit3                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIntValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaterialFunctionLibrary::MakeCustomStencilValue(bool InBit1, bool InBit2, bool InBit3, const int32 InIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "MakeCustomStencilValue");

	Params::MaterialFunctionLibrary_MakeCustomStencilValue Parms{};

	Parms.InBit1 = InBit1;
	Parms.InBit2 = InBit2;
	Parms.InBit3 = InBit3;
	Parms.InIntValue = InIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MaterialFunctionLibrary.SetCustomStencilValue_EnableIsPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialFunctionLibrary::SetCustomStencilValue_EnableIsPlayer(class UPrimitiveComponent* InComponent, const bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "SetCustomStencilValue_EnableIsPlayer");

	Params::MaterialFunctionLibrary_SetCustomStencilValue_EnableIsPlayer Parms{};

	Parms.InComponent = InComponent;
	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MaterialFunctionLibrary.SetCustomStencilValue_EnableNoDesaturation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialFunctionLibrary::SetCustomStencilValue_EnableNoDesaturation(class UPrimitiveComponent* InComponent, const bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "SetCustomStencilValue_EnableNoDesaturation");

	Params::MaterialFunctionLibrary_SetCustomStencilValue_EnableNoDesaturation Parms{};

	Parms.InComponent = InComponent;
	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MaterialFunctionLibrary.SetCustomStencilValue_EnableScanEdge
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialFunctionLibrary::SetCustomStencilValue_EnableScanEdge(class UPrimitiveComponent* InComponent, const bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "SetCustomStencilValue_EnableScanEdge");

	Params::MaterialFunctionLibrary_SetCustomStencilValue_EnableScanEdge Parms{};

	Parms.InComponent = InComponent;
	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MaterialFunctionLibrary.SetCustomStencilValue_IntValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIntValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialFunctionLibrary::SetCustomStencilValue_IntValue(class UPrimitiveComponent* InComponent, const int32 InIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialFunctionLibrary", "SetCustomStencilValue_IntValue");

	Params::MaterialFunctionLibrary_SetCustomStencilValue_IntValue Parms{};

	Parms.InComponent = InComponent;
	Parms.InIntValue = InIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MiniMapManager.CalcWideModeImageBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UMiniMapManager::CalcWideModeImageBounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapManager", "CalcWideModeImageBounds");

	Params::MiniMapManager_CalcWideModeImageBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MiniMapManager.GetIsMiniMapDisplayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMiniMapManager::GetIsMiniMapDisplayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapManager", "GetIsMiniMapDisplayed");

	Params::MiniMapManager_GetIsMiniMapDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MiniMapManager.OnChangeStoryFlag
// (Final, Native, Protected)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMiniMapManager::OnChangeStoryFlag(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapManager", "OnChangeStoryFlag");

	Params::MiniMapManager_OnChangeStoryFlag Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MistWall_Temp.OnComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMistWall_Temp::OnComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MistWall_Temp", "OnComponentBeginOverlap");

	Params::MistWall_Temp_OnComponentBeginOverlap Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MistWall_Temp.OnComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMistWall_Temp::OnComponentEndOverlap(class UPrimitiveComponent* InOverlappedComp, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MistWall_Temp", "OnComponentEndOverlap");

	Params::MistWall_Temp_OnComponentEndOverlap Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BindOnChengeActionGuideVisibleEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::BindOnChengeActionGuideVisibleEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BindOnChengeActionGuideVisibleEvent");

	Params::RadialMenuSystem_BindOnChengeActionGuideVisibleEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BindOnChengeLargeHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::BindOnChengeLargeHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BindOnChengeLargeHealShortCutEvent");

	Params::RadialMenuSystem_BindOnChengeLargeHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BindOnChengeMediumHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::BindOnChengeMediumHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BindOnChengeMediumHealShortCutEvent");

	Params::RadialMenuSystem_BindOnChengeMediumHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BindOnChengeSmallHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::BindOnChengeSmallHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BindOnChengeSmallHealShortCutEvent");

	Params::RadialMenuSystem_BindOnChengeSmallHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BindOnChengeStanceEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::BindOnChengeStanceEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BindOnChengeStanceEvent");

	Params::RadialMenuSystem_BindOnChengeStanceEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BroadCastOnChengeActionGuideVisibleEvent
// (Final, Native, Public, BlueprintCallable)

void URadialMenuSystem::BroadCastOnChengeActionGuideVisibleEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BroadCastOnChengeActionGuideVisibleEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BroadCastOnChengeLargeHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)

void URadialMenuSystem::BroadCastOnChengeLargeHealShortCutEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BroadCastOnChengeLargeHealShortCutEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BroadCastOnChengeMediumHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)

void URadialMenuSystem::BroadCastOnChengeMediumHealShortCutEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BroadCastOnChengeMediumHealShortCutEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BroadCastOnChengeSmallHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)

void URadialMenuSystem::BroadCastOnChengeSmallHealShortCutEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BroadCastOnChengeSmallHealShortCutEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.BroadCastOnChengeStanceEvent
// (Final, Native, Public, BlueprintCallable)

void URadialMenuSystem::BroadCastOnChengeStanceEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "BroadCastOnChengeStanceEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.UnbindOnChengeActionGuideVisibleEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::UnbindOnChengeActionGuideVisibleEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "UnbindOnChengeActionGuideVisibleEvent");

	Params::RadialMenuSystem_UnbindOnChengeActionGuideVisibleEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.UnBindOnChengeLargeHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::UnBindOnChengeLargeHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "UnBindOnChengeLargeHealShortCutEvent");

	Params::RadialMenuSystem_UnBindOnChengeLargeHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.UnBindOnChengeMediumHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::UnBindOnChengeMediumHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "UnBindOnChengeMediumHealShortCutEvent");

	Params::RadialMenuSystem_UnBindOnChengeMediumHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.UnBindOnChengeSmallHealShortCutEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::UnBindOnChengeSmallHealShortCutEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "UnBindOnChengeSmallHealShortCutEvent");

	Params::RadialMenuSystem_UnBindOnChengeSmallHealShortCutEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadialMenuSystem.UnBindOnChengeStanceEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Value)>             InDelegate                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialMenuSystem::UnBindOnChengeStanceEvent(TDelegate<void(bool Value)> InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialMenuSystem", "UnBindOnChengeStanceEvent");

	Params::RadialMenuSystem_UnBindOnChengeStanceEvent Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StandAloneGadget_Iaitou.DrawnSword
// (Final, Native, Public, BlueprintCallable)

void AStandAloneGadget_Iaitou::DrawnSword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StandAloneGadget_Iaitou", "DrawnSword");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageComponent.ClearHitDamageCoolTime
// (Final, Native, Private)

void UMountDamageComponent::ClearHitDamageCoolTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "ClearHitDamageCoolTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageComponent.OnHitPhysicsCollision
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMountDamageComponent::OnHitPhysicsCollision(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "OnHitPhysicsCollision");

	Params::MountDamageComponent_OnHitPhysicsCollision Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageComponent.OnRecoverCooltimeFinished
// (Final, Native, Private)

void UMountDamageComponent::OnRecoverCooltimeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "OnRecoverCooltimeFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageComponent.SetUIVisibility
// (Final, Native, Private)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountDamageComponent::SetUIVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "SetUIVisibility");

	Params::MountDamageComponent_SetUIVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageComponent.GetMaxMountHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountDamageComponent::GetMaxMountHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "GetMaxMountHealth");

	Params::MountDamageComponent_GetMaxMountHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountDamageComponent.GetMountHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountDamageComponent::GetMountHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageComponent", "GetMountHealth");

	Params::MountDamageComponent_GetMountHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountDamageGimmickReceive.EndTimer_Floor
// (Final, Native, Protected)
// Parameters:
// class FName                             InGimmickID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountDamageGimmickReceive::EndTimer_Floor(class FName InGimmickID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageGimmickReceive", "EndTimer_Floor");

	Params::MountDamageGimmickReceive_EndTimer_Floor Parms{};

	Parms.InGimmickID = InGimmickID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageGimmickReceive.EndTimer_OverlapGimmick
// (Final, Native, Protected)
// Parameters:
// class FName                             InGimmickID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountDamageGimmickReceive::EndTimer_OverlapGimmick(class FName InGimmickID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageGimmickReceive", "EndTimer_OverlapGimmick");

	Params::MountDamageGimmickReceive_EndTimer_OverlapGimmick Parms{};

	Parms.InGimmickID = InGimmickID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageGimmickReceive.OnComponentBeginOverlap_DamageGimmick
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOther                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMountDamageGimmickReceive::OnComponentBeginOverlap_DamageGimmick(class UPrimitiveComponent* InOverlappedComp, class AActor* InOther, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool InbFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageGimmickReceive", "OnComponentBeginOverlap_DamageGimmick");

	Params::MountDamageGimmickReceive_OnComponentBeginOverlap_DamageGimmick Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOther = InOther;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.InbFromSweep = InbFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountDamageGimmickReceive.OnComponentEndOverlap_DamageGimmick
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOther                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountDamageGimmickReceive::OnComponentEndOverlap_DamageGimmick(class UPrimitiveComponent* InOverlappedComp, class AActor* InOther, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountDamageGimmickReceive", "OnComponentEndOverlap_DamageGimmick");

	Params::MountDamageGimmickReceive_OnComponentEndOverlap_DamageGimmick Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOther = InOther;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioStartVolume.MulticastStartSmallScenario
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ASmallScenarioStartVolume::MulticastStartSmallScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioStartVolume", "MulticastStartSmallScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SmallScenarioStartVolume.OnSmallScenarioEnded
// (Final, Native, Private)

void ASmallScenarioStartVolume::OnSmallScenarioEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmallScenarioStartVolume", "OnSmallScenarioEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlParameterInterface.GetVisualControlParameter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UVisualControlParameter*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UVisualControlParameter* IVisualControlParameterInterface::GetVisualControlParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("VisualControlParameterInterface", "GetVisualControlParameter");

	Params::VisualControlParameterInterface_GetVisualControlParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountEventComponent.OnChangeGlideInput
// (Final, Native, Protected)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountEventComponent::OnChangeGlideInput(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountEventComponent", "OnChangeGlideInput");

	Params::MountEventComponent_OnChangeGlideInput Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountGameplayAbility.GettingOffMount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountGameplayAbility::GettingOffMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "GettingOffMount");

	Params::MountGameplayAbility_GettingOffMount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountGameplayAbility.MountAerialJump
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   AdditionalVelocity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountGameplayAbility::MountAerialJump(const struct FVector& AdditionalVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "MountAerialJump");

	Params::MountGameplayAbility_MountAerialJump Parms{};

	Parms.AdditionalVelocity = std::move(AdditionalVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountGameplayAbility.MountEmitNoiseByID
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FName                       InID                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountGameplayAbility::MountEmitNoiseByID(const class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "MountEmitNoiseByID");

	Params::MountGameplayAbility_MountEmitNoiseByID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountGameplayAbility.SetIsVehicleInAir
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsInAir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountGameplayAbility::SetIsVehicleInAir(bool bIsInAir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "SetIsVehicleInAir");

	Params::MountGameplayAbility_SetIsVehicleInAir Parms{};

	Parms.bIsInAir = bIsInAir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountGameplayAbility.SpawnAndRideMount
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                SpawnLocalTransform                                    (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountGameplayAbility::SpawnAndRideMount(const struct FTransform& SpawnLocalTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "SpawnAndRideMount");

	Params::MountGameplayAbility_SpawnAndRideMount Parms{};

	Parms.SpawnLocalTransform = std::move(SpawnLocalTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountGameplayAbility.GetOwnerMountControlComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMountControlComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMountControlComponent* UMountGameplayAbility::GetOwnerMountControlComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "GetOwnerMountControlComponent");

	Params::MountGameplayAbility_GetOwnerMountControlComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountGameplayAbility.GetVehicle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAppWheeledVehiclePawn*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAppWheeledVehiclePawn* UMountGameplayAbility::GetVehicle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountGameplayAbility", "GetVehicle");

	Params::MountGameplayAbility_GetVehicle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.AppearMount
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UMountVisualControlComponent::AppearMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "AppearMount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.MountVisualControlComponent.DisappearMount
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EUnsummonReason                         Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountVisualControlComponent::DisappearMount(EUnsummonReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "DisappearMount");

	Params::MountVisualControlComponent_DisappearMount Parms{};

	Parms.Reason = Reason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.MountVisualControlComponent.GetMountActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAppWheeledVehiclePawn*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAppWheeledVehiclePawn* UMountVisualControlComponent::GetMountActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetMountActor");

	Params::MountVisualControlComponent_GetMountActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.GetMountMesh
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UMountVisualControlComponent::GetMountMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetMountMesh");

	Params::MountVisualControlComponent_GetMountMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.GetSpeedBlurEffect_DebugDrawScreenRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountVisualControlComponent::GetSpeedBlurEffect_DebugDrawScreenRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetSpeedBlurEffect_DebugDrawScreenRange");

	Params::MountVisualControlComponent_GetSpeedBlurEffect_DebugDrawScreenRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.GetSpeedBlurEffect_EnableDebug
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountVisualControlComponent::GetSpeedBlurEffect_EnableDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetSpeedBlurEffect_EnableDebug");

	Params::MountVisualControlComponent_GetSpeedBlurEffect_EnableDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.GetSpeedBlurEffect_ScreenRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountVisualControlComponent::GetSpeedBlurEffect_ScreenRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetSpeedBlurEffect_ScreenRange");

	Params::MountVisualControlComponent_GetSpeedBlurEffect_ScreenRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.GetSpeedBlurEffect_Weight
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMountVisualControlComponent::GetSpeedBlurEffect_Weight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "GetSpeedBlurEffect_Weight");

	Params::MountVisualControlComponent_GetSpeedBlurEffect_Weight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.IsDisableSpeedBlurEffect
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountVisualControlComponent::IsDisableSpeedBlurEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "IsDisableSpeedBlurEffect");

	Params::MountVisualControlComponent_IsDisableSpeedBlurEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.IsDisableWheelRadialMotionBlur
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMountVisualControlComponent::IsDisableWheelRadialMotionBlur()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "IsDisableWheelRadialMotionBlur");

	Params::MountVisualControlComponent_IsDisableWheelRadialMotionBlur Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountVisualControlComponent.OnFinishDisappear
// (Final, Native, Public, BlueprintCallable)

void UMountVisualControlComponent::OnFinishDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "OnFinishDisappear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountVisualControlComponent.OnNoMount
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMountVisualControlComponent::OnNoMount(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "OnNoMount");

	Params::MountVisualControlComponent_OnNoMount Parms{};

	Parms.InHitResult = std::move(InHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.MountVisualControlComponent.OverrideWheelTrackDecal
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FDecalSpawnParameters*           OutSpawnInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDecalSpawnParameters&     InSpawnInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   LastSpawnedLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMountVisualControlComponent::OverrideWheelTrackDecal(struct FDecalSpawnParameters* OutSpawnInfo, const struct FDecalSpawnParameters& InSpawnInfo, const struct FVector& LastSpawnedLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountVisualControlComponent", "OverrideWheelTrackDecal");

	Params::MountVisualControlComponent_OverrideWheelTrackDecal Parms{};

	Parms.InSpawnInfo = std::move(InSpawnInfo);
	Parms.LastSpawnedLocation = std::move(LastSpawnedLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSpawnInfo != nullptr)
		*OutSpawnInfo = std::move(Parms.OutSpawnInfo);
}


// Function Extensions.VisualizationFunctionLibrary.DrawMoveDestination
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualizationFunctionLibrary::DrawMoveDestination(class UObject* WorldContextObject, const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualizationFunctionLibrary", "DrawMoveDestination");

	Params::VisualizationFunctionLibrary_DrawMoveDestination Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Destination = std::move(Destination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualizationFunctionLibrary.DrawMoveDestinationByEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualizationFunctionLibrary::DrawMoveDestinationByEnemy(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualizationFunctionLibrary", "DrawMoveDestinationByEnemy");

	Params::VisualizationFunctionLibrary_DrawMoveDestinationByEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualizationFunctionLibrary.DrawMovePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVisualizationFunctionLibrary::DrawMovePath(class UObject* WorldContextObject, const TArray<struct FVector>& Paths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualizationFunctionLibrary", "DrawMovePath");

	Params::VisualizationFunctionLibrary_DrawMovePath Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Paths = std::move(Paths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualizationFunctionLibrary.DrawMovePathByEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualizationFunctionLibrary::DrawMovePathByEnemy(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualizationFunctionLibrary", "DrawMovePathByEnemy");

	Params::VisualizationFunctionLibrary_DrawMovePathByEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfAddIn_Jump.OnApex
// (Final, Native, Private)

void UMountWolfAddIn_Jump::OnApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfAddIn_Jump", "OnApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfAddIn_Jump.OnLanded
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                InHit                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMountWolfAddIn_Jump::OnLanded(const struct FHitResult& InHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfAddIn_Jump", "OnLanded");

	Params::MountWolfAddIn_Jump_OnLanded Parms{};

	Parms.InHit = std::move(InHit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.MountWolfSettings.GetHowlingSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMountWolfHowlingSettings*  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMountWolfHowlingSettings* UMountWolfSettings::GetHowlingSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfSettings", "GetHowlingSettings");

	Params::MountWolfSettings_GetHowlingSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfSettings.GetJumpSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMountWolfJumpSettings*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMountWolfJumpSettings* UMountWolfSettings::GetJumpSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfSettings", "GetJumpSettings");

	Params::MountWolfSettings_GetJumpSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MountWolfSettings.GetMovementSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMountWolfMovementSettings* ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMountWolfMovementSettings* UMountWolfSettings::GetMovementSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountWolfSettings", "GetMovementSettings");

	Params::MountWolfSettings_GetMovementSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.MouseToolFunctionLibrary.GetMoveFromToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutFromLocation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutToLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMouseToolFunctionLibrary::GetMoveFromToLocation(const class UObject* InWorldContext, bool* OutIsValid, struct FVector* OutFromLocation, struct FVector* OutToLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MouseToolFunctionLibrary", "GetMoveFromToLocation");

	Params::MouseToolFunctionLibrary_GetMoveFromToLocation Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

	if (OutFromLocation != nullptr)
		*OutFromLocation = std::move(Parms.OutFromLocation);

	if (OutToLocation != nullptr)
		*OutToLocation = std::move(Parms.OutToLocation);
}


// Function Extensions.MouseToolFunctionLibrary.GetMoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMouseToolFunctionLibrary::GetMoveToLocation(const class UObject* InWorldContext, bool* OutIsValid, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MouseToolFunctionLibrary", "GetMoveToLocation");

	Params::MouseToolFunctionLibrary_GetMoveToLocation Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);
}


// Function Extensions.MultiNavLinkProxy.SetAllNavLinkEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMultiNavLinkProxy::SetAllNavLinkEnabled(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiNavLinkProxy", "SetAllNavLinkEnabled");

	Params::MultiNavLinkProxy_SetAllNavLinkEnabled Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NewGamePlusTrigger.OnDialogDecided
// (Native, Protected)
// Parameters:
// const uint8                             DecideOptionNumber                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANewGamePlusTrigger::OnDialogDecided(const uint8 DecideOptionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewGamePlusTrigger", "OnDialogDecided");

	Params::NewGamePlusTrigger_OnDialogDecided Parms{};

	Parms.DecideOptionNumber = DecideOptionNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopManager.InitShopMenu
// (Final, Native, Private)

void UShopManager::InitShopMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "InitShopMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopManager.OnChangeStoryFlag
// (Final, Native, Public)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnChangeStoryFlag(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnChangeStoryFlag");

	Params::ShopManager_OnChangeStoryFlag Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopManager.OnExecuteBuyAndSell
// (Final, Native, Private)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             InQuantity                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopManager::OnExecuteBuyAndSell(const struct FUIShopQueryInfo& InShopQuery, const int32 InQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnExecuteBuyAndSell");

	Params::ShopManager_OnExecuteBuyAndSell Parms{};

	Parms.InShopQuery = std::move(InShopQuery);
	Parms.InQuantity = InQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnExecuteTrade
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InNum                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManager::OnExecuteTrade(const struct FGameplayTag& InBuddyTag, const int32 InIndex, const int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnExecuteTrade");

	Params::ShopManager_OnExecuteTrade Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;
	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopManager.OnGetBloodCodeArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetBloodCodeArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIBloodCodeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetBloodCodeArticleUIInfo");

	Params::ShopManager_OnGetBloodCodeArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetBoosterArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetBoosterArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetBoosterArticleUIInfo");

	Params::ShopManager_OnGetBoosterArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetDefenceArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetDefenceArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetDefenceArticleUIInfo");

	Params::ShopManager_OnGetDefenceArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetEquipedWeaponArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InWeaponSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetEquipedWeaponArticleUIInfo(const EUIWeaponSlot InWeaponSlot, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetEquipedWeaponArticleUIInfo");

	Params::ShopManager_OnGetEquipedWeaponArticleUIInfo Parms{};

	Parms.InWeaponSlot = InWeaponSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetEquippedDefensiveGadgetInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetEquippedDefensiveGadgetInfo(struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetEquippedDefensiveGadgetInfo");

	Params::ShopManager_OnGetEquippedDefensiveGadgetInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetEquippedJailInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetEquippedJailInfo(struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetEquippedJailInfo");

	Params::ShopManager_OnGetEquippedJailInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetItemArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetItemArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetItemArticleUIInfo");

	Params::ShopManager_OnGetItemArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetItemInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetItemInfo(const int32 InIndex, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetItemInfo");

	Params::ShopManager_OnGetItemInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetJailArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetJailArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetJailArticleUIInfo");

	Params::ShopManager_OnGetJailArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetPresentNum
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UShopManager::OnGetPresentNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetPresentNum");

	Params::ShopManager_OnGetPresentNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnGetProductInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FShopStockUIInfo*                OutStockInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetProductInfo(const struct FUIShopQueryInfo& InShopQuery, struct FShopStockUIInfo* OutStockInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetProductInfo");

	Params::ShopManager_OnGetProductInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStockInfo != nullptr)
		*OutStockInfo = std::move(Parms.OutStockInfo);
}


// Function Extensions.ShopManager.OnGetProductNum
// (Final, Native, Private)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UShopManager::OnGetProductNum(const class FName InShopName, const EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetProductNum");

	Params::ShopManager_OnGetProductNum Parms{};

	Parms.InShopName = InShopName;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnGetStandAloneGadgetArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetStandAloneGadgetArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetStandAloneGadgetArticleUIInfo");

	Params::ShopManager_OnGetStandAloneGadgetArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetTradeArticleCategory
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArticleCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EArticleCategory UShopManager::OnGetTradeArticleCategory(const struct FGameplayTag& InBuddyTag, const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeArticleCategory");

	Params::ShopManager_OnGetTradeArticleCategory Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnGetTradeArticleNum
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UShopManager::OnGetTradeArticleNum(const struct FGameplayTag& InBuddyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeArticleNum");

	Params::ShopManager_OnGetTradeArticleNum Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnGetTradeBoosterUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeBoosterUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIBoosterInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeBoosterUIInfo");

	Params::ShopManager_OnGetTradeBoosterUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradeDefensiveGadgetUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeDefensiveGadgetUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIDefensiveGadgetInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeDefensiveGadgetUIInfo");

	Params::ShopManager_OnGetTradeDefensiveGadgetUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradeIndependentGadgetUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeIndependentGadgetUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIIndependentGadgetInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeIndependentGadgetUIInfo");

	Params::ShopManager_OnGetTradeIndependentGadgetUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradeItemUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeItemUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIItemInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeItemUIInfo");

	Params::ShopManager_OnGetTradeItemUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradeJailUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeJailUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIJailInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeJailUIInfo");

	Params::ShopManager_OnGetTradeJailUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradePoint
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UShopManager::OnGetTradePoint(const struct FGameplayTag& InBuddyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradePoint");

	Params::ShopManager_OnGetTradePoint Parms{};

	Parms.InBuddyType = std::move(InBuddyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopManager.OnGetTradeWeaponGadgetUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeWeaponGadgetUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIWeaponGadgetInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeWeaponGadgetUIInfo");

	Params::ShopManager_OnGetTradeWeaponGadgetUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetTradeWeaponUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutItemInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FTTransactionsUIInfo*            OutTradeInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopManager::OnGetTradeWeaponUIInfo(const struct FGameplayTag& InBuddyTag, const int32 InIndex, struct FUIWeaponInfo* OutItemInfo, struct FTTransactionsUIInfo* OutTradeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetTradeWeaponUIInfo");

	Params::ShopManager_OnGetTradeWeaponUIInfo Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	if (OutTradeInfo != nullptr)
		*OutTradeInfo = std::move(Parms.OutTradeInfo);
}


// Function Extensions.ShopManager.OnGetWeaponAddOnGadgetArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetWeaponAddOnGadgetArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetWeaponAddOnGadgetArticleUIInfo");

	Params::ShopManager_OnGetWeaponAddOnGadgetArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGetWeaponArticleUIInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopManager::OnGetWeaponArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGetWeaponArticleUIInfo");

	Params::ShopManager_OnGetWeaponArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopManager.OnGivePresent
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              InBuddyTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManager::OnGivePresent(const struct FGameplayTag& InBuddyTag, const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnGivePresent");

	Params::ShopManager_OnGivePresent Parms{};

	Parms.InBuddyTag = std::move(InBuddyTag);
	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopManager.OnInitMenu
// (Final, Native, Private)
// Parameters:
// TSoftClassPtr<class UClass>             InUIObjectClass                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManager::OnInitMenu(TSoftClassPtr<class UClass> InUIObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManager", "OnInitMenu");

	Params::ShopManager_OnInitMenu Parms{};

	Parms.InUIObjectClass = InUIObjectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VacuumComponent.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVacuumComponent::OnOverlapBegin(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VacuumComponent", "OnOverlapBegin");

	Params::VacuumComponent_OnOverlapBegin Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VacuumComponent.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVacuumComponent::OnOverlapEnd(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VacuumComponent", "OnOverlapEnd");

	Params::VacuumComponent_OnOverlapEnd Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.UserInterfaceFunctionLibrary.AsDateTimeWithCustomFormat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InFormat                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDateTime&                 InDateTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUserInterfaceFunctionLibrary::AsDateTimeWithCustomFormat(const class FString& InFormat, const struct FDateTime& InDateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "AsDateTimeWithCustomFormat");

	Params::UserInterfaceFunctionLibrary_AsDateTimeWithCustomFormat Parms{};

	Parms.InFormat = std::move(InFormat);
	Parms.InDateTime = std::move(InDateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.UserInterfaceFunctionLibrary.GetNumPrecompilesRemaining
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInterfaceFunctionLibrary::GetNumPrecompilesRemaining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetNumPrecompilesRemaining");

	Params::UserInterfaceFunctionLibrary_GetNumPrecompilesRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.UserInterfaceFunctionLibrary.IsGameFlagValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InGameFlag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsGameFlagValid(class UObject* InWorldContext, const struct FGameplayTag& InGameFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsGameFlagValid");

	Params::UserInterfaceFunctionLibrary_IsGameFlagValid Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InGameFlag = std::move(InGameFlag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.UserInterfaceFunctionLibrary.ParseIntoArrayLines
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutLines                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::ParseIntoArrayLines(const class FString& InString, TArray<class FString>* OutLines)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ParseIntoArrayLines");

	Params::UserInterfaceFunctionLibrary_ParseIntoArrayLines Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLines != nullptr)
		*OutLines = std::move(Parms.OutLines);
}


// Function Extensions.NPCManager.AddNearJadwiga
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InJadwigaTag                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::AddNearJadwiga(const struct FGameplayTag& InJadwigaTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "AddNearJadwiga");

	Params::NPCManager_AddNearJadwiga Parms{};

	Parms.InJadwigaTag = std::move(InJadwigaTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NPCManager.RemoveNearJadwiga
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InJadwigaTag                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::RemoveNearJadwiga(const struct FGameplayTag& InJadwigaTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "RemoveNearJadwiga");

	Params::NPCManager_RemoveNearJadwiga Parms{};

	Parms.InJadwigaTag = std::move(InJadwigaTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.NPCManager.GetVisibleJadwigaCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNPCManager::GetVisibleJadwigaCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetVisibleJadwigaCount");

	Params::NPCManager_GetVisibleJadwigaCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ParamBonusControlComponent.FindParamBonusControlComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParamBonusControlComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParamBonusControlComponent* UParamBonusControlComponent::FindParamBonusControlComponent(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ParamBonusControlComponent", "FindParamBonusControlComponent");

	Params::ParamBonusControlComponent_FindParamBonusControlComponent Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ParamBonusControlComponent.ApplyAttackEnhance
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyAttackEnhance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyAttackEnhance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyBloodSuckAddIchorEnhance
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyBloodSuckAddIchorEnhance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyBloodSuckAddIchorEnhance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyDamageReduction
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyDamageReduction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyDamageReduction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyEnhanceNextAttack
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyEnhanceNextAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyEnhanceNextAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyHealthToBuddyPoint
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyHealthToBuddyPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyHealthToBuddyPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyHealthToIchor
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyHealthToIchor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyHealthToIchor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyIchorConsumeReduction
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyIchorConsumeReduction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyIchorConsumeReduction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyStaminaConsumeReductiont
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyStaminaConsumeReductiont()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyStaminaConsumeReductiont");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ParamBonusControlComponent.ApplyStrengthEnhance
// (Final, Native, Public, BlueprintCallable)

void UParamBonusControlComponent::ApplyStrengthEnhance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamBonusControlComponent", "ApplyStrengthEnhance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PettableAnimal.PlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APettableAnimal::PlayAnimation(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PettableAnimal", "PlayAnimation");

	Params::PettableAnimal_PlayAnimation Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PettableAnimal.StopAnimation
// (Final, Native, Public, BlueprintCallable)

void APettableAnimal::StopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PettableAnimal", "StopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PettableAnimal.GetDominantStateName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName APettableAnimal::GetDominantStateName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PettableAnimal", "GetDominantStateName");

	Params::PettableAnimal_GetDominantStateName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoLogManager.GetPhotoLogDataByID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InPhotoLogID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhotoLogDataTableRow*           OutPhotoLogData                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhotoLogManager::GetPhotoLogDataByID(const class FName& InPhotoLogID, struct FPhotoLogDataTableRow* OutPhotoLogData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoLogManager", "GetPhotoLogDataByID");

	Params::PhotoLogManager_GetPhotoLogDataByID Parms{};

	Parms.InPhotoLogID = InPhotoLogID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPhotoLogData != nullptr)
		*OutPhotoLogData = std::move(Parms.OutPhotoLogData);

	return Parms.ReturnValue;
}


// Function Extensions.PhotoLogManager.GetPhotoLogTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UPhotoLogManager::GetPhotoLogTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoLogManager", "GetPhotoLogTable");

	Params::PhotoLogManager_GetPhotoLogTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoLogTrigger.OnPhotoLogWindowClosed
// (Native, Protected)

void APhotoLogTrigger::OnPhotoLogWindowClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoLogTrigger", "OnPhotoLogWindowClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_DirectlyWidget.OnCloseFinish
// (Final, Native, Public)

void UQSTask_DirectlyWidget::OnCloseFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_DirectlyWidget", "OnCloseFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoLogUIObject.ClosePhotoLogWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoLogUIObject::ClosePhotoLogWindow(const class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoLogUIObject", "ClosePhotoLogWindow");

	Params::PhotoLogUIObject_ClosePhotoLogWindow Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoLogUIObject.OpenPhotoLogWindow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InPhotoLogID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhotoLogUIObject::OpenPhotoLogWindow(const class UObject* InWorldContext, const class FName& InPhotoLogID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhotoLogUIObject", "OpenPhotoLogWindow");

	Params::PhotoLogUIObject_OpenPhotoLogWindow Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InPhotoLogID = InPhotoLogID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PhotoLogUIObject.GetTargetPhotoLogID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UPhotoLogUIObject::GetTargetPhotoLogID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoLogUIObject", "GetTargetPhotoLogID");

	Params::PhotoLogUIObject_GetTargetPhotoLogID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModeMenuUIObject.NotifyPropMotorcycleCancel
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPhotoModeMenuUIObject::NotifyPropMotorcycleCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModeMenuUIObject", "NotifyPropMotorcycleCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.PhotoModePhotoFrameActor.GetPhotoFrameCount
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhotoModePhotoFrameActor::GetPhotoFrameCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "GetPhotoFrameCount");

	Params::PhotoModePhotoFrameActor_GetPhotoFrameCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePhotoFrameActor.GetPhotoFrameDisplayNameByIndex
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APhotoModePhotoFrameActor::GetPhotoFrameDisplayNameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "GetPhotoFrameDisplayNameByIndex");

	Params::PhotoModePhotoFrameActor_GetPhotoFrameDisplayNameByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePhotoFrameActor.GetPhotoFrameNameByIndex
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APhotoModePhotoFrameActor::GetPhotoFrameNameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "GetPhotoFrameNameByIndex");

	Params::PhotoModePhotoFrameActor_GetPhotoFrameNameByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePhotoFrameActor.SelectPhotoFrameByIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhotoModePhotoFrameActor::SelectPhotoFrameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "SelectPhotoFrameByIndex");

	Params::PhotoModePhotoFrameActor_SelectPhotoFrameByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PhotoModePhotoFrameActor.SetPhotoFrameData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPhotoModeFrameData&       FrameData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void APhotoModePhotoFrameActor::SetPhotoFrameData(const struct FPhotoModeFrameData& FrameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "SetPhotoFrameData");

	Params::PhotoModePhotoFrameActor_SetPhotoFrameData Parms{};

	Parms.FrameData = std::move(FrameData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PhotoModePhotoFrameActor.GetPhotoFrameIndex
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhotoModePhotoFrameActor::GetPhotoFrameIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "GetPhotoFrameIndex");

	Params::PhotoModePhotoFrameActor_GetPhotoFrameIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePhotoFrameActor.IsCreatedByDebugMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APhotoModePhotoFrameActor::IsCreatedByDebugMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "IsCreatedByDebugMenu");

	Params::PhotoModePhotoFrameActor_IsCreatedByDebugMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PhotoModePhotoFrameActor.IsDebugEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APhotoModePhotoFrameActor::IsDebugEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhotoModePhotoFrameActor", "IsDebugEnabled");

	Params::PhotoModePhotoFrameActor_IsDebugEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StoryFlagCategoryScenarioDebugMenu.OnChangeFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UStoryFlagCategoryScenarioDebugMenu::OnChangeFlag(const struct FStoryFlagChangeParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoryFlagCategoryScenarioDebugMenu", "OnChangeFlag");

	Params::StoryFlagCategoryScenarioDebugMenu_OnChangeFlag Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PianoSettings.GeneratePianoAction
// (Final, Native, Protected)

void UPianoSettings::GeneratePianoAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PianoSettings", "GeneratePianoAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupItem.NetMulticastGiveItem
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FArticleBulkInfo&          InBulkInfo                                             (ConstParm, Parm, NativeAccessSpecifierPublic)

void APickupItem::NetMulticastGiveItem(const struct FArticleBulkInfo& InBulkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupItem", "NetMulticastGiveItem");

	Params::PickupItem_NetMulticastGiveItem Parms{};

	Parms.InBulkInfo = std::move(InBulkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupItem.OnRep_ReplicatedRecipient
// (Final, Native, Private)

void APickupItem::OnRep_ReplicatedRecipient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupItem", "OnRep_ReplicatedRecipient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PickupItem.UpdateEffect_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EArticleEffectRarity              InRarity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickupItem::UpdateEffect_BP(const EArticleEffectRarity InRarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupItem", "UpdateEffect_BP");

	Params::PickupItem_UpdateEffect_BP Parms{};

	Parms.InRarity = InRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PlatformDataManager.K2_GetCurrentInputDeviceType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputDeviceType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputDeviceType UPlatformDataManager::K2_GetCurrentInputDeviceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlatformDataManager", "K2_GetCurrentInputDeviceType");

	Params::PlatformDataManager_K2_GetCurrentInputDeviceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlatformDataManager.K2_GetKeyImageBrushByKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FSlateBrush UPlatformDataManager::K2_GetKeyImageBrushByKey(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlatformDataManager", "K2_GetKeyImageBrushByKey");

	Params::PlatformDataManager_K2_GetKeyImageBrushByKey Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlatformDataManager.K2_GetKeyImageBrushByRowName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       InRowName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInWarnIfMissing                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FSlateBrush UPlatformDataManager::K2_GetKeyImageBrushByRowName(const class FName InRowName, const bool bInWarnIfMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlatformDataManager", "K2_GetKeyImageBrushByRowName");

	Params::PlatformDataManager_K2_GetKeyImageBrushByRowName Parms{};

	Parms.InRowName = InRowName;
	Parms.bInWarnIfMissing = bInWarnIfMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlatformDataManager.K2_IsCurrentInputDeviceGamePad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformDataManager::K2_IsCurrentInputDeviceGamePad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlatformDataManager", "K2_IsCurrentInputDeviceGamePad");

	Params::PlatformDataManager_K2_IsCurrentInputDeviceGamePad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerCharacter.NextWeaponEquipSlot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::NextWeaponEquipSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NextWeaponEquipSlot");

	Params::PlayerCharacter_NextWeaponEquipSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerCharacter.OnMontageEnded
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInInterrupted                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnMontageEnded(class UAnimMontage* InMontage, const bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnMontageEnded");

	Params::PlayerCharacter_OnMontageEnded Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerCharacter.OnMontageStarted
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnMontageStarted");

	Params::PlayerCharacter_OnMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerCharacter.OnRep_Jump2HostInfo
// (Final, Native, Protected)

void APlayerCharacter::OnRep_Jump2HostInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnRep_Jump2HostInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerCharacter.ServerSuicide
// (Net, NetReliable, Native, Event, Protected, NetServer)

void APlayerCharacter::ServerSuicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ServerSuicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerCharacter.GetItemSyntheticComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItemSyntheticComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemSyntheticComponent* APlayerCharacter::GetItemSyntheticComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetItemSyntheticComponent");

	Params::PlayerCharacter_GetItemSyntheticComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerCharacter.GetPlayerEmotionControlComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerEmotionControlComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerEmotionControlComponent* APlayerCharacter::GetPlayerEmotionControlComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetPlayerEmotionControlComponent");

	Params::PlayerCharacter_GetPlayerEmotionControlComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.QSTask_BloodCodeAcquireDialog.OnDialogDecide
// (Final, Native, Public)

void UQSTask_BloodCodeAcquireDialog::OnDialogDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_BloodCodeAcquireDialog", "OnDialogDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerDamageGimmickReceive.EndTimer_Floor
// (Final, Native, Protected)
// Parameters:
// class FName                             InGimmickID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDamageGimmickReceive::EndTimer_Floor(class FName InGimmickID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDamageGimmickReceive", "EndTimer_Floor");

	Params::PlayerDamageGimmickReceive_EndTimer_Floor Parms{};

	Parms.InGimmickID = InGimmickID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerDamageGimmickReceive.EndTimer_OverlapGimmick
// (Final, Native, Protected)
// Parameters:
// class FName                             InGimmickID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDamageGimmickReceive::EndTimer_OverlapGimmick(class FName InGimmickID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDamageGimmickReceive", "EndTimer_OverlapGimmick");

	Params::PlayerDamageGimmickReceive_EndTimer_OverlapGimmick Parms{};

	Parms.InGimmickID = InGimmickID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerDamageGimmickReceive.OnComponentBeginOverlap_DamageGimmick
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOther                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerDamageGimmickReceive::OnComponentBeginOverlap_DamageGimmick(class UPrimitiveComponent* InOverlappedComp, class AActor* InOther, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool InbFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDamageGimmickReceive", "OnComponentBeginOverlap_DamageGimmick");

	Params::PlayerDamageGimmickReceive_OnComponentBeginOverlap_DamageGimmick Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOther = InOther;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.InbFromSweep = InbFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerDamageGimmickReceive.OnComponentEndOverlap_DamageGimmick
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComp                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOther                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDamageGimmickReceive::OnComponentEndOverlap_DamageGimmick(class UPrimitiveComponent* InOverlappedComp, class AActor* InOther, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDamageGimmickReceive", "OnComponentEndOverlap_DamageGimmick");

	Params::PlayerDamageGimmickReceive_OnComponentEndOverlap_DamageGimmick Parms{};

	Parms.InOverlappedComp = InOverlappedComp;
	Parms.InOther = InOther;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerDebugMenu.OnPlayerCharacterMovementModeChanged
// (Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDebugMenu::OnPlayerCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDebugMenu", "OnPlayerCharacterMovementModeChanged");

	Params::PlayerDebugMenu_OnPlayerCharacterMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnCanEquipWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerEquipControlComponent::OnCanEquipWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const struct FUIWeaponGadgetQueryInfo& InGadgetQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnCanEquipWeaponAddOnGadget");

	Params::PlayerEquipControlComponent_OnCanEquipWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnCheckWeaponAddOnGadgetCapacity
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerEquipControlComponent::OnCheckWeaponAddOnGadgetCapacity(const struct FUIWeaponQueryInfo& InWeaponQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnCheckWeaponAddOnGadgetCapacity");

	Params::PlayerEquipControlComponent_OnCheckWeaponAddOnGadgetCapacity Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipBloodCode
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipBloodCode(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipBloodCode");

	Params::PlayerEquipControlComponent_OnEquipBloodCode Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipBooster
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIBoosterSlot                    InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIBoosterQueryInfo&       InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bIsDuplicationEquip                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipBooster(const EUIBoosterSlot InUISlot, const struct FUIBoosterQueryInfo& InQuery, bool* bIsDuplicationEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipBooster");

	Params::PlayerEquipControlComponent_OnEquipBooster Parms{};

	Parms.InUISlot = InUISlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsDuplicationEquip != nullptr)
		*bIsDuplicationEquip = Parms.bIsDuplicationEquip;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipDefaultWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InWeaponGadgetSlot                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipDefaultWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InWeaponGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipDefaultWeaponAddOnGadget");

	Params::PlayerEquipControlComponent_OnEquipDefaultWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InWeaponGadgetSlot = InWeaponGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipDefenceGadget
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipDefenceGadget(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipDefenceGadget");

	Params::PlayerEquipControlComponent_OnEquipDefenceGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipJail
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipJail(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipJail");

	Params::PlayerEquipControlComponent_OnEquipJail Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipStandAloneGadget
// (Final, Native, Private)
// Parameters:
// const int32                             InInventoryIndex                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipStandAloneGadget(const int32 InInventoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipStandAloneGadget");

	Params::PlayerEquipControlComponent_OnEquipStandAloneGadget Parms{};

	Parms.InInventoryIndex = InInventoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponQueryInfo&        InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipWeapon(const EUIWeaponSlot InSlot, const struct FUIWeaponQueryInfo& InQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipWeapon");

	Params::PlayerEquipControlComponent_OnEquipWeapon Parms{};

	Parms.InSlot = InSlot;
	Parms.InQuery = std::move(InQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnEquipWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InWeaponGadgetSlot                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUIWeaponGadgetQueryInfo&  InGadgetQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnEquipWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InWeaponGadgetSlot, const struct FUIWeaponGadgetQueryInfo& InGadgetQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnEquipWeaponAddOnGadget");

	Params::PlayerEquipControlComponent_OnEquipWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InWeaponGadgetSlot = InWeaponGadgetSlot;
	Parms.InGadgetQuery = std::move(InGadgetQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquipBoosterIndex
// (Final, Native, Private)
// Parameters:
// const EUIBoosterSlot                    InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIBoosterCategory                InBoosterCategory                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquipBoosterIndex(const EUIBoosterSlot InUISlot, const EUIBoosterCategory InBoosterCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquipBoosterIndex");

	Params::PlayerEquipControlComponent_OnGetEquipBoosterIndex Parms{};

	Parms.InUISlot = InUISlot;
	Parms.InBoosterCategory = InBoosterCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquipDefenceGadgetIndex
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquipDefenceGadgetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquipDefenceGadgetIndex");

	Params::PlayerEquipControlComponent_OnGetEquipDefenceGadgetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquipedWeaponAddOnGadgetIndex
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InGadgetSlot                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetCategory           InGadgetCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquipedWeaponAddOnGadgetIndex(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InGadgetSlot, const EUIWeaponGadgetCategory InGadgetCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquipedWeaponAddOnGadgetIndex");

	Params::PlayerEquipControlComponent_OnGetEquipedWeaponAddOnGadgetIndex Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InGadgetSlot = InGadgetSlot;
	Parms.InGadgetCategory = InGadgetCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquipJailIndex
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquipJailIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquipJailIndex");

	Params::PlayerEquipControlComponent_OnGetEquipJailIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquippedBloodCodeIndex
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquippedBloodCodeIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquippedBloodCodeIndex");

	Params::PlayerEquipControlComponent_OnGetEquippedBloodCodeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquippedWeaponIndex
// (Final, Native, Private)
// Parameters:
// const EUIWeaponSlot                     InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUIWeaponCategory                 InUICategory                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquippedWeaponIndex(const EUIWeaponSlot InUISlot, const EUIWeaponCategory InUICategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquippedWeaponIndex");

	Params::PlayerEquipControlComponent_OnGetEquippedWeaponIndex Parms{};

	Parms.InUISlot = InUISlot;
	Parms.InUICategory = InUICategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnGetEquipStandAloneGadgetIndex
// (Final, Native, Private)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPlayerEquipControlComponent::OnGetEquipStandAloneGadgetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnGetEquipStandAloneGadgetIndex");

	Params::PlayerEquipControlComponent_OnGetEquipStandAloneGadgetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipBooster
// (Final, Native, Private)
// Parameters:
// const EUIBoosterSlot                    InUISlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnUnequipBooster(const EUIBoosterSlot InUISlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipBooster");

	Params::PlayerEquipControlComponent_OnUnequipBooster Parms{};

	Parms.InUISlot = InUISlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipDefenceGadget
// (Final, Native, Private)

void UPlayerEquipControlComponent::OnUnequipDefenceGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipDefenceGadget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipJail
// (Final, Native, Private)

void UPlayerEquipControlComponent::OnUnequipJail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipJail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipStandAloneGadget
// (Final, Native, Private)

void UPlayerEquipControlComponent::OnUnequipStandAloneGadget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipStandAloneGadget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipWeapon
// (Final, Native, Private)
// Parameters:
// const EUIWeaponSlot                     InSlot                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnUnequipWeapon(const EUIWeaponSlot InSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipWeapon");

	Params::PlayerEquipControlComponent_OnUnequipWeapon Parms{};

	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipControlComponent.OnUnequipWeaponAddOnGadget
// (Final, Native, Private)
// Parameters:
// const struct FUIWeaponQueryInfo&        InWeaponQuery                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const EUIWeaponGadgetSlot               InWeaponGadgetSlot                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEquipControlComponent::OnUnequipWeaponAddOnGadget(const struct FUIWeaponQueryInfo& InWeaponQuery, const EUIWeaponGadgetSlot InWeaponGadgetSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipControlComponent", "OnUnequipWeaponAddOnGadget");

	Params::PlayerEquipControlComponent_OnUnequipWeaponAddOnGadget Parms{};

	Parms.InWeaponQuery = std::move(InWeaponQuery);
	Parms.InWeaponGadgetSlot = InWeaponGadgetSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerEquipmentVisualControlComponent.IsHideWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerEquipmentVisualControlComponent::IsHideWeapon(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEquipmentVisualControlComponent", "IsHideWeapon");

	Params::PlayerEquipmentVisualControlComponent_IsHideWeapon Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerManager.OnFastTravelCompleted
// (Final, Native, Private)

void UPlayerManager::OnFastTravelCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "OnFastTravelCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerManager.SendMessageAutoMove
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerMessageAutoMove&          InMessage                                              (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerManager::SendMessageAutoMove(struct FPlayerMessageAutoMove& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "SendMessageAutoMove");

	Params::PlayerManager_SendMessageAutoMove Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InMessage = std::move(Parms.InMessage);
}


// Function Extensions.PlayerManager.SendMessageMoveTypeRestrict
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerMessageMoveTypeRestrict&  InMessage                                              (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerManager::SendMessageMoveTypeRestrict(struct FPlayerMessageMoveTypeRestrict& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "SendMessageMoveTypeRestrict");

	Params::PlayerManager_SendMessageMoveTypeRestrict Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InMessage = std::move(Parms.InMessage);
}


// Function Extensions.PlayerManager.SendMessageMoveTypeRestrictCancel
// (Final, Native, Public, BlueprintCallable)

void UPlayerManager::SendMessageMoveTypeRestrictCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "SendMessageMoveTypeRestrictCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerManager.SendMessageRequestInputAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerMessageRequestInputAction&InMessage                                              (Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerManager::SendMessageRequestInputAction(struct FPlayerMessageRequestInputAction& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "SendMessageRequestInputAction");

	Params::PlayerManager_SendMessageRequestInputAction Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InMessage = std::move(Parms.InMessage);
}


// Function Extensions.PlayerManager.SendMessageTeleport
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerMessageTeleport&          InMessage                                              (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerManager::SendMessageTeleport(struct FPlayerMessageTeleport& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "SendMessageTeleport");

	Params::PlayerManager_SendMessageTeleport Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InMessage = std::move(Parms.InMessage);
}


// Function Extensions.PlayerManager.GetGuestPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UPlayerManager::GetGuestPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "GetGuestPlayer");

	Params::PlayerManager_GetGuestPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerManager.GetHostPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UPlayerManager::GetHostPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "GetHostPlayer");

	Params::PlayerManager_GetHostPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerManager.GetPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UPlayerManager::GetPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "GetPlayer");

	Params::PlayerManager_GetPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.PlayerManager.GetPlayerInfoService
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPlayerInfoService*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerInfoService* UPlayerManager::GetPlayerInfoService() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerManager", "GetPlayerInfoService");

	Params::PlayerManager_GetPlayerInfoService Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.GetShowFlagIndexByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UViewModeFunctionLibrary::GetShowFlagIndexByName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "GetShowFlagIndexByName");

	Params::ViewModeFunctionLibrary_GetShowFlagIndexByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.GetShowFlagNameByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UViewModeFunctionLibrary::GetShowFlagNameByIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "GetShowFlagNameByIndex");

	Params::ViewModeFunctionLibrary_GetShowFlagNameByIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.GetShowFlagValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UViewModeFunctionLibrary::GetShowFlagValue(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "GetShowFlagValue");

	Params::ViewModeFunctionLibrary_GetShowFlagValue Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.Landscape_GetViewMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UViewModeFunctionLibrary::Landscape_GetViewMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "Landscape_GetViewMode");

	Params::ViewModeFunctionLibrary_Landscape_GetViewMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.Landscape_SetViewMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InViewMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInRedraw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewModeFunctionLibrary::Landscape_SetViewMode(class FName InViewMode, bool bInRedraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "Landscape_SetViewMode");

	Params::ViewModeFunctionLibrary_Landscape_SetViewMode Parms{};

	Parms.InViewMode = InViewMode;
	Parms.bInRedraw = bInRedraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ViewModeFunctionLibrary.Lumen_GetVisualizationMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UViewModeFunctionLibrary::Lumen_GetVisualizationMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "Lumen_GetVisualizationMode");

	Params::ViewModeFunctionLibrary_Lumen_GetVisualizationMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.Lumen_SetVisualizationMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewModeFunctionLibrary::Lumen_SetVisualizationMode(class FName InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "Lumen_SetVisualizationMode");

	Params::ViewModeFunctionLibrary_Lumen_SetVisualizationMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ViewModeFunctionLibrary.SetShowFlagValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewModeFunctionLibrary::SetShowFlagValue(int32 InIndex, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "SetShowFlagValue");

	Params::ViewModeFunctionLibrary_SetShowFlagValue Parms{};

	Parms.InIndex = InIndex;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ViewModeFunctionLibrary.ViewMode_GetViewMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EViewModeIndex                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EViewModeIndex UViewModeFunctionLibrary::ViewMode_GetViewMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "ViewMode_GetViewMode");

	Params::ViewModeFunctionLibrary_ViewMode_GetViewMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ViewModeFunctionLibrary.ViewMode_SetEnableNanite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewModeFunctionLibrary::ViewMode_SetEnableNanite(bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "ViewMode_SetEnableNanite");

	Params::ViewModeFunctionLibrary_ViewMode_SetEnableNanite Parms{};

	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ViewModeFunctionLibrary.ViewMode_SetViewMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EViewModeIndex                          InViewMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewModeFunctionLibrary::ViewMode_SetViewMode(EViewModeIndex InViewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ViewModeFunctionLibrary", "ViewMode_SetViewMode");

	Params::ViewModeFunctionLibrary_ViewMode_SetViewMode Parms{};

	Parms.InViewMode = InViewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.WaterSurfaceActor.OnTimeSeriesChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWaterSurfaceActor::OnTimeSeriesChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterSurfaceActor", "OnTimeSeriesChanged");

	Params::WaterSurfaceActor_OnTimeSeriesChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PlayerSettings.GetGuardSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPlayerGuardSettings*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerGuardSettings* UPlayerSettings::GetGuardSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSettings", "GetGuardSettings");

	Params::PlayerSettings_GetGuardSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.LeaveMultiplayStatement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::LeaveMultiplayStatement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "LeaveMultiplayStatement");

	Params::SubtitlesUIObject_LeaveMultiplayStatement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.NotifyStageDirectionsClose
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::NotifyStageDirectionsClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "NotifyStageDirectionsClose");

	Params::SubtitlesUIObject_NotifyStageDirectionsClose Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.NotifyStageDirectionsUpdate
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      StageDirectionsText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::NotifyStageDirectionsUpdate(const class FText& StageDirectionsText, float DisplayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "NotifyStageDirectionsUpdate");

	Params::SubtitlesUIObject_NotifyStageDirectionsUpdate Parms{};

	Parms.StageDirectionsText = std::move(StageDirectionsText);
	Parms.DisplayTime = DisplayTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.NotifySubtitleClose
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::NotifySubtitleClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "NotifySubtitleClose");

	Params::SubtitlesUIObject_NotifySubtitleClose Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.NotifySubtitleUpdate
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      Speaker                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Talk                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDisplayOnScreenMask                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDisplayInteractGuide                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::NotifySubtitleUpdate(const class FText& Speaker, const class FText& Talk, float DisplayTime, bool bIsDisplayOnScreenMask, bool bIsDisplayInteractGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "NotifySubtitleUpdate");

	Params::SubtitlesUIObject_NotifySubtitleUpdate Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Talk = std::move(Talk);
	Parms.DisplayTime = DisplayTime;
	Parms.bIsDisplayOnScreenMask = bIsDisplayOnScreenMask;
	Parms.bIsDisplayInteractGuide = bIsDisplayInteractGuide;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.OnSetInteractSkipProhibited
// (Event, Public, BlueprintEvent)

void USubtitlesUIObject::OnSetInteractSkipProhibited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "OnSetInteractSkipProhibited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.SubtitlesUIObject.SetInteractGuideVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InIsVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesUIObject::SetInteractGuideVisibility(bool InIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetInteractGuideVisibility");

	Params::SubtitlesUIObject_SetInteractGuideVisibility Parms{};

	Parms.InIsVisible = InIsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.SubtitlesUIObject.SetInteractSkipProhibited
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InProhibited                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesUIObject::SetInteractSkipProhibited(bool InProhibited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetInteractSkipProhibited");

	Params::SubtitlesUIObject_SetInteractSkipProhibited Parms{};

	Parms.InProhibited = InProhibited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SubtitlesUIObject.SetLeaveMultiplayIndicatorPercent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::SetLeaveMultiplayIndicatorPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetLeaveMultiplayIndicatorPercent");

	Params::SubtitlesUIObject_SetLeaveMultiplayIndicatorPercent Parms{};

	Parms.NewPercent = NewPercent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.SetShowLeaveMultiplayIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShowWidget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::SetShowLeaveMultiplayIndicator(bool bShowWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetShowLeaveMultiplayIndicator");

	Params::SubtitlesUIObject_SetShowLeaveMultiplayIndicator Parms{};

	Parms.bShowWidget = bShowWidget;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.SetShowSkipIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShowWidget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::SetShowSkipIndicator(bool bShowWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetShowSkipIndicator");

	Params::SubtitlesUIObject_SetShowSkipIndicator Parms{};

	Parms.bShowWidget = bShowWidget;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.SetSkipIndicatorPercent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::SetSkipIndicatorPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetSkipIndicatorPercent");

	Params::SubtitlesUIObject_SetSkipIndicatorPercent Parms{};

	Parms.NewPercent = NewPercent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.SetSkipProhibited
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InProhibited                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesUIObject::SetSkipProhibited(bool InProhibited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SetSkipProhibited");

	Params::SubtitlesUIObject_SetSkipProhibited Parms{};

	Parms.InProhibited = InProhibited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SubtitlesUIObject.SkipStatement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::SkipStatement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "SkipStatement");

	Params::SubtitlesUIObject_SkipStatement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.IsCutScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::IsCutScene() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "IsCutScene");

	Params::SubtitlesUIObject_IsCutScene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.IsInteractSkipProhibited
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::IsInteractSkipProhibited() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "IsInteractSkipProhibited");

	Params::SubtitlesUIObject_IsInteractSkipProhibited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SubtitlesUIObject.IsSkipProhibited
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesUIObject::IsSkipProhibited() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesUIObject", "IsSkipProhibited");

	Params::SubtitlesUIObject_IsSkipProhibited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TestLogSendFunctionLibarary.TestLogSend_LogViewer
// (Final, Native, Static, Public, BlueprintCallable)

void UTestLogSendFunctionLibarary::TestLogSend_LogViewer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLogSendFunctionLibarary", "TestLogSend_LogViewer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioUIObject.AbortSelection
// (Final, Native, Public, BlueprintCallable)

void UScenarioUIObject::AbortSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "AbortSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioUIObject.ClearShowSelectionDialog_AutoTest
// (Final, Native, Private, BlueprintCallable)

void UScenarioUIObject::ClearShowSelectionDialog_AutoTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "ClearShowSelectionDialog_AutoTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioUIObject.HideSelectionDialog
// (Final, Native, Public, BlueprintCallable)

void UScenarioUIObject::HideSelectionDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "HideSelectionDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioUIObject.IsShowSelectionDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioUIObject::IsShowSelectionDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "IsShowSelectionDialog");

	Params::ScenarioUIObject_IsShowSelectionDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ScenarioUIObject.OnHideSelectionDialogBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioUIObject::OnHideSelectionDialogBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "OnHideSelectionDialogBP");

	Params::ScenarioUIObject_OnHideSelectionDialogBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScenarioUIObject.OnShowSelectionDialogBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class FText>&              InOptionTexts                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             InInitialSelection                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ESelectionDialogDisplayType       InDisplayType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioUIObject::OnShowSelectionDialogBP(const TArray<class FText>& InOptionTexts, const int32 InInitialSelection, const ESelectionDialogDisplayType InDisplayType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "OnShowSelectionDialogBP");

	Params::ScenarioUIObject_OnShowSelectionDialogBP Parms{};

	Parms.InOptionTexts = std::move(InOptionTexts);
	Parms.InInitialSelection = InInitialSelection;
	Parms.InDisplayType = InDisplayType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScenarioUIObject.SelectOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InOption                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioUIObject::SelectOption(const int32 InOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "SelectOption");

	Params::ScenarioUIObject_SelectOption Parms{};

	Parms.InOption = InOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioUIObject.ShowSelectionDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FText>&              InOptionTexts                                          (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const int32                             InInitialSelection                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const int32 SelectIndex)>InSelectDelegate                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InAbortDelegate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ESelectionDialogDisplayType       InDisplayType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioUIObject::ShowSelectionDialog(const TArray<class FText>& InOptionTexts, const int32 InInitialSelection, TDelegate<void(const int32 SelectIndex)> InSelectDelegate, TDelegate<void()> InAbortDelegate, const ESelectionDialogDisplayType InDisplayType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioUIObject", "ShowSelectionDialog");

	Params::ScenarioUIObject_ShowSelectionDialog Parms{};

	Parms.InOptionTexts = std::move(InOptionTexts);
	Parms.InInitialSelection = InInitialSelection;
	Parms.InSelectDelegate = InSelectDelegate;
	Parms.InAbortDelegate = InAbortDelegate;
	Parms.InDisplayType = InDisplayType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PrepareGadgetAbility.StartPrepare
// (Final, Native, Protected, BlueprintCallable)

void UPrepareGadgetAbility::StartPrepare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrepareGadgetAbility", "StartPrepare");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PropEffectControlComponent.ExecuteEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPropEffectControl_EffectType           InEffectType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPropEffectControlComponent::ExecuteEffect(EPropEffectControl_EffectType InEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropEffectControlComponent", "ExecuteEffect");

	Params::PropEffectControlComponent_ExecuteEffect Parms{};

	Parms.InEffectType = InEffectType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.PropEffectControlComponent.OnFinishInternal
// (Final, Native, Protected, BlueprintCallable)

void UPropEffectControlComponent::OnFinishInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropEffectControlComponent", "OnFinishInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PropEffectControlComponent.SetAutoDestroy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAutoDestroy                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPropEffectControlComponent::SetAutoDestroy(bool bInAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropEffectControlComponent", "SetAutoDestroy");

	Params::PropEffectControlComponent_SetAutoDestroy Parms{};

	Parms.bInAutoDestroy = bInAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.PropEffectControlComponent.SetAutoExecuteEffectTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPropEffectControl_EffectType           InEffectType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPropEffectControlComponent::SetAutoExecuteEffectTime(EPropEffectControl_EffectType InEffectType, float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropEffectControlComponent", "SetAutoExecuteEffectTime");

	Params::PropEffectControlComponent_SetAutoExecuteEffectTime Parms{};

	Parms.InEffectType = InEffectType;
	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.QSExtenstionLibrary.SendMessageBuddyChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQSMessageBuddyChange&     Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageBuddyChange(const class UObject* InWorldContext, const struct FQSMessageBuddyChange& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageBuddyChange");

	Params::QSExtenstionLibrary_SendMessageBuddyChange Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSExtenstionLibrary.SendMessageFieldReset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQSMessageFieldReset&      Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageFieldReset(const class UObject* InWorldContext, const struct FQSMessageFieldReset& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageFieldReset");

	Params::QSExtenstionLibrary_SendMessageFieldReset Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSExtenstionLibrary.SendMessageInvaderWaveAbort
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQSMessageInvaderWaveAbort&Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageInvaderWaveAbort(const class UObject* InWorldContext, const struct FQSMessageInvaderWaveAbort& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageInvaderWaveAbort");

	Params::QSExtenstionLibrary_SendMessageInvaderWaveAbort Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSExtenstionLibrary.SendMessageInvaderWaveEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQSMessageInvaderWaveEnd&  Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageInvaderWaveEnd(const class UObject* InWorldContext, const struct FQSMessageInvaderWaveEnd& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageInvaderWaveEnd");

	Params::QSExtenstionLibrary_SendMessageInvaderWaveEnd Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSExtenstionLibrary.SendMessageSkipCutScene
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQSMessageSkipCutSceneParam&Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageSkipCutScene(const class UObject* InWorldContext, const struct FQSMessageSkipCutSceneParam& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageSkipCutScene");

	Params::QSExtenstionLibrary_SendMessageSkipCutScene Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSExtenstionLibrary.SendMessageTaskComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    InWorldContext                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInMuseum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSExtenstionLibrary::SendMessageTaskComplete(const class UObject* InWorldContext, bool IsInMuseum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QSExtenstionLibrary", "SendMessageTaskComplete");

	Params::QSExtenstionLibrary_SendMessageTaskComplete Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.IsInMuseum = IsInMuseum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_ArchiveBegin.OnArchiveBeginCompleted
// (Native, Public)

void UQSTask_ArchiveBegin::OnArchiveBeginCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_ArchiveBegin", "OnArchiveBeginCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_AwaitBuddyTypeAndFieldRegion.OnChangeBuddyType
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InBuddyType                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInShowMessage                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_AwaitBuddyTypeAndFieldRegion::OnChangeBuddyType(const struct FGameplayTag& InBuddyType, const bool bInShowMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_AwaitBuddyTypeAndFieldRegion", "OnChangeBuddyType");

	Params::QSTask_AwaitBuddyTypeAndFieldRegion_OnChangeBuddyType Parms{};

	Parms.InBuddyType = std::move(InBuddyType);
	Parms.bInShowMessage = bInShowMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_AwaitBuddyTypeAndFieldRegion.OnChangeFieldRegion
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTagContainer&     InPreFieldRegion                                       (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InCurrentFieldRegion                                   (Parm, NativeAccessSpecifierPublic)

void UQSTask_AwaitBuddyTypeAndFieldRegion::OnChangeFieldRegion(const struct FGameplayTagContainer& InPreFieldRegion, const struct FGameplayTagContainer& InCurrentFieldRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_AwaitBuddyTypeAndFieldRegion", "OnChangeFieldRegion");

	Params::QSTask_AwaitBuddyTypeAndFieldRegion_OnChangeFieldRegion Parms{};

	Parms.InPreFieldRegion = std::move(InPreFieldRegion);
	Parms.InCurrentFieldRegion = std::move(InCurrentFieldRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_AwaitBuddyTypeAndFieldRegion.OnChangeGameFlag
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_AwaitBuddyTypeAndFieldRegion::OnChangeGameFlag(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_AwaitBuddyTypeAndFieldRegion", "OnChangeGameFlag");

	Params::QSTask_AwaitBuddyTypeAndFieldRegion_OnChangeGameFlag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_AwaitItemCount.OnCheckItemCount
// (Final, Native, Protected)

void UQSTask_AwaitItemCount::OnCheckItemCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_AwaitItemCount", "OnCheckItemCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_AwaitMenuUIClose.OnMenuUIClose
// (Final, Native, Public)

void UQSTask_AwaitMenuUIClose::OnMenuUIClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_AwaitMenuUIClose", "OnMenuUIClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_BuddySummonContractDialog.OnDialogDecide
// (Final, Native, Public)

void UQSTask_BuddySummonContractDialog::OnDialogDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_BuddySummonContractDialog", "OnDialogDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_Description.OnDescriptionWindowClosed
// (Native, Public)

void UQSTask_Description::OnDescriptionWindowClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_Description", "OnDescriptionWindowClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_EnemyDefeatMessage.OnMenuClosed
// (Native, Public)

void UQSTask_EnemyDefeatMessage::OnMenuClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_EnemyDefeatMessage", "OnMenuClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringBegin.OnCompletedChangeCostume
// (Final, Native, Protected)

void UQSTask_HotSpringBegin::OnCompletedChangeCostume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringBegin", "OnCompletedChangeCostume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringBegin.OnHotSpringBegin
// (Final, Native, Protected)

void UQSTask_HotSpringBegin::OnHotSpringBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringBegin", "OnHotSpringBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringBegin.OnLoadedAkAudioEvent
// (Final, Native, Protected)

void UQSTask_HotSpringBegin::OnLoadedAkAudioEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringBegin", "OnLoadedAkAudioEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringBegin.OnScreenMasked
// (Final, Native, Protected)

void UQSTask_HotSpringBegin::OnScreenMasked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringBegin", "OnScreenMasked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringEnd.OnCompletedChangeCostume
// (Final, Native, Protected)

void UQSTask_HotSpringEnd::OnCompletedChangeCostume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringEnd", "OnCompletedChangeCostume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_HotSpringEnd.OnScreenMasked
// (Final, Native, Protected)

void UQSTask_HotSpringEnd::OnScreenMasked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_HotSpringEnd", "OnScreenMasked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_PlayLevelSequence.OnFinishCutScene
// (Final, Native, Private)
// Parameters:
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQSTask_PlayLevelSequence::OnFinishCutScene(class ULevelSequence* InLevelSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_PlayLevelSequence", "OnFinishCutScene");

	Params::QSTask_PlayLevelSequence_OnFinishCutScene Parms{};

	Parms.InLevelSequence = InLevelSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_PlayLevelSequence.OnPlayerRespawn
// (Final, Native, Private)

void UQSTask_PlayLevelSequence::OnPlayerRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_PlayLevelSequence", "OnPlayerRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SetPlayerLocation.OnCheckLocationActorLoaded
// (Final, Native, Private)

void UQSTask_SetPlayerLocation::OnCheckLocationActorLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SetPlayerLocation", "OnCheckLocationActorLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SetPlayerLocation.OnEndScreenMaskForMultiplay
// (Final, Native, Private)

void UQSTask_SetPlayerLocation::OnEndScreenMaskForMultiplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SetPlayerLocation", "OnEndScreenMaskForMultiplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SetPlayerLocation.OnFinishFastTravel
// (Final, Native, Private)

void UQSTask_SetPlayerLocation::OnFinishFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SetPlayerLocation", "OnFinishFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SetPlayerLocation.OnPlayerRespawn
// (Final, Native, Private)

void UQSTask_SetPlayerLocation::OnPlayerRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SetPlayerLocation", "OnPlayerRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QSTask_SetPlayerLocation.OnScreenMaskCompleted
// (Final, Native, Private)

void UQSTask_SetPlayerLocation::OnScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QSTask_SetPlayerLocation", "OnScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientEndScreenMask
// (Net, NetReliable, Native, Event, Public, NetClient)

void UQuestExtensionsOnlineComponent::ClientEndScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientEndScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTCreateStreamingSource
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const class FString&                    InLabel                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTCreateStreamingSource(const class FString& InLabel, const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTCreateStreamingSource");

	Params::QuestExtensionsOnlineComponent_ClientQSTCreateStreamingSource Parms{};

	Parms.InLabel = std::move(InLabel);
	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTDeleteStreamingSource
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FString&                    InLabel                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTDeleteStreamingSource(const class FString& InLabel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTDeleteStreamingSource");

	Params::QuestExtensionsOnlineComponent_ClientQSTDeleteStreamingSource Parms{};

	Parms.InLabel = std::move(InLabel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTEnemyDefeatMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const EEnemyDefeatAppearanceType        InAppearanceType                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InMessage                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTEnemyDefeatMessage(const EEnemyDefeatAppearanceType InAppearanceType, const class FString& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTEnemyDefeatMessage");

	Params::QuestExtensionsOnlineComponent_ClientQSTEnemyDefeatMessage Parms{};

	Parms.InAppearanceType = InAppearanceType;
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTGainMultiplayReward
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<struct FQuestExtensionsSendArticleInfo>&InArticleInfoList                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTGainMultiplayReward(const TArray<struct FQuestExtensionsSendArticleInfo>& InArticleInfoList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTGainMultiplayReward");

	Params::QuestExtensionsOnlineComponent_ClientQSTGainMultiplayReward Parms{};

	Parms.InArticleInfoList = std::move(InArticleInfoList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTPostEvent
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FSoftObjectPath&           InAkAudioEvent                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTPostEvent(const struct FSoftObjectPath& InAkAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTPostEvent");

	Params::QuestExtensionsOnlineComponent_ClientQSTPostEvent Parms{};

	Parms.InAkAudioEvent = std::move(InAkAudioEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTSetPlayerLocation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InCameraYaw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsFindGround                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScreenMaskSettings&       InScreenMaskSettings                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTSetPlayerLocation(const struct FVector& InLocation, const struct FRotator& InRotation, float InCameraYaw, bool InIsFindGround, const struct FScreenMaskSettings& InScreenMaskSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTSetPlayerLocation");

	Params::QuestExtensionsOnlineComponent_ClientQSTSetPlayerLocation Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.InCameraYaw = InCameraYaw;
	Parms.InIsFindGround = InIsFindGround;
	Parms.InScreenMaskSettings = std::move(InScreenMaskSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ClientQSTWaitTimerAndInputDisable
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   InWaitTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbEnableScreenMask                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScreenMaskSettings&       InScreenMaskSettings                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UQuestExtensionsOnlineComponent::ClientQSTWaitTimerAndInputDisable(float InWaitTime, bool InbEnableScreenMask, const struct FScreenMaskSettings& InScreenMaskSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ClientQSTWaitTimerAndInputDisable");

	Params::QuestExtensionsOnlineComponent_ClientQSTWaitTimerAndInputDisable Parms{};

	Parms.InWaitTime = InWaitTime;
	Parms.InbEnableScreenMask = InbEnableScreenMask;
	Parms.InScreenMaskSettings = std::move(InScreenMaskSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.OnFinishFastTravel
// (Final, Native, Private)

void UQuestExtensionsOnlineComponent::OnFinishFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "OnFinishFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.OnRetryNotifyReadyEndScreenMask
// (Final, Native, Private)

void UQuestExtensionsOnlineComponent::OnRetryNotifyReadyEndScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "OnRetryNotifyReadyEndScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.OnWaitReadyEndScreenMaskAllPlayer
// (Final, Native, Private)

void UQuestExtensionsOnlineComponent::OnWaitReadyEndScreenMaskAllPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "OnWaitReadyEndScreenMaskAllPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.OnWaitTimeComplated
// (Final, Native, Private)

void UQuestExtensionsOnlineComponent::OnWaitTimeComplated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "OnWaitTimeComplated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.QuestExtensionsOnlineComponent.ServerNotifyReadyEndScreenMask
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UQuestExtensionsOnlineComponent::ServerNotifyReadyEndScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestExtensionsOnlineComponent", "ServerNotifyReadyEndScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RadarSceneBlueprintLibrary.GetRadarImage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* URadarSceneBlueprintLibrary::GetRadarImage(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "GetRadarImage");

	Params::RadarSceneBlueprintLibrary_GetRadarImage Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.RadarSceneBlueprintLibrary.SetEnableUpdate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URadarSceneBlueprintLibrary::SetEnableUpdate(class UObject* WorldContextObject, bool bValue, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "SetEnableUpdate");

	Params::RadarSceneBlueprintLibrary_SetEnableUpdate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bValue = bValue;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.RadarSceneBlueprintLibrary.SetNorthUpMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URadarSceneBlueprintLibrary::SetNorthUpMode(class UObject* WorldContextObject, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "SetNorthUpMode");

	Params::RadarSceneBlueprintLibrary_SetNorthUpMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.RadarSceneBlueprintLibrary.SetShowFootprints
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URadarSceneBlueprintLibrary::SetShowFootprints(class UObject* WorldContextObject, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "SetShowFootprints");

	Params::RadarSceneBlueprintLibrary_SetShowFootprints Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.RadarSceneBlueprintLibrary.SetShowFOV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URadarSceneBlueprintLibrary::SetShowFOV(class UObject* WorldContextObject, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "SetShowFOV");

	Params::RadarSceneBlueprintLibrary_SetShowFOV Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.RadarSceneBlueprintLibrary.SetWideMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URadarSceneBlueprintLibrary::SetWideMode(class UObject* WorldContextObject, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RadarSceneBlueprintLibrary", "SetWideMode");

	Params::RadarSceneBlueprintLibrary_SetWideMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ReloadMagazineAbility.OnMontageNotifyBegin
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReloadMagazineAbility::OnMontageNotifyBegin(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReloadMagazineAbility", "OnMontageNotifyBegin");

	Params::ReloadMagazineAbility_OnMontageNotifyBegin Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ReloadMagazineAbility.OnMontageNotifyEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReloadMagazineAbility::OnMontageNotifyEnd(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReloadMagazineAbility", "OnMontageNotifyEnd");

	Params::ReloadMagazineAbility_OnMontageNotifyEnd Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.RiverActor.OnTimeSeriesChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARiverActor::OnTimeSeriesChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverActor", "OnTimeSeriesChanged");

	Params::RiverActor_OnTimeSeriesChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.BeginScreenMask
// (Final, Native, Public, BlueprintCallable)

void USaveDataMenuUIObject::BeginScreenMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "BeginScreenMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.GetHistorySaveDataInfoArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             InMainSlotNo                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FUIHistorySaveDataInfo>*  OutHistorySaveDataInfoArray                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USaveDataMenuUIObject::GetHistorySaveDataInfoArray(const int32 InMainSlotNo, TArray<struct FUIHistorySaveDataInfo>* OutHistorySaveDataInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "GetHistorySaveDataInfoArray");

	Params::SaveDataMenuUIObject_GetHistorySaveDataInfoArray Parms{};

	Parms.InMainSlotNo = InMainSlotNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHistorySaveDataInfoArray != nullptr)
		*OutHistorySaveDataInfoArray = std::move(Parms.OutHistorySaveDataInfoArray);
}


// Function Extensions.SaveDataMenuUIObject.GetSaveDataInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUISaveDataInfo*                 OutSaveDataInfo                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void USaveDataMenuUIObject::GetSaveDataInfo(const int32 InIndex, struct FUISaveDataInfo* OutSaveDataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "GetSaveDataInfo");

	Params::SaveDataMenuUIObject_GetSaveDataInfo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSaveDataInfo != nullptr)
		*OutSaveDataInfo = std::move(Parms.OutSaveDataInfo);
}


// Function Extensions.SaveDataMenuUIObject.GetSaveDataSlotNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USaveDataMenuUIObject::GetSaveDataSlotNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "GetSaveDataSlotNum");

	Params::SaveDataMenuUIObject_GetSaveDataSlotNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataMenuUIObject.IndexToSlotNo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USaveDataMenuUIObject::IndexToSlotNo(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "IndexToSlotNo");

	Params::SaveDataMenuUIObject_IndexToSlotNo Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataMenuUIObject.IsSaveAndReturnToTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataMenuUIObject::IsSaveAndReturnToTitle(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "IsSaveAndReturnToTitle");

	Params::SaveDataMenuUIObject_IsSaveAndReturnToTitle Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataMenuUIObject.MakeCurrentSortedSlots
// (Final, Native, Public, BlueprintCallable)

void USaveDataMenuUIObject::MakeCurrentSortedSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "MakeCurrentSortedSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.OnScreenMaskCompleted
// (Final, Native, Protected)

void USaveDataMenuUIObject::OnScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "OnScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.OnScreenMaskCompletedBP
// (Event, Public, BlueprintEvent)

void USaveDataMenuUIObject::OnScreenMaskCompletedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "OnScreenMaskCompletedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.SaveDataMenuUIObject.RequestDeleteSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InMainSlotNo                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveDataMenuUIObject::RequestDeleteSaveData(const int32 InMainSlotNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "RequestDeleteSaveData");

	Params::SaveDataMenuUIObject_RequestDeleteSaveData Parms{};

	Parms.InMainSlotNo = InMainSlotNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SaveDataMenuUIObject.RequestSelectSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EGameFlowTitleMenuType            InMenuType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InSlotNo                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataMenuUIObject::RequestSelectSaveData(const EGameFlowTitleMenuType InMenuType, const int32 InSlotNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "RequestSelectSaveData");

	Params::SaveDataMenuUIObject_RequestSelectSaveData Parms{};

	Parms.InMenuType = InMenuType;
	Parms.InSlotNo = InSlotNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.SetSaveDataGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EUISaveDataGroup                  InSaveDataGroup                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveDataMenuUIObject::SetSaveDataGroup(const EUISaveDataGroup InSaveDataGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "SetSaveDataGroup");

	Params::SaveDataMenuUIObject_SetSaveDataGroup Parms{};

	Parms.InSaveDataGroup = InSaveDataGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.TriggerCancelDelegate
// (Final, Native, Public, BlueprintCallable)

void USaveDataMenuUIObject::TriggerCancelDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "TriggerCancelDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SaveDataMenuUIObject.GetSaveDataGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUISaveDataGroup                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUISaveDataGroup USaveDataMenuUIObject::GetSaveDataGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveDataMenuUIObject", "GetSaveDataGroup");

	Params::SaveDataMenuUIObject_GetSaveDataGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ScenarioNPCComponent.ForceStartEmoteAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InEmotionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::ForceStartEmoteAnimation(class FName InEmotionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "ForceStartEmoteAnimation");

	Params::ScenarioNPCComponent_ForceStartEmoteAnimation Parms{};

	Parms.InEmotionName = InEmotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnBeginOverlapLookAtCollision
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnBeginOverlapLookAtCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnBeginOverlapLookAtCollision");

	Params::ScenarioNPCComponent_OnBeginOverlapLookAtCollision Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnBeginSmallScenario
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnBeginSmallScenario(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnBeginSmallScenario");

	Params::ScenarioNPCComponent_OnBeginSmallScenario Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnChangeRegion
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTagContainer&     InPreFieldRegion                                       (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InCurrentFieldRegion                                   (Parm, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnChangeRegion(const struct FGameplayTagContainer& InPreFieldRegion, const struct FGameplayTagContainer& InCurrentFieldRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnChangeRegion");

	Params::ScenarioNPCComponent_OnChangeRegion Parms{};

	Parms.InPreFieldRegion = std::move(InPreFieldRegion);
	Parms.InCurrentFieldRegion = std::move(InCurrentFieldRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnChangeStoryFlag
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagChangeParam&     Param                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnChangeStoryFlag(const struct FStoryFlagChangeParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnChangeStoryFlag");

	Params::ScenarioNPCComponent_OnChangeStoryFlag Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnChangeTimeSeries
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnChangeTimeSeries(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnChangeTimeSeries");

	Params::ScenarioNPCComponent_OnChangeTimeSeries Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnEndOverlapLookAtCollision
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::OnEndOverlapLookAtCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnEndOverlapLookAtCollision");

	Params::ScenarioNPCComponent_OnEndOverlapLookAtCollision Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnEndSmallScenario
// (Final, Native, Private)

void UScenarioNPCComponent::OnEndSmallScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnEndSmallScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.OnFinishTurn
// (Final, Native, Public, BlueprintCallable)

void UScenarioNPCComponent::OnFinishTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "OnFinishTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.RequestTurn
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FTurnRequestInfo&          RequestInfo                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::RequestTurn(const struct FTurnRequestInfo& RequestInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "RequestTurn");

	Params::ScenarioNPCComponent_RequestTurn Parms{};

	Parms.RequestInfo = std::move(RequestInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.SetEmotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EmotionName_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::SetEmotion(class FName EmotionName_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "SetEmotion");

	Params::ScenarioNPCComponent_SetEmotion Parms{};

	Parms.EmotionName_0 = EmotionName_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.SetFacialType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacialType                             NewFacialType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::SetFacialType(EFacialType NewFacialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "SetFacialType");

	Params::ScenarioNPCComponent_SetFacialType Parms{};

	Parms.NewFacialType = NewFacialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.SetGesture
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGestureInfo&              InGestureInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestTimer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::SetGesture(const struct FGestureInfo& InGestureInfo, bool bRequestTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "SetGesture");

	Params::ScenarioNPCComponent_SetGesture Parms{};

	Parms.InGestureInfo = std::move(InGestureInfo);
	Parms.bRequestTimer = bRequestTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.SetScenarioClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ASmallScenarioBase>   InScenarioClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::SetScenarioClass(TSubclassOf<class ASmallScenarioBase> InScenarioClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "SetScenarioClass");

	Params::ScenarioNPCComponent_SetScenarioClass Parms{};

	Parms.InScenarioClass = InScenarioClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.StartEmoteAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InEmotionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioNPCComponent::StartEmoteAnimation(class FName InEmotionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "StartEmoteAnimation");

	Params::ScenarioNPCComponent_StartEmoteAnimation Parms{};

	Parms.InEmotionName = InEmotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.StartNormalStateBehavior
// (Final, Native, Private, BlueprintCallable)

void UScenarioNPCComponent::StartNormalStateBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "StartNormalStateBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCComponent.StopEmoteAnimation
// (Final, Native, Public, BlueprintCallable)

void UScenarioNPCComponent::StopEmoteAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCComponent", "StopEmoteAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCInteractiveActor.OnSmallScenarioEnded
// (Final, Native, Private)

void AScenarioNPCInteractiveActor::OnSmallScenarioEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCInteractiveActor", "OnSmallScenarioEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScenarioNPCInteractiveActor.SetCanInteract_Implementation
// (Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bInCanInteract                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScenarioNPCInteractiveActor::SetCanInteract_Implementation(const bool bInCanInteract, const class FString& InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioNPCInteractiveActor", "SetCanInteract_Implementation");

	Params::ScenarioNPCInteractiveActor_SetCanInteract_Implementation Parms{};

	Parms.bInCanInteract = bInCanInteract;
	Parms.InID = std::move(InID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenEffectUIObject.HideDeathEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenEffectUIObject::HideDeathEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenEffectUIObject", "HideDeathEffect");

	Params::ScreenEffectUIObject_HideDeathEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenEffectUIObject.SetDeathEffectVisibilityForcibly
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenEffectUIObject::SetDeathEffectVisibilityForcibly(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenEffectUIObject", "SetDeathEffectVisibilityForcibly");

	Params::ScreenEffectUIObject_SetDeathEffectVisibilityForcibly Parms{};

	Parms.InVisible = InVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ScreenEffectUIObject.ShowDeathEffect
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenEffectUIObject::ShowDeathEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenEffectUIObject", "ShowDeathEffect");

	Params::ScreenEffectUIObject_ShowDeathEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenMaskUIObject.HideScreenMask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InHideTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EScreenMaskEffectType             InEffectType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenMaskUIObject::HideScreenMask(class UObject* InWorldContext, const float InHideTime, const EScreenMaskEffectType InEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenMaskUIObject", "HideScreenMask");

	Params::ScreenMaskUIObject_HideScreenMask Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InHideTime = InHideTime;
	Parms.InEffectType = InEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.HideTips
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenMaskUIObject::HideTips(class UObject* InWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenMaskUIObject", "HideTips");

	Params::ScreenMaskUIObject_HideTips Parms{};

	Parms.InWorldContext = InWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.ShowScreenMask
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaskTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EScreenMaskEffectType             InEffectType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenMaskUIObject::ShowScreenMask(class UObject* InWorldContext, const struct FLinearColor& InColor, const float InMaskTime, const EScreenMaskEffectType InEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenMaskUIObject", "ShowScreenMask");

	Params::ScreenMaskUIObject_ShowScreenMask Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InColor = std::move(InColor);
	Parms.InMaskTime = InMaskTime;
	Parms.InEffectType = InEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.ShowTips
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InTitleText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InContentsText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScreenMaskUIObject::ShowTips(class UObject* InWorldContext, const class FText& InTitleText, const class FText& InContentsText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenMaskUIObject", "ShowTips");

	Params::ScreenMaskUIObject_ShowTips Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InTitleText = std::move(InTitleText);
	Parms.InContentsText = std::move(InContentsText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.HideScreenMaskBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             InHideTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EScreenMaskEffectType             InEffectType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenMaskUIObject::HideScreenMaskBP(const float InHideTime, const EScreenMaskEffectType InEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "HideScreenMaskBP");

	Params::ScreenMaskUIObject_HideScreenMaskBP Parms{};

	Parms.InHideTime = InHideTime;
	Parms.InEffectType = InEffectType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenMaskUIObject.HideTipsBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenMaskUIObject::HideTipsBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "HideTipsBP");

	Params::ScreenMaskUIObject_HideTipsBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenMaskUIObject.NotifyScreenMaskCompleted
// (Final, Native, Public, BlueprintCallable)

void UScreenMaskUIObject::NotifyScreenMaskCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "NotifyScreenMaskCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.NotifyScreenMaskRemoved
// (Final, Native, Public, BlueprintCallable)

void UScreenMaskUIObject::NotifyScreenMaskRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "NotifyScreenMaskRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ScreenMaskUIObject.SetScreenMaskVisibilityForcibly
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenMaskUIObject::SetScreenMaskVisibilityForcibly(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "SetScreenMaskVisibilityForcibly");

	Params::ScreenMaskUIObject_SetScreenMaskVisibilityForcibly Parms{};

	Parms.InVisible = InVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ScreenMaskUIObject.ShowScreenMaskBP
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FLinearColor&              InColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaskTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EScreenMaskEffectType             InEffectType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenMaskUIObject::ShowScreenMaskBP(const struct FLinearColor& InColor, const float InMaskTime, const EScreenMaskEffectType InEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "ShowScreenMaskBP");

	Params::ScreenMaskUIObject_ShowScreenMaskBP Parms{};

	Parms.InColor = std::move(InColor);
	Parms.InMaskTime = InMaskTime;
	Parms.InEffectType = InEffectType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ScreenMaskUIObject.ShowTipsBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InTitleText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InContentsText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenMaskUIObject::ShowTipsBP(const class FText& InTitleText, const class FText& InContentsText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenMaskUIObject", "ShowTipsBP");

	Params::ScreenMaskUIObject_ShowTipsBP Parms{};

	Parms.InTitleText = std::move(InTitleText);
	Parms.InContentsText = std::move(InContentsText);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.SealingDeviceActor.GetRotationWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASealingDeviceActor::GetRotationWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealingDeviceActor", "GetRotationWeight");

	Params::SealingDeviceActor_GetRotationWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SealingDeviceActor.IsSpawnedBySequencer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASealingDeviceActor::IsSpawnedBySequencer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealingDeviceActor", "IsSpawnedBySequencer");

	Params::SealingDeviceActor_IsSpawnedBySequencer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughObjectIF.GetSeeThroughMaterial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ISeeThroughObjectIF::GetSeeThroughMaterial(class AActor* InActor, class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SeeThroughObjectIF", "GetSeeThroughMaterial");

	Params::SeeThroughObjectIF_GetSeeThroughMaterial Parms{};

	Parms.InActor = InActor;
	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughObjectIF.GetSeeThroughMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* ISeeThroughObjectIF::GetSeeThroughMesh(class AActor* InActor, class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SeeThroughObjectIF", "GetSeeThroughMesh");

	Params::SeeThroughObjectIF_GetSeeThroughMesh Parms{};

	Parms.InActor = InActor;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughObjectIF.IsSeeThroughObject
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISeeThroughObjectIF::IsSeeThroughObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SeeThroughObjectIF", "IsSeeThroughObject");

	Params::SeeThroughObjectIF_IsSeeThroughObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SeeThroughObjectIF.UseSeeThroughMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISeeThroughObjectIF::UseSeeThroughMesh(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SeeThroughObjectIF", "UseSeeThroughMesh");

	Params::SeeThroughObjectIF_UseSeeThroughMesh Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SelectActorGizmoComponent.OnBeginCursorOver
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectActorGizmoComponent::OnBeginCursorOver(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectActorGizmoComponent", "OnBeginCursorOver");

	Params::SelectActorGizmoComponent_OnBeginCursorOver Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SelectActorGizmoComponent.OnEndCursorOver
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectActorGizmoComponent::OnEndCursorOver(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectActorGizmoComponent", "OnEndCursorOver");

	Params::SelectActorGizmoComponent_OnEndCursorOver Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Volume.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFromSweep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASensor_Volume::OnComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Volume", "OnComponentBeginOverlap");

	Params::Sensor_Volume_OnComponentBeginOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.Sensor_Volume.OnComponentEndOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASensor_Volume::OnComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sensor_Volume", "OnComponentEndOverlap");

	Params::Sensor_Volume_OnComponentEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopMenu.UpdatePossessionHeiz
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InHeiz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopMenu::UpdatePossessionHeiz(int32 InHeiz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenu", "UpdatePossessionHeiz");

	Params::ShopMenu_UpdatePossessionHeiz Parms{};

	Parms.InHeiz = InHeiz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ShopMenuTestActor.GetExp
// (Final, Native, Public)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AShopMenuTestActor::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetExp");

	Params::ShopMenuTestActor_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuTestActor.GetIsUsingTestData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AShopMenuTestActor::GetIsUsingTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetIsUsingTestData");

	Params::ShopMenuTestActor_GetIsUsingTestData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuTestActor.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AShopMenuTestActor::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetPlayerStatusSummaryInfo");

	Params::ShopMenuTestActor_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ShopMenuTestActor.GetShopArticleBoosterInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AShopMenuTestActor::GetShopArticleBoosterInfo(const class FName InShopName, const int32 InListIndex, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetShopArticleBoosterInfo");

	Params::ShopMenuTestActor_GetShopArticleBoosterInfo Parms{};

	Parms.InShopName = InShopName;
	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuTestActor.GetShopArticleItemInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AShopMenuTestActor::GetShopArticleItemInfo(const class FName InShopName, const int32 InListIndex, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetShopArticleItemInfo");

	Params::ShopMenuTestActor_GetShopArticleItemInfo Parms{};

	Parms.InShopName = InShopName;
	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuTestActor.GetShopArticleStockInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InListIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopStockUIInfo*                OutStockInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void AShopMenuTestActor::GetShopArticleStockInfo(const class FName InShopName, int32 InListIndex, struct FShopStockUIInfo* OutStockInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetShopArticleStockInfo");

	Params::ShopMenuTestActor_GetShopArticleStockInfo Parms{};

	Parms.InShopName = InShopName;
	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStockInfo != nullptr)
		*OutStockInfo = std::move(Parms.OutStockInfo);
}


// Function Extensions.ShopMenuTestActor.GetShopArticleWeaponInfo
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InListIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void AShopMenuTestActor::GetShopArticleWeaponInfo(const class FName InShopName, const int32 InListIndex, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetShopArticleWeaponInfo");

	Params::ShopMenuTestActor_GetShopArticleWeaponInfo Parms{};

	Parms.InShopName = InShopName;
	Parms.InListIndex = InListIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuTestActor.GetShopTotalNumber
// (Final, Native, Public)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 AShopMenuTestActor::GetShopTotalNumber(const class FName InShopName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "GetShopTotalNumber");

	Params::ShopMenuTestActor_GetShopTotalNumber Parms{};

	Parms.InShopName = InShopName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuTestActor.RequestUseTestData
// (Final, Native, Public, BlueprintCallable)

void AShopMenuTestActor::RequestUseTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "RequestUseTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopMenuTestActor.TradeItem
// (Final, Native, Public)
// Parameters:
// const class FName                       InShopName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InShopListIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InQuantity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AShopMenuTestActor::TradeItem(const class FName InShopName, int32 InShopListIndex, int32 InQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuTestActor", "TradeItem");

	Params::ShopMenuTestActor_TradeItem Parms{};

	Parms.InShopName = InShopName;
	Parms.InShopListIndex = InShopListIndex;
	Parms.InQuantity = InQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.CreatePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UShopMenuUIObject::CreatePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "CreatePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopMenuUIObject.DeletePreviewCharacter
// (Final, Native, Protected, BlueprintCallable)

void UShopMenuUIObject::DeletePreviewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "DeletePreviewCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopMenuUIObject.GetArticleStockInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FShopStockUIInfo*                OutStockInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetArticleStockInfo(const struct FUIShopQueryInfo& InShopQuery, struct FShopStockUIInfo* OutStockInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetArticleStockInfo");

	Params::ShopMenuUIObject_GetArticleStockInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStockInfo != nullptr)
		*OutStockInfo = std::move(Parms.OutStockInfo);
}


// Function Extensions.ShopMenuUIObject.GetBloodCodeArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBloodCodeInfo*                OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetBloodCodeArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIBloodCodeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetBloodCodeArticleUIInfo");

	Params::ShopMenuUIObject_GetBloodCodeArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetBoosterArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIBoosterInfo*                  OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetBoosterArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIBoosterInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetBoosterArticleUIInfo");

	Params::ShopMenuUIObject_GetBoosterArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetDefenciveGadgetArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetDefenciveGadgetArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetDefenciveGadgetArticleUIInfo");

	Params::ShopMenuUIObject_GetDefenciveGadgetArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetEquipedArticleIndexInSell
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EUIMainCategory                   InCategory                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutIndexes                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetEquipedArticleIndexInSell(const EUIMainCategory InCategory, TArray<int32>* OutIndexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetEquipedArticleIndexInSell");

	Params::ShopMenuUIObject_GetEquipedArticleIndexInSell Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndexes != nullptr)
		*OutIndexes = std::move(Parms.OutIndexes);
}


// Function Extensions.ShopMenuUIObject.GetEquipedDefensiveGadgetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIDefensiveGadgetInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetEquipedDefensiveGadgetUIInfo(struct FUIDefensiveGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetEquipedDefensiveGadgetUIInfo");

	Params::ShopMenuUIObject_GetEquipedDefensiveGadgetUIInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetEquipedJailUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetEquipedJailUIInfo(struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetEquipedJailUIInfo");

	Params::ShopMenuUIObject_GetEquipedJailUIInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UShopMenuUIObject::GetExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetExp");

	Params::ShopMenuUIObject_GetExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.GetIndependentGadgetArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIIndependentGadgetInfo*        OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetIndependentGadgetArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIIndependentGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetIndependentGadgetArticleUIInfo");

	Params::ShopMenuUIObject_GetIndependentGadgetArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetItemArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIItemInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetItemArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIItemInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetItemArticleUIInfo");

	Params::ShopMenuUIObject_GetItemArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetJailArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIJailInfo*                     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetJailArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIJailInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetJailArticleUIInfo");

	Params::ShopMenuUIObject_GetJailArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetMainWeaponUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetMainWeaponUIInfo(struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetMainWeaponUIInfo");

	Params::ShopMenuUIObject_GetMainWeaponUIInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetPlayerStatusSummaryInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetPlayerStatusSummaryInfo(struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetPlayerStatusSummaryInfo");

	Params::ShopMenuUIObject_GetPlayerStatusSummaryInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ShopMenuUIObject.GetPlayerStatusSummaryInfoWithShopEquipment
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InQueryInfo                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIPlayerStatusSummaryInfo*      OutSummaryInfo                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetPlayerStatusSummaryInfoWithShopEquipment(const struct FUIShopQueryInfo& InQueryInfo, struct FUIPlayerStatusSummaryInfo* OutSummaryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetPlayerStatusSummaryInfoWithShopEquipment");

	Params::ShopMenuUIObject_GetPlayerStatusSummaryInfoWithShopEquipment Parms{};

	Parms.InQueryInfo = std::move(InQueryInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSummaryInfo != nullptr)
		*OutSummaryInfo = std::move(Parms.OutSummaryInfo);
}


// Function Extensions.ShopMenuUIObject.GetShopName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UShopMenuUIObject::GetShopName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetShopName");

	Params::ShopMenuUIObject_GetShopName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.GetShopTitleName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const class FText UShopMenuUIObject::GetShopTitleName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetShopTitleName");

	Params::ShopMenuUIObject_GetShopTitleName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.GetShopTotalItemNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUIMainCategory                         InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShopMenuUIObject::GetShopTotalItemNumber(EUIMainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetShopTotalItemNumber");

	Params::ShopMenuUIObject_GetShopTotalItemNumber Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.GetSpecialBuffListWithShopEquipment
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUISpecialBuffListInfo*          OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetSpecialBuffListWithShopEquipment(const struct FUIShopQueryInfo& InInfo, struct FUISpecialBuffListInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetSpecialBuffListWithShopEquipment");

	Params::ShopMenuUIObject_GetSpecialBuffListWithShopEquipment Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetWeaponArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponInfo*                   OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetWeaponArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIWeaponInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetWeaponArticleUIInfo");

	Params::ShopMenuUIObject_GetWeaponArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.GetWeaponGadgetArticleUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUIWeaponGadgetInfo*             OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UShopMenuUIObject::GetWeaponGadgetArticleUIInfo(const struct FUIShopQueryInfo& InShopQuery, struct FUIWeaponGadgetInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "GetWeaponGadgetArticleUIInfo");

	Params::ShopMenuUIObject_GetWeaponGadgetArticleUIInfo Parms{};

	Parms.InShopQuery = std::move(InShopQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);
}


// Function Extensions.ShopMenuUIObject.IsSellMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopMenuUIObject::IsSellMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "IsSellMenu");

	Params::ShopMenuUIObject_IsSellMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.OnCloseMenuNotify
// (Final, Native, Public, BlueprintCallable)

void UShopMenuUIObject::OnCloseMenuNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "OnCloseMenuNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ShopMenuUIObject.OpenBuyMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InShopName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UShopMenuUIObject::OpenBuyMenu(class FName InShopName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "OpenBuyMenu");

	Params::ShopMenuUIObject_OpenBuyMenu Parms{};

	Parms.InShopName = InShopName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.OpenSellMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMenuBase*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuBase* UShopMenuUIObject::OpenSellMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "OpenSellMenu");

	Params::ShopMenuUIObject_OpenSellMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.TradeItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FUIShopQueryInfo&          InShopQuery                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InQuantity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopMenuUIObject::TradeItem(const struct FUIShopQueryInfo& InShopQuery, int32 InQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "TradeItem");

	Params::ShopMenuUIObject_TradeItem Parms{};

	Parms.InShopQuery = std::move(InShopQuery);
	Parms.InQuantity = InQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.ShopMenuUIObject.TradeSuccessNotifyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FScenarioNPCEventInfo&     InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UShopMenuUIObject::TradeSuccessNotifyEvent(const struct FScenarioNPCEventInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopMenuUIObject", "TradeSuccessNotifyEvent");

	Params::ShopMenuUIObject_TradeSuccessNotifyEvent Parms{};

	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletComponent.SetSpawnEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpawnBulletComponent::SetSpawnEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnBulletComponent", "SetSpawnEnable");

	Params::SpawnBulletComponent_SetSpawnEnable Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletComponent.SpawnBullet
// (Final, Native, Public, BlueprintCallable)

void USpawnBulletComponent::SpawnBullet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnBulletComponent", "SpawnBullet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpawnBulletComponent.IsSpawnEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnBulletComponent::IsSpawnEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnBulletComponent", "IsSpawnEnable");

	Params::SpawnBulletComponent_IsSpawnEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.WeaponPostProcessAnimInstance.SetPoseSnapshot
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseSnapshot&             InPoseSnapshot                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponPostProcessAnimInstance::SetPoseSnapshot(const struct FPoseSnapshot& InPoseSnapshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPostProcessAnimInstance", "SetPoseSnapshot");

	Params::WeaponPostProcessAnimInstance_SetPoseSnapshot Parms{};

	Parms.InPoseSnapshot = std::move(InPoseSnapshot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.WeaponPostProcessAnimInstance.GetGearWeight
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponPostProcessAnimInstance::GetGearWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPostProcessAnimInstance", "GetGearWeight");

	Params::WeaponPostProcessAnimInstance_GetGearWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Yadorigi.CanCampRest
// (Final, Native, Protected)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AYadorigi::CanCampRest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Yadorigi", "CanCampRest");

	Params::Yadorigi_CanCampRest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Yadorigi.GetYadorigiName
// (Final, Native, Protected)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AYadorigi::GetYadorigiName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Yadorigi", "GetYadorigiName");

	Params::Yadorigi_GetYadorigiName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.Yadorigi.OnUIClosed
// (Final, Native, Private)

void AYadorigi::OnUIClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Yadorigi", "OnUIClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TextureFunctionLibrary.ExportBinaryToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    OutData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextureFunctionLibrary::ExportBinaryToFile(class UObject* WorldContextObject, const class FString& FilePath, const class FString& Filename, const TArray<uint8>& OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextureFunctionLibrary", "ExportBinaryToFile");

	Params::TextureFunctionLibrary_ExportBinaryToFile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FilePath = std::move(FilePath);
	Parms.Filename = std::move(Filename);
	Parms.OutData = std::move(OutData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TextureFunctionLibrary.GetPngDataFromRenderTarget2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>*                          OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextureFunctionLibrary::GetPngDataFromRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, TArray<uint8>* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextureFunctionLibrary", "GetPngDataFromRenderTarget2D");

	Params::TextureFunctionLibrary_GetPngDataFromRenderTarget2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function Extensions.TextureFunctionLibrary.GetPngDataFromTexture2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTexture2D*                 InTexture                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>*                          OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextureFunctionLibrary::GetPngDataFromTexture2D(class UObject* WorldContextObject, const class UTexture2D* InTexture, TArray<uint8>* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextureFunctionLibrary", "GetPngDataFromTexture2D");

	Params::TextureFunctionLibrary_GetPngDataFromTexture2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function Extensions.TextureFunctionLibrary.GetTexture2DFromPngData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    InData                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D**                      OutTexture                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextureFunctionLibrary::GetTexture2DFromPngData(class UObject* WorldContextObject, const TArray<uint8>& InData, class UTexture2D** OutTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextureFunctionLibrary", "GetTexture2DFromPngData");

	Params::TextureFunctionLibrary_GetTexture2DFromPngData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = Parms.OutTexture;

	return Parms.ReturnValue;
}


// Function Extensions.TextureFunctionLibrary.GetTextureFromRenderTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewTexName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D**                      NewTexture                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextureFunctionLibrary::GetTextureFromRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& NewTexName, class UTexture2D** NewTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextureFunctionLibrary", "GetTextureFromRenderTarget");

	Params::TextureFunctionLibrary_GetTextureFromRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.NewTexName = std::move(NewTexName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTexture != nullptr)
		*NewTexture = Parms.NewTexture;

	return Parms.ReturnValue;
}


// Function Extensions.TitleProgressManager.OnStoryFlagChange
// (Final, Native, Private)
// Parameters:
// const struct FStoryFlagEvaluationFormula&EvaluationFormula                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleProgressManager::OnStoryFlagChange(const struct FStoryFlagEvaluationFormula& EvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleProgressManager", "OnStoryFlagChange");

	Params::TitleProgressManager_OnStoryFlagChange Parms{};

	Parms.EvaluationFormula = std::move(EvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TutorialVolume.OnDescriptionWindowClosed
// (Native, Public)

void ATutorialVolume::OnDescriptionWindowClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialVolume", "OnDescriptionWindowClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TutorialVolume.OnEvaluationFormulaResultUpdated
// (Native, Public)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialVolume::OnEvaluationFormulaResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialVolume", "OnEvaluationFormulaResultUpdated");

	Params::TutorialVolume_OnEvaluationFormulaResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualEffectManager.GetCurrentViewTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UVisualEffectManager::GetCurrentViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "GetCurrentViewTarget");

	Params::VisualEffectManager_GetCurrentViewTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualEffectManager.IsCinematicScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InCheckCineCamera                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualEffectManager::IsCinematicScene(bool InCheckCineCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "IsCinematicScene");

	Params::VisualEffectManager_IsCinematicScene Parms{};

	Parms.InCheckCineCamera = InCheckCineCamera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualEffectManager.OnEndPhotoMode
// (Final, Native, Public)

void UVisualEffectManager::OnEndPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "OnEndPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualEffectManager.OnStartPhotoMode
// (Final, Native, Public)

void UVisualEffectManager::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualEffectManager.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UVisualEffectManager::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.VisualEffectManager.ReceiveEndPhotoMode
// (Event, Public, BlueprintEvent)

void UVisualEffectManager::ReceiveEndPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "ReceiveEndPhotoMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.VisualEffectManager.ReceiveEndPlay
// (Event, Public, BlueprintEvent)

void UVisualEffectManager::ReceiveEndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "ReceiveEndPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.VisualEffectManager.ReceiveStartPhotoMode
// (Event, Public, BlueprintEvent)

void UVisualEffectManager::ReceiveStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "ReceiveStartPhotoMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.VisualEffectManager.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualEffectManager::ReceiveTick(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "ReceiveTick");

	Params::VisualEffectManager_ReceiveTick Parms{};

	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.VisualEffectManager.Trace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InStart                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InEnd                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVisualEffectManager::Trace(const struct FVector& InStart, const struct FVector& InEnd, float InRadius, bool* bOutResult, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "Trace");

	Params::VisualEffectManager_Trace Parms{};

	Parms.InStart = std::move(InStart);
	Parms.InEnd = std::move(InEnd);
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutResult != nullptr)
		*bOutResult = Parms.bOutResult;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);
}


// Function Extensions.VisualEffectManager.IsShowPlayerPositionDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualEffectManager::IsShowPlayerPositionDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEffectManager", "IsShowPlayerPositionDebugInfo");

	Params::VisualEffectManager_IsShowPlayerPositionDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpecialBuffController.OnRep_ContainerInfoMap
// (Final, Native, Public)

void USpecialBuffController::OnRep_ContainerInfoMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBuffController", "OnRep_ContainerInfoMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpecialBuffController.RequestSync
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpecialBuffController::RequestSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBuffController", "RequestSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpBuffEndCondition_Immediate.OnEndTimer
// (Final, Native, Private)

void USpBuffEndCondition_Immediate::OnEndTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffEndCondition_Immediate", "OnEndTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StateListenerUI.OnBattleStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InBattleState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IStateListenerUI::OnBattleStateChanged(bool InBattleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("StateListenerUI", "OnBattleStateChanged");

	Params::StateListenerUI_OnBattleStateChanged Parms{};

	Parms.InBattleState = InBattleState;

	AsUObject()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Actor_GetObjectGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectGroup*                           OutGroup                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_Actor_GetObjectGroup(class AActor* InActor, EObjectGroup* OutGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Actor_GetObjectGroup");

	Params::VisualControlFunctionLibrary_VCF_Actor_GetObjectGroup Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGroup != nullptr)
		*OutGroup = Parms.OutGroup;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Actor_SetObjectGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EObjectGroup                      InGroup                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_Actor_SetObjectGroup(class AActor* InActor, const EObjectGroup InGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Actor_SetObjectGroup");

	Params::VisualControlFunctionLibrary_VCF_Actor_SetObjectGroup Parms{};

	Parms.InActor = InActor;
	Parms.InGroup = InGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_DebugStatusEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InName                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlFunctionLibrary::VCF_DebugStatusEffect(class ACharacter* InCharacter, const class FString& InName, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_DebugStatusEffect");

	Params::VisualControlFunctionLibrary_VCF_DebugStatusEffect Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InName = std::move(InName);
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_DebugStatusEffect_IsExist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InName                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_DebugStatusEffect_IsExist(class ACharacter* InCharacter, const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_DebugStatusEffect_IsExist");

	Params::VisualControlFunctionLibrary_VCF_DebugStatusEffect_IsExist Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Enemy_GetWeaponActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_Enemy_GetWeaponActors(class ACharacter* InCharacter, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Enemy_GetWeaponActors");

	Params::VisualControlFunctionLibrary_VCF_Enemy_GetWeaponActors Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Enemy_GetWeaponMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InWeaponActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UVisualControlFunctionLibrary::VCF_Enemy_GetWeaponMesh(class AActor* InWeaponActor, int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Enemy_GetWeaponMesh");

	Params::VisualControlFunctionLibrary_VCF_Enemy_GetWeaponMesh Parms{};

	Parms.InWeaponActor = InWeaponActor;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Enemy_GetWeaponMeshCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InWeaponActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVisualControlFunctionLibrary::VCF_Enemy_GetWeaponMeshCount(class AActor* InWeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Enemy_GetWeaponMeshCount");

	Params::VisualControlFunctionLibrary_VCF_Enemy_GetWeaponMeshCount Parms{};

	Parms.InWeaponActor = InWeaponActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_EnemyParameter_GetCatchingFire
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutCatchingFire                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_EnemyParameter_GetCatchingFire(class ACharacter* InCharacter, bool* bOutCatchingFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_EnemyParameter_GetCatchingFire");

	Params::VisualControlFunctionLibrary_VCF_EnemyParameter_GetCatchingFire Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutCatchingFire != nullptr)
		*bOutCatchingFire = Parms.bOutCatchingFire;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_EnemyParameter_SetSightCollisionLimitedName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEnemyParameter*                  InParameter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlFunctionLibrary::VCF_EnemyParameter_SetSightCollisionLimitedName(class UEnemyParameter* InParameter, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_EnemyParameter_SetSightCollisionLimitedName");

	Params::VisualControlFunctionLibrary_VCF_EnemyParameter_SetSightCollisionLimitedName Parms{};

	Parms.InParameter = InParameter;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetBloodVeil
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActionHumanEquipment_Vampire*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActionHumanEquipment_Vampire* UVisualControlFunctionLibrary::VCF_GetBloodVeil(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetBloodVeil");

	Params::VisualControlFunctionLibrary_VCF_GetBloodVeil Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetCharacterVisualControl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterVisualControlComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterVisualControlComponent* UVisualControlFunctionLibrary::VCF_GetCharacterVisualControl(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetCharacterVisualControl");

	Params::VisualControlFunctionLibrary_VCF_GetCharacterVisualControl Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetCurrentBattleMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnemyModeId*                           OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_GetCurrentBattleMode(class ACharacter* InCharacter, EEnemyModeId* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetCurrentBattleMode");

	Params::VisualControlFunctionLibrary_VCF_GetCurrentBattleMode Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetDefenceGadget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActionHumanEquipment_DefenceGadget*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActionHumanEquipment_DefenceGadget* UVisualControlFunctionLibrary::VCF_GetDefenceGadget(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetDefenceGadget");

	Params::VisualControlFunctionLibrary_VCF_GetDefenceGadget Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetEffectData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UEffectData*                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UEffectData* UVisualControlFunctionLibrary::VCF_GetEffectData(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetEffectData");

	Params::VisualControlFunctionLibrary_VCF_GetEffectData Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetEffectInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEffectData*                      InEffectData                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InEffectName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem**                  SystemTemplate                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bAutoActivate                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bAutoDestroy                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent**                   Sound                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_GetEffectInfo(class UEffectData* InEffectData, const class FName& InEffectName, class UNiagaraSystem** SystemTemplate, bool* bAutoActivate, bool* bAutoDestroy, class UAkAudioEvent** Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetEffectInfo");

	Params::VisualControlFunctionLibrary_VCF_GetEffectInfo Parms{};

	Parms.InEffectData = InEffectData;
	Parms.InEffectName = InEffectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SystemTemplate != nullptr)
		*SystemTemplate = Parms.SystemTemplate;

	if (bAutoActivate != nullptr)
		*bAutoActivate = Parms.bAutoActivate;

	if (bAutoDestroy != nullptr)
		*bAutoDestroy = Parms.bAutoDestroy;

	if (Sound != nullptr)
		*Sound = Parms.Sound;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetEnemyEquipmentVisualControl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentVisualControlComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentVisualControlComponent* UVisualControlFunctionLibrary::VCF_GetEnemyEquipmentVisualControl(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetEnemyEquipmentVisualControl");

	Params::VisualControlFunctionLibrary_VCF_GetEnemyEquipmentVisualControl Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetEnemyEquipmentVisualControlFromEquipmentActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InEquipmentActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentVisualControlComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentVisualControlComponent* UVisualControlFunctionLibrary::VCF_GetEnemyEquipmentVisualControlFromEquipmentActor(class AActor* InEquipmentActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetEnemyEquipmentVisualControlFromEquipmentActor");

	Params::VisualControlFunctionLibrary_VCF_GetEnemyEquipmentVisualControlFromEquipmentActor Parms{};

	Parms.InEquipmentActor = InEquipmentActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetEnemyState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnemyState*                            OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_GetEnemyState(class ACharacter* InCharacter, EEnemyState* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetEnemyState");

	Params::VisualControlFunctionLibrary_VCF_GetEnemyState Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetGameplayCueTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGameplayCueNotify_Actor*         InGameplayCueActor                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UVisualControlFunctionLibrary::VCF_GetGameplayCueTag(class AGameplayCueNotify_Actor* InGameplayCueActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetGameplayCueTag");

	Params::VisualControlFunctionLibrary_VCF_GetGameplayCueTag Parms{};

	Parms.InGameplayCueActor = InGameplayCueActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetMinimapMoveHistory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMiniMapMoveHistoryData>* OutHistoryArray                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_GetMinimapMoveHistory(class ACharacter* InCharacter, TArray<struct FMiniMapMoveHistoryData>* OutHistoryArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetMinimapMoveHistory");

	Params::VisualControlFunctionLibrary_VCF_GetMinimapMoveHistory Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHistoryArray != nullptr)
		*OutHistoryArray = std::move(Parms.OutHistoryArray);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetMinimapMoveHistory_LocationArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 OutLocationArray                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_GetMinimapMoveHistory_LocationArray(class ACharacter* InCharacter, TArray<struct FVector>* OutLocationArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetMinimapMoveHistory_LocationArray");

	Params::VisualControlFunctionLibrary_VCF_GetMinimapMoveHistory_LocationArray Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationArray != nullptr)
		*OutLocationArray = std::move(Parms.OutLocationArray);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetPlayerCamera
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* UVisualControlFunctionLibrary::VCF_GetPlayerCamera(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetPlayerCamera");

	Params::VisualControlFunctionLibrary_VCF_GetPlayerCamera Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetPlayerIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVisualControlFunctionLibrary::VCF_GetPlayerIndex(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetPlayerIndex");

	Params::VisualControlFunctionLibrary_VCF_GetPlayerIndex Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetSAGadgetGadget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActionHumanEquipment_SAGadget*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActionHumanEquipment_SAGadget* UVisualControlFunctionLibrary::VCF_GetSAGadgetGadget(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetSAGadgetGadget");

	Params::VisualControlFunctionLibrary_VCF_GetSAGadgetGadget Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetWeaponActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActionHumanEquipment_Weapon*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActionHumanEquipment_Weapon* UVisualControlFunctionLibrary::VCF_GetWeaponActor(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetWeaponActor");

	Params::VisualControlFunctionLibrary_VCF_GetWeaponActor Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetWeaponMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UVisualControlFunctionLibrary::VCF_GetWeaponMesh(class ACharacter* InCharacter, int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetWeaponMesh");

	Params::VisualControlFunctionLibrary_VCF_GetWeaponMesh Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_GetWeaponMeshCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVisualControlFunctionLibrary::VCF_GetWeaponMeshCount(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_GetWeaponMeshCount");

	Params::VisualControlFunctionLibrary_VCF_GetWeaponMeshCount Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_MakeBoxFromVectorArray
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           InVectorArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UVisualControlFunctionLibrary::VCF_MakeBoxFromVectorArray(const TArray<struct FVector>& InVectorArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_MakeBoxFromVectorArray");

	Params::VisualControlFunctionLibrary_VCF_MakeBoxFromVectorArray Parms{};

	Parms.InVectorArray = std::move(InVectorArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_MinimapMoveHistory_ConstructSpline
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 InSplineComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutStartIndexArray                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bInUpdateSpline                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_MinimapMoveHistory_ConstructSpline(class ACharacter* InCharacter, class USplineComponent* InSplineComponent, TArray<int32>* OutStartIndexArray, bool bInUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_MinimapMoveHistory_ConstructSpline");

	Params::VisualControlFunctionLibrary_VCF_MinimapMoveHistory_ConstructSpline Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InSplineComponent = InSplineComponent;
	Parms.bInUpdateSpline = bInUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartIndexArray != nullptr)
		*OutStartIndexArray = std::move(Parms.OutStartIndexArray);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_MinimapMoveHistory_ConstructSplineArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USplineComponent*>*        OutSplineComponentArray                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_MinimapMoveHistory_ConstructSplineArray(class AActor* InOwner, class ACharacter* InCharacter, TArray<class USplineComponent*>* OutSplineComponentArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_MinimapMoveHistory_ConstructSplineArray");

	Params::VisualControlFunctionLibrary_VCF_MinimapMoveHistory_ConstructSplineArray Parms{};

	Parms.InOwner = InOwner;
	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSplineComponentArray != nullptr)
		*OutSplineComponentArray = std::move(Parms.OutSplineComponentArray);

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_NiagaraComponent_IsComplete
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_NiagaraComponent_IsComplete(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_NiagaraComponent_IsComplete");

	Params::VisualControlFunctionLibrary_VCF_NiagaraComponent_IsComplete Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_NiagaraComponent_IsInactive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_NiagaraComponent_IsInactive(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_NiagaraComponent_IsInactive");

	Params::VisualControlFunctionLibrary_VCF_NiagaraComponent_IsInactive Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_NiagaraComponent_IsInactive_Requested
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_NiagaraComponent_IsInactive_Requested(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_NiagaraComponent_IsInactive_Requested");

	Params::VisualControlFunctionLibrary_VCF_NiagaraComponent_IsInactive_Requested Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_SetStaticMeshBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBoxSphereBounds&          InBounds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVisualControlFunctionLibrary::VCF_SetStaticMeshBounds(class UPrimitiveComponent* InComponent, const struct FBoxSphereBounds& InBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_SetStaticMeshBounds");

	Params::VisualControlFunctionLibrary_VCF_SetStaticMeshBounds Parms{};

	Parms.InComponent = InComponent;
	Parms.InBounds = std::move(InBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_SkeletalMesh_GetPolygonVertexCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLodIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutPolygonCount                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutVertexCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_SkeletalMesh_GetPolygonVertexCount(class USkeletalMeshComponent* InComponent, int32 InLodIndex, int32* OutPolygonCount, int32* OutVertexCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_SkeletalMesh_GetPolygonVertexCount");

	Params::VisualControlFunctionLibrary_VCF_SkeletalMesh_GetPolygonVertexCount Parms{};

	Parms.InComponent = InComponent;
	Parms.InLodIndex = InLodIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPolygonCount != nullptr)
		*OutPolygonCount = Parms.OutPolygonCount;

	if (OutVertexCount != nullptr)
		*OutVertexCount = Parms.OutVertexCount;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_SkeletalMesh_IsEnableTick
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutPrimaryTick                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutClothTick                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_SkeletalMesh_IsEnableTick(class USkeletalMeshComponent* InComponent, bool* bOutPrimaryTick, bool* bOutClothTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_SkeletalMesh_IsEnableTick");

	Params::VisualControlFunctionLibrary_VCF_SkeletalMesh_IsEnableTick Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutPrimaryTick != nullptr)
		*bOutPrimaryTick = Parms.bOutPrimaryTick;

	if (bOutClothTick != nullptr)
		*bOutClothTick = Parms.bOutClothTick;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_SkeletalMesh_SetEnableTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPrimaryTick                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInClothTick                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVisualControlFunctionLibrary::VCF_SkeletalMesh_SetEnableTick(class USkeletalMeshComponent* InComponent, bool bInPrimaryTick, bool bInClothTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_SkeletalMesh_SetEnableTick");

	Params::VisualControlFunctionLibrary_VCF_SkeletalMesh_SetEnableTick Parms{};

	Parms.InComponent = InComponent;
	Parms.bInPrimaryTick = bInPrimaryTick;
	Parms.bInClothTick = bInClothTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_UnionBoxSphereBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FBoxSphereBounds&          InA                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FBoxSphereBounds&          InB                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UVisualControlFunctionLibrary::VCF_UnionBoxSphereBounds(const struct FBoxSphereBounds& InA, const struct FBoxSphereBounds& InB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_UnionBoxSphereBounds");

	Params::VisualControlFunctionLibrary_VCF_UnionBoxSphereBounds Parms{};

	Parms.InA = std::move(InA);
	Parms.InB = std::move(InB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_UpdateComponentRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlFunctionLibrary::VCF_UpdateComponentRendering(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_UpdateComponentRendering");

	Params::VisualControlFunctionLibrary_VCF_UpdateComponentRendering Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_UpdateNiagaraAssetRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   InNiagaraSystem                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualControlFunctionLibrary::VCF_UpdateNiagaraAssetRendering(class UNiagaraSystem* InNiagaraSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_UpdateNiagaraAssetRendering");

	Params::VisualControlFunctionLibrary_VCF_UpdateNiagaraAssetRendering Parms{};

	Parms.InNiagaraSystem = InNiagaraSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Weapon_GetWeaponMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActionHumanEquipment_Weapon*     InWeapon                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UVisualControlFunctionLibrary::VCF_Weapon_GetWeaponMesh(class AActionHumanEquipment_Weapon* InWeapon, int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Weapon_GetWeaponMesh");

	Params::VisualControlFunctionLibrary_VCF_Weapon_GetWeaponMesh Parms{};

	Parms.InWeapon = InWeapon;
	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VisualControlFunctionLibrary.VCF_Weapon_GetWeaponMeshCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActionHumanEquipment_Weapon*     InWeapon                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVisualControlFunctionLibrary::VCF_Weapon_GetWeaponMeshCount(class AActionHumanEquipment_Weapon* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VisualControlFunctionLibrary", "VCF_Weapon_GetWeaponMeshCount");

	Params::VisualControlFunctionLibrary_VCF_Weapon_GetWeaponMeshCount Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SupportMenuUIObject.BindOnChangeSupportMenuControlType
// (Final, Native, Public, BlueprintCallable)

void USupportMenuUIObject::BindOnChangeSupportMenuControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "BindOnChangeSupportMenuControlType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SupportMenuUIObject.GetControlType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESupportMenuControlType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESupportMenuControlType USupportMenuUIObject::GetControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "GetControlType");

	Params::SupportMenuUIObject_GetControlType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SupportMenuUIObject.GetDebugFullSupportMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USupportMenuUIObject::GetDebugFullSupportMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "GetDebugFullSupportMenu");

	Params::SupportMenuUIObject_GetDebugFullSupportMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SupportMenuUIObject.OnChangeSupportMenuControlType
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESupportMenuControlType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USupportMenuUIObject::OnChangeSupportMenuControlType(ESupportMenuControlType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "OnChangeSupportMenuControlType");

	Params::SupportMenuUIObject_OnChangeSupportMenuControlType Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.SupportMenuUIObject.OnChangeSupportMenuControlTypeCallback
// (Final, Native, Protected)
// Parameters:
// ESupportMenuControlType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USupportMenuUIObject::OnChangeSupportMenuControlTypeCallback(ESupportMenuControlType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "OnChangeSupportMenuControlTypeCallback");

	Params::SupportMenuUIObject_OnChangeSupportMenuControlTypeCallback Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SupportMenuUIObject.SupportMenuFormat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText&                      InSourceText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FText>&              InReplacementTexts                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USupportMenuUIObject::SupportMenuFormat(const class FText& InSourceText, const TArray<class FText>& InReplacementTexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportMenuUIObject", "SupportMenuFormat");

	Params::SupportMenuUIObject_SupportMenuFormat Parms{};

	Parms.InSourceText = std::move(InSourceText);
	Parms.InReplacementTexts = std::move(InReplacementTexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.SpBuffTrigger_AttackNoHit.OnMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInterrupted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuffTrigger_AttackNoHit::OnMontageBlendingOut(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffTrigger_AttackNoHit", "OnMontageBlendingOut");

	Params::SpBuffTrigger_AttackNoHit_OnMontageBlendingOut Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.SpBuffTrigger_AttackNoHit.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpBuffTrigger_AttackNoHit::OnMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpBuffTrigger_AttackNoHit", "OnMontageStarted");

	Params::SpBuffTrigger_AttackNoHit_OnMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StatusIndicatorUIObject.BindGameFlagEvent
// (Final, Native, Protected, BlueprintCallable)

void UStatusIndicatorUIObject::BindGameFlagEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "BindGameFlagEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StatusIndicatorUIObject.GetHealthGaugeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EHealthGaugeType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthGaugeType UStatusIndicatorUIObject::GetHealthGaugeType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "GetHealthGaugeType");

	Params::StatusIndicatorUIObject_GetHealthGaugeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.GetResourceGaugeLengthType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EResourceGaugeLengthType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EResourceGaugeLengthType UStatusIndicatorUIObject::GetResourceGaugeLengthType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "GetResourceGaugeLengthType");

	Params::StatusIndicatorUIObject_GetResourceGaugeLengthType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.InitializeIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentHealth                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InCurrentStamina                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxStamina                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             InCurrentHaze                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::InitializeIndicator(const float InCurrentHealth, const float InMaxHealth, const float InCurrentStamina, const float InMaxStamina, const int32 InCurrentHaze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "InitializeIndicator");

	Params::StatusIndicatorUIObject_InitializeIndicator Parms{};

	Parms.InCurrentHealth = InCurrentHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InCurrentStamina = InCurrentStamina;
	Parms.InMaxStamina = InMaxStamina;
	Parms.InCurrentHaze = InCurrentHaze;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyAccumulateStateValueChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InInfo                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UStatusIndicatorUIObject::NotifyAccumulateStateValueChange(const struct FGameplayTag& InEffectTag, const struct FAccumulateAttributeUIInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyAccumulateStateValueChange");

	Params::StatusIndicatorUIObject_NotifyAccumulateStateValueChange Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StatusIndicatorUIObject.NotifyExpChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             InCurrentExp                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::NotifyExpChanged(const int32 InCurrentExp, const EResourceChangeFactor InChangeFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyExpChanged");

	Params::StatusIndicatorUIObject_NotifyExpChanged Parms{};

	Parms.InCurrentExp = InCurrentExp;
	Parms.InChangeFactor = InChangeFactor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyHealthChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentHealth                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::NotifyHealthChanged(const float InCurrentHealth, const float InMaxHealth, const EResourceChangeFactor InChangeFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyHealthChanged");

	Params::StatusIndicatorUIObject_NotifyHealthChanged Parms{};

	Parms.InCurrentHealth = InCurrentHealth;
	Parms.InMaxHealth = InMaxHealth;
	Parms.InChangeFactor = InChangeFactor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStaminaChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const float                             InCurrentStamina                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMaxStamina                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EResourceChangeFactor             InChangeFactor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::NotifyStaminaChanged(const float InCurrentStamina, const float InMaxStamina, const EResourceChangeFactor InChangeFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStaminaChanged");

	Params::StatusIndicatorUIObject_NotifyStaminaChanged Parms{};

	Parms.InCurrentStamina = InCurrentStamina;
	Parms.InMaxStamina = InMaxStamina;
	Parms.InChangeFactor = InChangeFactor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStatusDownEffectApplied
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusDownEffectIconType         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EStatusEffectFrameType            InFrame                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UStatusIndicatorUIObject::NotifyStatusDownEffectApplied(const EStatusDownEffectIconType InType, const EStatusEffectFrameType InFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStatusDownEffectApplied");

	Params::StatusIndicatorUIObject_NotifyStatusDownEffectApplied Parms{};

	Parms.InType = InType;
	Parms.InFrame = InFrame;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStatusEffectRemoved
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::NotifyStatusEffectRemoved(const struct FStatusEffectIconHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStatusEffectRemoved");

	Params::StatusIndicatorUIObject_NotifyStatusEffectRemoved Parms{};

	Parms.InHandle = std::move(InHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStatusEffectTimeElapsed
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FStatusEffectIconHandle&   InHandle                                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             InRemainingTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InTotalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::NotifyStatusEffectTimeElapsed(const struct FStatusEffectIconHandle& InHandle, const float InRemainingTime, const float InTotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStatusEffectTimeElapsed");

	Params::StatusIndicatorUIObject_NotifyStatusEffectTimeElapsed Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InRemainingTime = InRemainingTime;
	Parms.InTotalTime = InTotalTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStatusUpEffectApplied
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusUpEffectIconType           InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EStatusEffectFrameType            InFrame                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UStatusIndicatorUIObject::NotifyStatusUpEffectApplied(const EStatusUpEffectIconType InType, const EStatusEffectFrameType InFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStatusUpEffectApplied");

	Params::StatusIndicatorUIObject_NotifyStatusUpEffectApplied Parms{};

	Parms.InType = InType;
	Parms.InFrame = InFrame;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.NotifyStatusUpEffectAppliedEx
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EStatusUpEffectIconTypeEx         InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EStatusEffectFrameType            InFrame                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatusEffectIconHandle          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectIconHandle UStatusIndicatorUIObject::NotifyStatusUpEffectAppliedEx(const EStatusUpEffectIconTypeEx InType, const EStatusEffectFrameType InFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "NotifyStatusUpEffectAppliedEx");

	Params::StatusIndicatorUIObject_NotifyStatusUpEffectAppliedEx Parms{};

	Parms.InType = InType;
	Parms.InFrame = InFrame;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StatusIndicatorUIObject.OnHarmonyMoon
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusIndicatorUIObject::OnHarmonyMoon(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "OnHarmonyMoon");

	Params::StatusIndicatorUIObject_OnHarmonyMoon Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.StatusIndicatorUIObject.OnHotSpring
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusIndicatorUIObject::OnHotSpring(const struct FGameplayTag& InTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "OnHotSpring");

	Params::StatusIndicatorUIObject_OnHotSpring Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.StatusIndicatorUIObject.UnbindGameFlagEvent
// (Final, Native, Protected, BlueprintCallable)

void UStatusIndicatorUIObject::UnbindGameFlagEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "UnbindGameFlagEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StatusIndicatorUIObject.UpdateAccumulateStateValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FAccumulateGaugeInfo&      InGaugeInfo                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FAccumulateAttributeUIInfo&InAttributeInfo                                        (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusIndicatorUIObject::UpdateAccumulateStateValue(const struct FAccumulateGaugeInfo& InGaugeInfo, const struct FAccumulateAttributeUIInfo& InAttributeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusIndicatorUIObject", "UpdateAccumulateStateValue");

	Params::StatusIndicatorUIObject_UpdateAccumulateStateValue Parms{};

	Parms.InGaugeInfo = std::move(InGaugeInfo);
	Parms.InAttributeInfo = std::move(InAttributeInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.StoryFlagTrigger.OnEvaluationFormulaResultUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStoryFlagTrigger::OnEvaluationFormulaResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoryFlagTrigger", "OnEvaluationFormulaResultUpdated");

	Params::StoryFlagTrigger_OnEvaluationFormulaResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.StoryFlagTrigger.OnTargetFlagUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagChangeParam&     InFlagChangeParam                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AStoryFlagTrigger::OnTargetFlagUpdated(const struct FStoryFlagChangeParam& InFlagChangeParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoryFlagTrigger", "OnTargetFlagUpdated");

	Params::StoryFlagTrigger_OnTargetFlagUpdated Parms{};

	Parms.InFlagChangeParam = std::move(InFlagChangeParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.EnoughInstalledDLC
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContext                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSlot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EDLCType>*                       OutNotEnoughDLCs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::EnoughInstalledDLC(class UObject* InWorldContext, int32 InSlot, TArray<EDLCType>* OutNotEnoughDLCs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TitleMenuUIObject", "EnoughInstalledDLC");

	Params::TitleMenuUIObject_EnoughInstalledDLC Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InSlot = InSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotEnoughDLCs != nullptr)
		*OutNotEnoughDLCs = std::move(Parms.OutNotEnoughDLCs);

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.AnySaveGameExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::AnySaveGameExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "AnySaveGameExist");

	Params::TitleMenuUIObject_AnySaveGameExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetAccountName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTitleMenuUIObject::GetAccountName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetAccountName");

	Params::TitleMenuUIObject_GetAccountName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetApplicationVersionString
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UTitleMenuUIObject::GetApplicationVersionString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetApplicationVersionString");

	Params::TitleMenuUIObject_GetApplicationVersionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetContinueSlotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTitleMenuUIObject::GetContinueSlotID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetContinueSlotID");

	Params::TitleMenuUIObject_GetContinueSlotID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetCurrentTitleDisplayType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETitleProgressType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETitleProgressType UTitleMenuUIObject::GetCurrentTitleDisplayType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetCurrentTitleDisplayType");

	Params::TitleMenuUIObject_GetCurrentTitleDisplayType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetLouRescueNewGameSlotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTitleMenuUIObject::GetLouRescueNewGameSlotID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetLouRescueNewGameSlotID");

	Params::TitleMenuUIObject_GetLouRescueNewGameSlotID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.GetSlotStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InSlotID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUISaveDataStatus                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUISaveDataStatus UTitleMenuUIObject::GetSlotStatus(int32 InSlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "GetSlotStatus");

	Params::TitleMenuUIObject_GetSlotStatus Parms{};

	Parms.InSlotID = InSlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.HasAnyDLCAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::HasAnyDLCAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "HasAnyDLCAvailable");

	Params::TitleMenuUIObject_HasAnyDLCAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.HasEmptySaveSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::HasEmptySaveSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "HasEmptySaveSlot");

	Params::TitleMenuUIObject_HasEmptySaveSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.InvokeOnShowTitleMenuCallback
// (Final, Native, Public, BlueprintCallable)

void UTitleMenuUIObject::InvokeOnShowTitleMenuCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "InvokeOnShowTitleMenuCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.IsEnableLoadMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsEnableLoadMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsEnableLoadMenu");

	Params::TitleMenuUIObject_IsEnableLoadMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsEnableLouRescueContinueMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsEnableLouRescueContinueMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsEnableLouRescueContinueMenu");

	Params::TitleMenuUIObject_IsEnableLouRescueContinueMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsEnableLouRescueNewGameMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsEnableLouRescueNewGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsEnableLouRescueNewGameMenu");

	Params::TitleMenuUIObject_IsEnableLouRescueNewGameMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsEnableOnlineMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsEnableOnlineMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsEnableOnlineMenu");

	Params::TitleMenuUIObject_IsEnableOnlineMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsEnableQuitGameMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsEnableQuitGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsEnableQuitGameMenu");

	Params::TitleMenuUIObject_IsEnableQuitGameMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsSaveAndReturnToTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameFlowTitleMenuType                  InTitleMenuType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsSaveAndReturnToTitle(EGameFlowTitleMenuType InTitleMenuType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsSaveAndReturnToTitle");

	Params::TitleMenuUIObject_IsSaveAndReturnToTitle Parms{};

	Parms.InTitleMenuType = InTitleMenuType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsSaveDataSelectForLouRescueNewGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsSaveDataSelectForLouRescueNewGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsSaveDataSelectForLouRescueNewGame");

	Params::TitleMenuUIObject_IsSaveDataSelectForLouRescueNewGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.IsSaveExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::IsSaveExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "IsSaveExist");

	Params::TitleMenuUIObject_IsSaveExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.OnChangeTestCharacterView
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsInEnable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::OnChangeTestCharacterView(bool bIsInEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "OnChangeTestCharacterView");

	Params::TitleMenuUIObject_OnChangeTestCharacterView Parms{};

	Parms.bIsInEnable = bIsInEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.TitleMenuUIObject.OnChangeTestCharacterViewCallback
// (Final, Native, Protected)
// Parameters:
// bool                                    bInIsEnable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::OnChangeTestCharacterViewCallback(bool bInIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "OnChangeTestCharacterViewCallback");

	Params::TitleMenuUIObject_OnChangeTestCharacterViewCallback Parms{};

	Parms.bInIsEnable = bInIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.OnChangeTitleProgress
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETitleProgressType                      Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::OnChangeTitleProgress(ETitleProgressType Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "OnChangeTitleProgress");

	Params::TitleMenuUIObject_OnChangeTitleProgress Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.TitleMenuUIObject.OnChangeTitleProgressCallback
// (Final, Native, Protected)
// Parameters:
// ETitleProgressType                      Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::OnChangeTitleProgressCallback(ETitleProgressType Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "OnChangeTitleProgressCallback");

	Params::TitleMenuUIObject_OnChangeTitleProgressCallback Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.OnUserInitializeComplete
// (Final, Native, Protected)
// Parameters:
// const class UCommonUserInfo*            UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestPrivilege                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::OnUserInitializeComplete(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "OnUserInitializeComplete");

	Params::TitleMenuUIObject_OnUserInitializeComplete Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestPrivilege = RequestPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.RequestCheckNetworkAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Result)>            OnCompleted                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::RequestCheckNetworkAvailable(TDelegate<void(bool Result)> OnCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "RequestCheckNetworkAvailable");

	Params::TitleMenuUIObject_RequestCheckNetworkAvailable Parms{};

	Parms.OnCompleted = OnCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.RequestTransition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameFlowTitleMenuType                  TitleMenuType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTitleMenuUIObject::RequestTransition(EGameFlowTitleMenuType TitleMenuType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "RequestTransition");

	Params::TitleMenuUIObject_RequestTransition Parms{};

	Parms.TitleMenuType = TitleMenuType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TitleMenuUIObject.ShowStoreUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTitleMenuUIObject::ShowStoreUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "ShowStoreUI");

	Params::TitleMenuUIObject_ShowStoreUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.TitleMenuUIObject.UpdateDLCAvailabilityCache
// (Final, Native, Public, BlueprintCallable)

void UTitleMenuUIObject::UpdateDLCAvailabilityCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleMenuUIObject", "UpdateDLCAvailabilityCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TreasureBox.K2_OnOpenedTreasureBox
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bInOpened                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureBox::K2_OnOpenedTreasureBox(const bool bInOpened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBox", "K2_OnOpenedTreasureBox");

	Params::TreasureBox_K2_OnOpenedTreasureBox Parms{};

	Parms.bInOpened = bInOpened;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.TreasureBox.OnRep_ReplicatedContext
// (Final, Native, Protected)

void ATreasureBox::OnRep_ReplicatedContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBox", "OnRep_ReplicatedContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TreasureBox.OnStoryFlagRequirementsResultUpdated
// (Native, Protected)
// Parameters:
// const struct FStoryFlagEvaluationFormula&InEvaluationFormula                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureBox::OnStoryFlagRequirementsResultUpdated(const struct FStoryFlagEvaluationFormula& InEvaluationFormula, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBox", "OnStoryFlagRequirementsResultUpdated");

	Params::TreasureBox_OnStoryFlagRequirementsResultUpdated Parms{};

	Parms.InEvaluationFormula = std::move(InEvaluationFormula);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.TreasureBox.UpdateHiddenByGameFlag_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bShouldHide                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureBox::UpdateHiddenByGameFlag_BP(const bool bShouldHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBox", "UpdateHiddenByGameFlag_BP");

	Params::TreasureBox_UpdateHiddenByGameFlag_BP Parms{};

	Parms.bShouldHide = bShouldHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ForceClosableUIInterface.CloseForceClosableUI
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InWidgetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IForceClosableUIInterface::CloseForceClosableUI(class FName InWidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ForceClosableUIInterface", "CloseForceClosableUI");

	Params::ForceClosableUIInterface_CloseForceClosableUI Parms{};

	Parms.InWidgetName = InWidgetName;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Extensions.ForceClosableUIInterface.IsForceClosableUIVisible
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InWidgetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IForceClosableUIInterface::IsForceClosableUIVisible(class FName InWidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ForceClosableUIInterface", "IsForceClosableUIVisible");

	Params::ForceClosableUIInterface_IsForceClosableUIVisible Parms{};

	Parms.InWidgetName = InWidgetName;

	AsUObject()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetFrontWheelRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UVehicleAnimationControlComponent::GetFrontWheelRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetFrontWheelRotation");

	Params::VehicleAnimationControlComponent_GetFrontWheelRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetFrontWheelSpringForce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleAnimationControlComponent::GetFrontWheelSpringForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetFrontWheelSpringForce");

	Params::VehicleAnimationControlComponent_GetFrontWheelSpringForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetLeanRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleAnimationControlComponent::GetLeanRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetLeanRatio");

	Params::VehicleAnimationControlComponent_GetLeanRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetVehicleForce
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVehicleAnimationControlComponent::GetVehicleForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetVehicleForce");

	Params::VehicleAnimationControlComponent_GetVehicleForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetVisualAllBodyTranslate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVehicleAnimationControlComponent::GetVisualAllBodyTranslate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetVisualAllBodyTranslate");

	Params::VehicleAnimationControlComponent_GetVisualAllBodyTranslate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetVisualBodyOnlyTranslate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVehicleAnimationControlComponent::GetVisualBodyOnlyTranslate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetVisualBodyOnlyTranslate");

	Params::VehicleAnimationControlComponent_GetVisualBodyOnlyTranslate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetVisualRollAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleAnimationControlComponent::GetVisualRollAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetVisualRollAngle");

	Params::VehicleAnimationControlComponent_GetVisualRollAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.GetVisualSteeringAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleAnimationControlComponent::GetVisualSteeringAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "GetVisualSteeringAngle");

	Params::VehicleAnimationControlComponent_GetVisualSteeringAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.IsLookBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVehicleAnimationControlComponent::IsLookBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "IsLookBack");

	Params::VehicleAnimationControlComponent_IsLookBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.VehicleAnimationControlComponent.LearSeatFowardBackRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleAnimationControlComponent::LearSeatFowardBackRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAnimationControlComponent", "LearSeatFowardBackRatio");

	Params::VehicleAnimationControlComponent_LearSeatFowardBackRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Extensions.WolfIndicatorUIObject.HideWolfOperationGuide
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWolfIndicatorUIObject::HideWolfOperationGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WolfIndicatorUIObject", "HideWolfOperationGuide");

	Params::WolfIndicatorUIObject_HideWolfOperationGuide Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.WolfIndicatorUIObject.ShowWolfOperationGuide
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWolfIndicatorUIObject::ShowWolfOperationGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WolfIndicatorUIObject", "ShowWolfOperationGuide");

	Params::WolfIndicatorUIObject_ShowWolfOperationGuide Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Extensions.ZenonVehicleAttachActor.BP_Initialize
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AAppWheeledVehiclePawn*           InVehicle                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZenonVehicleAttachActor::BP_Initialize(class AAppWheeledVehiclePawn* InVehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "BP_Initialize");

	Params::ZenonVehicleAttachActor_BP_Initialize Parms{};

	Parms.InVehicle = InVehicle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Extensions.ZenonVehicleAttachActor.BP_RequestDestroy
// (Event, Protected, BlueprintEvent)

void AZenonVehicleAttachActor::BP_RequestDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "BP_RequestDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Extensions.ZenonVehicleAttachActor.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAppWheeledVehiclePawn*           InVehicle                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZenonVehicleAttachActor::Initialize(class AAppWheeledVehiclePawn* InVehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "Initialize");

	Params::ZenonVehicleAttachActor_Initialize Parms{};

	Parms.InVehicle = InVehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ZenonVehicleAttachActor.OnEndPhotoMode
// (Final, Native, Protected)

void AZenonVehicleAttachActor::OnEndPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "OnEndPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ZenonVehicleAttachActor.OnStartPhotoMode
// (Final, Native, Protected)

void AZenonVehicleAttachActor::OnStartPhotoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "OnStartPhotoMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Extensions.ZenonVehicleAttachActor.RequestDestroy
// (Final, Native, Public, BlueprintCallable)

void AZenonVehicleAttachActor::RequestDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZenonVehicleAttachActor", "RequestDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

